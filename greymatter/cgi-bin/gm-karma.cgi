#!/usr/bin/perl

###############################################################################
# Greymatter 1.8.2                            
# Copyright (c)2000-2008, The Greymatter team 
# http://greymatterforum.proboards82.com/     
# By possessing this software, you agree not to hold the author responsible for 
# any problems that may arise from your installation or usage of Greymatter 
# itself, or from any content generated by yourself or others through the use of 
# this program.  You <I>may</I> freely modify and redistribute this program, so 
# long as every copyright notice (including in this manual and in the Greymatter 
# code) remains fully intact.  Finally, you may <I>not</I> sell or in any way 
# make a financial profit from this program, either in original or modified form.
# Your possession of this software signifies that you agree to these terms; 
# please delete your copy of this software if you don't agree to these terms.
# Original Creator Noah Grey
###############################################################################

use lib 'libs';

use CGI::Carp qw(fatalsToBrowser);
use Gm_Constants;
use Gm_Web;
use Gm_Core;

require "gm-library.cgi";

### TODO: refactor into gm_uactions (Gm User Actions) to remove dependancy on gm-library.cgi

%IN = %{Gm_Web::getWebParams( errHandler=>\&Gm_Web::displayUserErrorExit )};

$userip = $ENV{'REMOTE_ADDR'};

&gm_readconfig;
&gm_readtemplates;
&gm_readcounter;

#&gm_karmabancheck;
gm_karmabancheck( $userip );

if( $IN{'entry'} =~ m/\D/gos ){
		## We got a non digit entered, more than likely, this is a hack attempt
		# TODO: INTEGRATE INTO GM_PHPHACKCHECK (AND RENAME), SO WE CAN EMAIL!
		Gm_Web::displayUserErrorExit('A invalid value was given for "entry" when karma voting.');
}
$newcommententrynumberpadded = Gm_Utils::toEntryPadded( $IN{'entry'} );

my $gmEntry = Gm_Storage::getEntry( id=>$IN{'entry'},
	errHandler=>\&Gm_Web::displayUserErrorExit );

## TODO: refactor out usage of variables, make work directly off of entry
$thisentrynumber = $gmEntry->{'entryinfo'}{'id'};
$thisentryauthor = $gmEntry->{'entryinfo'}{'author'};
$thisentrysubject = $gmEntry->{'entryinfo'}{'subject'};
$thisentryweekdaynumber = $gmEntry->{'entryinfo'}{'weekday'};
$thisentrymonth = $gmEntry->{'entryinfo'}{'month'};
$thisentryday = $gmEntry->{'entryinfo'}{'day'};
$thisentryyearyear = $gmEntry->{'entryinfo'}{'year'};
$thisentryhour = $gmEntry->{'entryinfo'}{'hour'};
$thisentryminute = $gmEntry->{'entryinfo'}{'minute'};
$thisentrysecond = $gmEntry->{'entryinfo'}{'second'};
$thisentryampm = $gmEntry->{'entryinfo'}{'ampm'};
$thisentrypositivekarma = $gmEntry->{'entryinfo'}{'karmapos'};
$thisentrynegativekarma = $gmEntry->{'entryinfo'}{'karmaneg'};
$thisentrycommentsnumber = $gmEntry->{'entryinfo'}{'commenttotal'};
$thisentryallowkarma = $gmEntry->{'entryinfo'}{'karma'};
$thisentryallowcomments = $gmEntry->{'entryinfo'}{'comments'};
$thisentryopenstatus = $gmEntry->{'entryinfo'}{'status'};
$thisentrymusic = $gmEntry->{'entryinfo'}{'music'};
$thisentrymood = $gmEntry->{'entryinfo'}{'mood'};
$thisentryemoticonsallowed = $gmEntry->{'entryinfo'}{'emoticons'};

gm_referercheck();
&gm_allowedcheck;
&gm_blankcheck;
&gm_votetwicecheck;
&gm_addkarma;
&gm_freshenafterkarma;

# -------------
# check for ban
# -------------
## TODO MAKE THIS FUNCTION A UTIL OR SOMETHING, ITS IN COMMENTS TOO
sub gm_karmabancheck {
	my $useraddr = shift(@_);

	my $isBanned = Gm_Core::banCheck( ip=>$useraddr );
	if( $isBanned ){	
		my ( $checkthisip, $checkthisiphost, $checkthisperson ) = 
			( $isBanned->{'ip'}, $isBanned->{'host'}, $isBanned->{'label'} );
			
		if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
			my $cp_message = "<span class=\"error_msg\">A banned IP ($checkthisip/$checkthisiphost";
			if ($checkthisperson ne '') { 
				$cp_message .= ", \"$checkthisperson\""; 
			}
			$cp_message .= ") attempted to cast a ".Gm_Utils::sumMsg( Gm_Utils::toWebSafe( $IN{'vote'} )).
				" karma vote on entry #$thisentrynumber</span>";
			Gm_Core::writeToCplog( $cp_message, \&Gm_Web::displayUserErrorExit );			
		}

		Gm_Web::displayUserErrorExit("You have been banned from voting on this site.<BR>(IP: $userip)");
	}
}


## GM Link Limit
# Will check that the commenters does not contain more links than allowed by
# the configuration setting.
sub gm_referercheck {
	if( $commentverifyreferer eq Gm_Constants::YES ){
		my $referer = $ENV{'HTTP_REFERER'} || '';
	
		## check if Web Log Path matches start of incoming URL
		unless( $referer =~ m/^$LogWebPath/i ){
			## Logging	
			my $cpMsg = "<span class=\"error_msg\">($authorIP) attempted to illegally post to entry #".
				$IN{'newcommententrynumber'}." from '".Gm_Utils::sumMsg( Gm_Utils::toWebSafe( $referer ) ).
				"'</span>";
			Gm_Core::writeToCplog(  $cpMsg, \&Gm_Web::displayUserErrorExit );	
		
			## report back to user that they have been blocked
			my $userMessage = 'You have voted from an external site, this is prohibited.';
			Gm_Web::displayUserErrorExit( $userMessage );
		}
	}
}


# --------------------------------
# check if karma votes can be cast
# --------------------------------

sub gm_allowedcheck {

	if (($posttoarchives eq Gm_Constants::NO) && ($thisentrynumber <= $newarchivenumber)) {
		if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
			my $cp_message = "A $IN{'vote'} karma vote was blocked from being added to archived entry #$thisentrynumber";
			Gm_Core::writeToCplog( $cp_message, \&Gm_Web::displayUserErrorExit );
		}
		Gm_Web::displayUserErrorExit('Sorry - karma votes cannot be cast on archived entries. '.
			'Please use your browser\'s Back button to return.');
	}

	if (($thisentryallowkarma eq Gm_Constants::NO) || 
			($thisentryopenstatus eq Gm_Constants::CLOSED) || ($allowkarmaorcomments eq Gm_Constants::COMMENTS) || 
			($allowkarmaorcomments eq Gm_Constants::NEITHER)) {
	
	if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
		my $cp_message = "A $IN{'vote'} karma vote was blocked from being cast on entry #$IN{'newcommententrynumber'}";
		Gm_Core::writeToCplog( $cp_message, \&Gm_Web::displayUserErrorExit );
	}

	Gm_Web::displayUserErrorExit('Sorry - karma votes cannot be cast on this entry. '.
		'Please use your browser\'s Back button to return.');
	}

}

# --------------------------------------
# check if this person has already voted
# --------------------------------------

sub gm_votetwicecheck {

# 	@pastkarmavotes = split (/\|/, $entrylines[1]);
 	@pastkarmavotes = keys( %{$gmEntry->{'karmavotes'}} );	
	$votedtwice = Gm_Constants::NO;
	
	foreach $googoogajoob (@pastkarmavotes) {
		if ($googoogajoob eq $userip) {
			if ($allowmultiplekarmavotes eq Gm_Constants::YES) {
			$votedtwice = Gm_Constants::YES;
			} else {
			
			if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
				my $cp_message = "A repeat karma vote ($IN{'vote'}) was blocked from being added to entry #$thisentrynumber";
				Gm_Core::writeToCplog( $cp_message, \&Gm_Web::displayUserErrorExit );
			}
			
			Gm_Web::displayUserErrorExit('Sorry - you can\'t vote twice on the same entry.  '.
				'Please use your browser\'s Back button to return.');
			}		
		}
	}
}

# ---------------------------
# check if the input is blank
# ---------------------------
sub gm_blankcheck {

	if (($IN{'vote'} eq Gm_Constants::EMPTY) || ($IN{'entry'} eq Gm_Constants::EMPTY)) {	
		Gm_Web::displayUserErrorExit('Error: Blank fields reported in the karma module '.
			'input.  Please report to this site\'s webmaster.');
	}
}

# ------------------
# add the karma vote
# ------------------

sub gm_addkarma {

if ($IN{'vote'} eq 'positive') {
	$thisentrypositivekarma++;
	$newalltimepktotalnumber++;
#	unless ($votedtwice eq Gm_Constants::YES) { $entrylines[1] .= "|$userip|P"; }
	unless ($votedtwice eq Gm_Constants::YES) { 
		$gmEntry->{'karmavotes'}{"$userip"} = 'P'; 
	}
}
if ($IN{'vote'} eq 'negative') {
	$thisentrynegativekarma++;
	$newalltimenktotalnumber++;
#	unless ($votedtwice eq Gm_Constants::YES) { $entrylines[1] .= "|$userip|N"; }
	unless ($votedtwice eq Gm_Constants::YES) { 
		$gmEntry->{'karmavotes'}{"$userip"} = 'N'; 
	}
}

$gmEntry->{'entryinfo'}{'karmapos'} = $thisentrypositivekarma;
$gmEntry->{'entryinfo'}{'karmaneg'} = $thisentrynegativekarma;

Gm_Storage::setEntry( entry=>$gmEntry, errHandler=>\&Gm_Web::displayAdminErrorExit );

}

# ------------------------
# primp, preen, take a bow
# ------------------------

sub gm_freshenafterkarma {

&gm_writecounter;
&gm_readtemplates;

# &gm_getentryvariables($IN{'entry'});
$entryVars = Gm_Core::getEntryVariables( entryid=>$IN{'entry'}, 
	errHandler=>\&Gm_Web::displayAdminErrorExit ); 

## fix the referrer logic, or lack thereof, for $aftermath
## 
$aftermath = $ENV{'HTTP_REFERER'};
## added in 1.3.1 linear

if ($generateentrypages eq Gm_Constants::YES) {
	if ($entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY ) {
#		&gm_formatentry($gmmoreentrypagetemplate);
		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$gmmoreentrypagetemplate, errHandler=>\&Gm_Web::displayAdminErrorExit);		
	} else {
#		&gm_formatentry($gmentrypagetemplate);
		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$gmentrypagetemplate, errHandler=>\&Gm_Web::displayAdminErrorExit);		
	}
## TODO: USE NON-PADDED NUMBER AND USE PAD ENTRY HERE

		Gm_Storage::saveFile( loc=>"$EntriesPath/$newcommententrynumberpadded.$entrysuffix", 
			content=>[$entryreturn],'new'=>1, ch_mod=>'0666', 
			errHandler=>\&Gm_Web::displayAdminErrorExit );
}

if ( $entryVars->{'thisentryisanarchive'} eq Gm_Constants::NO) {
#	&gm_generatemainindex;
	Gm_Core::constructMainIndex( errHandler=>\&Gm_Web::displayUserErrorExit );
} else {
	&gm_readcounter;
# 	$stoppednumber = $newarchivenumber;
# 	do { &gm_generatearchive($stoppednumber); } until $stoppednumber <= 1;
# 	if( $gmneedstogeneratefirstarchive ){ &gm_generatearchive(1); }
	## startnum could be more precise, if we could figure out which entry starts the month of the 
	# entry that was commented on, we could give that and tell to only build it, instead of all archives
	Gm_Core::constructArchives( startnum=>$newarchivenumber,  
		errHandler=>\&Gm_Web::displayUserErrorExit );	
}

&gm_readconfig;

if (($NotifyForStatus eq Gm_Constants::KARMA) || ($NotifyForStatus eq Gm_Constants::BOTH)) {
if ($NotifyEmail ne "") {

# &gm_getentryvariables($IN{'entry'});
$entryVars = Gm_Core::getEntryVariables( entryid=>$IN{'entry'}, 
	errHandler=>\&Gm_Web::displayAdminErrorExit ); 

my $emailMsg = "A $IN{'vote'} karma vote has just been cast by $userip IP on entry ".
	"#$thisentrynumber ($thisentrysubject).  That brings this entry to $thisentrypositivekarma ".
	"positive and $thisentrynegativekarma negative karma votes for a ".
	"$entryVars->{'thisentrytotalkarma'} total karma rating.";

Gm_Core::sendEmail( to=>$NotifyEmail, subject=>'Notice: Karma Vote Cast', 
	body=>$emailMsg );


}
}

if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
	Gm_Core::writeToCplog( "<I>A $IN{'vote'} karma vote was cast on entry #$thisentrynumber ".
		"($thisentrysubject) by IP: $userip</I>", \&Gm_Web::displayUserErrorExit );

}

## Time to send user back to page came from
Gm_Web::displayUserRedirectExit( $aftermath );

exit;

}

