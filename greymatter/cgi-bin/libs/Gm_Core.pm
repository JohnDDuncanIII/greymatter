package Gm_Core;

###############################################################################
# Greymatter 1.8.2  
# Copyright (c)2000-2008, The Greymatter team 
# http://greymatterforum.proboards82.com/     
# By possessing this software, you agree not to hold the author responsible for 
# any problems that may arise from your installation or usage of Greymatter 
# itself, or from any content generated by yourself or others through the use of 
# this program.  You <I>may</I> freely modify and redistribute this program, so 
# long as every copyright notice (including in this manual and in the Greymatter 
# code) remains fully intact.  Finally, you may <I>not</I> sell or in any way 
# make a financial profit from this program, either in original or modified form.
# Your possession of this software signifies that you agree to these terms; 
# please delete your copy of this software if you don't agree to these terms.
# Original Creators Noah Grey
###############################################################################

#==============================================================================
# Note no exporting because items from this package should be fully qualified
## Gm Core
# This package groups functions that deal with the core
# functionality of GreyMatter:
# - Admin screen functionality (but not display), such as writting to cplog, checking banned IPs
# - Template Variable Translation
# - Text Localization
# - Configuration value retrieval (Gm can't run without configs)
#
# CONVENTIONS
# 1. Return a string rather than printing, this is just more elegant.  Leave prints
#   to the calling subroutine, if possible (especially if the calling subroutine is dealing
#   with displaying information to the user)
# 2. Private subroutines should start with the '_' character.  By private I mean
#   it will never be called outside of this package.
# 3. If you have more than 1 or 2 parameters, especially if they are not required,
#   use named parameters such as in createRadioButton.  By putting stuff in a 
#   hash we gain the flexibility to add more optional parameters without having
#   to pass in '' placeholders or modify existing code.
# 4. Subs starting with 'create' or 'get' should return a string.
# 5. Subs starting with 'display' are expected to contain print statements
# 6. Use ' and " where appropriate.  If you don't have any variables or newlines
# then use ', its quicker and cleaner.  
# 7. Don't put all text on one huge long line.  It messes with some programs
# that don't do line wraps.  
#
# Some usefull DEBUG: warn join( ', ', map { $_ = "$_ = $params{$_}" } keys( %params ) );	

use strict;
use warnings;

use Gm_Constants;
use Gm_Storage;
use Gm_Utils;
use Gm_Web;
use Gm_Security;

# Global vars that are highly used, maybe make local sometime
my $CONFIGS = Gm_Storage::getConfigs( errHandler=>\&Gm_Web::displayAdminErrorExit );
my $TEMPLATES = Gm_Storage::getTemplates( errHandler=>\&Gm_Web::displayAdminErrorExit );

# Global Language labels
my %LABELS = ();
%LABELS = %{Gm_Storage::loadLanguage( Gm_Constants::DEFAULT_LANG )};
#warn 'default language loaded';  ## leave until no more 'require gm_library' in gm.cgi

## Config
# This gets the set config for the supplied config name (should be constants?)
# ARG1: the configuration label for the requested config value
# RETURNS: the value for which the label was given
## MOVE TO STORAGE -- OR MAKE THIS WRAPPER
sub config {
	my $label = shift( @_ );
	my $value =  Gm_Constants::EMPTY;
	
	if( defined( $label ) ){
		$value = defined( $CONFIGS->{ $label } ) ? $CONFIGS->{ $label } : Gm_Constants::EMPTY;
	}
	return( $value );
}


## Text
# this gets the labels string for a given constant
# ARG1: the label to return text from
# (opt) ARG2: a hash reference to the parameters to replace on the returned label,
# e.g. a string ENTRIES that equates to this 'There are $NUM entries' should be 
#  called like this: Lang::getText( Lang::ENTRIES, { NUM=>'5' } );
#  or this: Lang::getText( Lang::ENTRIES, \%params );
#  which will return: 'There are 5 entries'
# Note that if no ARG2 is provided, the string will be unchanged i.e. the user will
#  see 'There are $NUM entries'
# RETURNS: localized text
sub text {
	my $label = shift( @_ ) || Gm_Constants::EMPTY;
	my $params = shift( @_ ) || {};
	
	my $theText = defined( $LABELS{ $label } ) ? $LABELS{ $label } : Gm_Constants::EMPTY;
	
	foreach my $p ( keys( %$params ) ){
		## TODO: SHOULD CHECK IF VALUE DEFINED?
		$theText =~ s/\$$p/$params->{$p}/gis;
	}
	
	return( $theText );
}


## Set Language
# this sets the language of the given author
# ARG author=> the hash returned by getAuthors, for a particular author
sub setLanguage {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $author = $params{'author'} || {};
	
	my $lang = $author->{'lang'};
	
	if( $lang ){
		my %newLabels = %{Gm_Storage::loadLanguage( $lang )};
		## We are overlapping the labels here, so that if the new loaded language might
		# be missing any new labels, that the default labels will still be used, so that
		# some text is shown, rather than no text at all!
		%LABELS = (%LABELS, %newLabels );
	}
}


# ---------------
# write to cp log
# ---------------
## Write to Control Panel Log
# shorthand to write to the control panel log, used by admin
# or user, but must pass handler if want error to look right
# ARGS1 = message to write to control panel
# (opt) ARGS2 = error handler
# DEPRECATES: gm_writetocplog
sub writeToCplog {
	my $writetologtext = shift(@_);
	# forcewrite is required so that when diagnostics and repair are run, it will log, this is required
	#  since hasDiagRun requires that Diagnostics and Repair has modified the cplog
	my $forcewrite = shift(@_) || '';
	
	my $errHandler = shift(@_) || \&Gm_Utils::gmWarn;

	if( $CONFIGS->{'gmkeeplog'} eq Gm_Constants::YES || $forcewrite ){
		my ($gmdate) = Gm_Utils::getStdDate( $CONFIGS->{'gmserveroffset'} );
		my $authorIp = $ENV{'REMOTE_ADDR'};
		## Checking to see if message was sanitized
		if( Gm_Security::hackWebTest( $writetologtext ) ){
			$writetologtext = '<span class="error_msg">[Aborted log - '.
			'Hack Attempt]</span> by <b>'.$ENV{'REMOTE_ADDR'}.'</b>';
		}
	
		## TODO: make the date and ip and message some sort of internal format, such as :: seperated
		# then markup on display, so that we aren't storing data that is preformated (prevents date formats
		# for other countries, etc.  LOCALIZE
		Gm_Storage::addLogMessage( msg=>"<font size=\"1\">[$gmdate] [$authorIp]".
			"</font> $writetologtext", errHandler=>$errHandler );
	}
} 


## Ban Check
# Determines if a given ip has been 'banned'
# ARG ip => the ip address to check if banned, usually from the 'REMOTE_ADDR' environment
#  variable
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: 0 if not banned, the Banlist entry if banned (so can access 'ip', 'host', etc.)
sub banCheck {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $currentip = $params{'ip'} || $ENV{'REMOTE_ADDR'};
	
	my $gmbanlist = Gm_Storage::getBanlist( errHandler=>$errHandler );
	my $isBanned = 0;
 
	foreach my $gmbanlistline ( keys(%$gmbanlist)) {
		my ($checkthisip, $checkthisiphost, $checkthisperson) = 
			($gmbanlist->{$gmbanlistline}{'ip'}, $gmbanlist->{$gmbanlistline}{'host'}, 
			 $gmbanlist->{$gmbanlistline}{'label'} );
		
		## This will make the checkthisip string safe, so that it can be run through a regex
		# otherwise a string like '1.2.3.4)' will cause gm to die.
		my $safeip = quotemeta( $checkthisip );

		if (($currentip =~ m/$safeip/) && ($checkthisip ne Gm_Constants::EMPTY)) {
			$isBanned = $gmbanlist->{$gmbanlistline};
			last;
		}
	}
	
	return( $isBanned );
}


## Process Ban Check
# Determines if a given ip has been 'banned' and logs it and returns message to the user
# ARG ip => the ip address to check if banned, usually from the 'REMOTE_ADDR' environment
#  variable
# ARG action => the action the user was trying to perform
# (opt) ARG errHandler => the error handler used to display errors
# DEPRECATES: gm_bancheck
sub processBanCheck {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $currentip = $params{'ip'} || $ENV{'REMOTE_ADDR'};
	my $action = $params{'action'} || 'accessing this program';
	
	my $isBanned = banCheck( ip=>$currentip, errHandler=>$errHandler );
	if( $isBanned ){
		# Logging...
		my $banLabel = $isBanned->{'label'} ? ", \"$isBanned->{'label'}\"" : ''; 
		my $cpMsg = '<span class="error_msg">'.Gm_Core::text( Gm_Constants::BANNED_ACCESS, 
			{ IP=>$isBanned->{'ip'}, HOST=>$banLabel, ACTION=>$action } ).'</span>';
		Gm_Core::writeToCplog( $cpMsg );
		
		# Tell them why
		&$errHandler( Gm_Core::text( Gm_Constants::BANNED_DENY, { IP=>$ENV{'REMOTE_ADDR'}, 
			ACTION=>$action } ));
	}
}


## Reconstruct Entrylist (should this be just 'Construct'?
# Goes through each entry and creates and saves the entrylist file
# (opt) ARG errHandler => the error handler used to display errors
sub reconstructEntrylist {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	
	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );
	## validating 
	if( !defined( $gmCounters->{'entrytotal'} ) || 
		$gmCounters->{'entrytotal'} =~ m/\D/gi ){
		&$errHandler( 'There is an issue with gm-counters, please run Diagnostic and Repair and'.
			' check the gm-counters file.' );
	}

	## TODO: THIS CODE DUPLICATES IN GM_DIAGNOSTICSPERFORM
	#	$checkentrycounter = $newentrynumber;
	my $checkentrycounter = $gmCounters->{'entrytotal'};
	my %rebuiltentrylist = ();
	do {
		my $checkentrycounterpadded = Gm_Utils::toEntryPadded( $checkentrycounter );

		my $entryVars = getEntryVariables( entryid=>$checkentrycounter, 
			errHandler=>$errHandler );	
		my $checkentryopenstatus = 'O';
		my $checkentrymorestatus = Gm_Constants::N;
		if( $entryVars->{'thisentryopenstatus'} eq Gm_Constants::CLOSED ){ 
			$checkentryopenstatus = 'C'; 
		}
		if( $entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY ){ 
			$checkentrymorestatus = Gm_Constants::Y; 
		}
		## TODO: SHOULD THIS DO DIAGNOSTICS?  SHOULD IT REPAIR?
		$rebuiltentrylist{$entryVars->{'thisentrynumber'}} = { id=>$entryVars->{'thisentrynumber'}, 
			author=>$entryVars->{'thisentryauthor'}, subject=>$entryVars->{'thisentrysubject'}, 
			created=>"$entryVars->{'thisentrymonthmonth'}\/$entryVars->{'thisentrydayday'}\/$entryVars->{'thisentryyear'}",
			createt=>"$entryVars->{'thisentryhourhour'}\:$entryVars->{'thisentryminuteminute'} $entryVars->{'thisentryampm'}", status=>$checkentryopenstatus,
			extended=>$checkentrymorestatus, music=>$entryVars->{'thisentrymusic'}, mood=>$entryVars->{'thisentrymood'},
			emoticons=>$entryVars->{'thisentryemoticonsallowed'} };
		$checkentrycounter--;
	} until $checkentrycounter < 1;
	
	Gm_Storage::setEntrylist( list=>\%rebuiltentrylist, errHandler=>$errHandler );
}	


## Translate Archive Templates
# Takes all the templates setup by the getArchiveVariables and applies them to
# and gm template tokens in the given template string
# ARG template => the template to which the given vars should be applied
# ARG archiveVars => the output of getArchiveVariables
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a string that has had the archive variables applied to the given template
# DEPRECATES: entrylistsubsub
sub translateArchiveTemplates {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $listsubsub = $params{'template'} || '';
	my $archiveVars = $params{'archiveVars'} || 
		&$errHandler('Invalid archiveVars parameter passed to translateArchiveTemplates');

	####
	## TODO REFACTOR THIS INTO A LOOP, SIMPLY DO /{{$KEY}}/$A->{$KEY}/GI
	### VARIABLES HAVE TO BE RENAMED TO TEMPLATE NAMES FOR SOME
	$listsubsub =~ s/{{year}}/$archiveVars->{'loglistyear'}/gi;
	$listsubsub =~ s/{{yearyear}}/$archiveVars->{'loglistyearyear'}/gi;
	$listsubsub =~ s/{{month}}/$archiveVars->{'loglistmonth'}/gi;
	$listsubsub =~ s/{{monthmonth}}/$archiveVars->{'loglistmonthmonth'}/gi;
	$listsubsub =~ s/{{monthword}}/$archiveVars->{'loglistmonthword'}/gi;
	$listsubsub =~ s/{{monthwordshort}}/$archiveVars->{'loglistmonthwordshort'}/gi;
	$listsubsub =~ s/{{monthwordupper}}/$archiveVars->{'loglistmonthwordupper'}/gi;
	$listsubsub =~ s/{{monthwordlower}}/$archiveVars->{'loglistmonthwordlower'}/gi;
	$listsubsub =~ s/{{monthworduppershort}}/$archiveVars->{'loglistmonthworduppershort'}/gi;
	$listsubsub =~ s/{{monthwordlowershort}}/$archiveVars->{'loglistmonthwordlowershort'}/gi;
	$listsubsub =~ s/{{day}}/$archiveVars->{'loglistday'}/gi;
	$listsubsub =~ s/{{dayday}}/$archiveVars->{'loglistdayday'}/gi;
	$listsubsub =~ s/{{hour}}/$archiveVars->{'loglisthour'}/gi;
	$listsubsub =~ s/{{hourhour}}/$archiveVars->{'loglisthourhour'}/gi;
	$listsubsub =~ s/{{militaryhour}}/$archiveVars->{'loglistmilitaryhour'}/gi;
	$listsubsub =~ s/{{minute}}/$archiveVars->{'loglistminute'}/gi;
	$listsubsub =~ s/{{minuteminute}}/$archiveVars->{'loglistminuteminute'}/gi;
	$listsubsub =~ s/{{ampm}}/$archiveVars->{'loglistampm'}/gi;
	$listsubsub =~ s/{{ampmlower}}/$archiveVars->{'loglistampmlower'}/gi;
	$listsubsub =~ s/{{ampmdot}}/$archiveVars->{'loglistampmdot'}/gi;
	$listsubsub =~ s/{{ampmdotlower}}/$archiveVars->{'loglistampmdotlower'}/gi;
	$listsubsub =~ s/{{author}}/$archiveVars->{'loglistauthor'}/gi; ## DUPLICATED BELOW, but needed?
	$listsubsub =~ s/{{entrysubject}}/$archiveVars->{'loglistsubject'}/gi;
	$listsubsub =~ s/{{entrynumber}}/$archiveVars->{'loglistnumber'}/gi;
	$listsubsub =~ s/{{entrynumberpadded}}/$archiveVars->{'loglistnumberpadded'}/gi;
	$listsubsub =~ s/{{pagelink}}/$archiveVars->{'loglistpagelink'}/gi;
	$listsubsub =~ s/{{pagearchivelogindexlink}}/$archiveVars->{'loglistpagearchivelogindexlink'}/gi;
	$listsubsub =~ s/{{entrymusic}}/$archiveVars->{'loglistentrymusic'}/gi;
	$listsubsub =~ s/{{entrymood}}/$archiveVars->{'loglistentrymood'}/gi;

	if ($listsubsub =~ m/{{author/i) {
		$listsubsub =~ s/{{author}}/$archiveVars->{'loglistentryauthor'}/gi;
		$listsubsub =~ s/{{authoremail}}/$archiveVars->{'loglistentryauthoremail'}/gi;
		$listsubsub =~ s/{{authorhomepage}}/$archiveVars->{'loglistentryauthorhomepage'}/gi;
		$listsubsub =~ s/{{authorentrycount}}/$archiveVars->{'loglistentryauthorentrycount'}/gi;
	}

	if (($listsubsub =~ m/{{weekbeginning/i) || ($listsubsub =~ m/{{weekending/i)) {
		$listsubsub =~ s/{{weekbeginningday}}/$archiveVars->{'loglistweekbeginningday'}/gi;
		$listsubsub =~ s/{{weekbeginningdayday}}/$archiveVars->{'loglistweekbeginningdayday'}/gi;
		$listsubsub =~ s/{{weekbeginningmonth}}/$archiveVars->{'loglistweekbeginningmonth'}/gi;
		$listsubsub =~ s/{{weekbeginningmonthmonth}}/$archiveVars->{'loglistweekbeginningmonthmonth'}/gi;
		$listsubsub =~ s/{{weekbeginningyear}}/$archiveVars->{'loglistweekbeginningyear'}/gi;
		$listsubsub =~ s/{{weekbeginningyearyear}}/$archiveVars->{'loglistweekbeginningyearyear'}/gi;
		$listsubsub =~ s/{{weekbeginningweekday}}/$archiveVars->{'loglistweekbeginningweekday'}/gi;
		$listsubsub =~ s/{{weekbeginningweekdayshort}}/$archiveVars->{'loglistweekbeginningweekdayshort'}/gi;	
		$listsubsub =~ s/{{weekbeginningmonthword}}/$archiveVars->{'loglistweekbeginningmonthword'}/gi;
		$listsubsub =~ s/{{weekbeginningmonthwordshort}}/$archiveVars->{'loglistweekbeginningmonthwordshort'}/gi;
		$listsubsub =~ s/{{weekbeginningweekdayupper}}/$archiveVars->{'loglistweekbeginningweekdayupper'}/gi;
		$listsubsub =~ s/{{weekbeginningmonthwordupper}}/$archiveVars->{'loglistweekbeginningmonthwordupper'}/gi;
		$listsubsub =~ s/{{weekbeginningweekdaylower}}/$archiveVars->{'loglistweekbeginningweekdaylower'}/gi;
		$listsubsub =~ s/{{weekbeginningmonthwordlower}}/$archiveVars->{'loglistweekbeginningmonthwordlower'}/gi;
		$listsubsub =~ s/{{weekbeginningweekdayuppershort}}/$archiveVars->{'loglistweekbeginningweekdayuppershort'}/gi;
		$listsubsub =~ s/{{weekbeginningmonthworduppershort}}/$archiveVars->{'loglistweekbeginningmonthworduppershort'}/gi;
		$listsubsub =~ s/{{weekbeginningweekdaylowershort}}/$archiveVars->{'loglistweekbeginningweekdaylowershort'}/gi;
		$listsubsub =~ s/{{weekbeginningmonthwordlowershort}}/$archiveVars->{'loglistweekbeginningmonthwordlowershort'}/gi;
		$listsubsub =~ s/{{weekendingday}}/$archiveVars->{'loglistweekendingday'}/gi;
		$listsubsub =~ s/{{weekendingdayday}}/$archiveVars->{'loglistweekendingdayday'}/gi;
		$listsubsub =~ s/{{weekendingmonth}}/$archiveVars->{'loglistweekendingmonth'}/gi;
		$listsubsub =~ s/{{weekendingmonthmonth}}/$archiveVars->{'loglistweekendingmonthmonth'}/gi;
		$listsubsub =~ s/{{weekendingyear}}/$archiveVars->{'loglistweekendingyear'}/gi;
		$listsubsub =~ s/{{weekendingyearyear}}/$archiveVars->{'loglistweekendingyearyear'}/gi;
		$listsubsub =~ s/{{weekendingweekday}}/$archiveVars->{'loglistweekendingweekday'}/gi;
		$listsubsub =~ s/{{weekendingweekdayshort}}/$archiveVars->{'loglistweekendingweekdayshort'}/gi;
		$listsubsub =~ s/{{weekendingmonthword}}/$archiveVars->{'loglistweekendingmonthword'}/gi;
		$listsubsub =~ s/{{weekendingmonthwordshort}}/$archiveVars->{'loglistweekendingmonthwordshort'}/gi;
		$listsubsub =~ s/{{weekendingweekdayupper}}/$archiveVars->{'loglistweekendingweekdayupper'}/gi;
		$listsubsub =~ s/{{weekendingmonthwordupper}}/$archiveVars->{'loglistweekendingmonthwordupper'}/gi;
		$listsubsub =~ s/{{weekendingweekdaylower}}/$archiveVars->{'loglistweekendingweekdaylower'}/gi;
		$listsubsub =~ s/{{weekendingmonthwordlower}}/$archiveVars->{'loglistweekendingmonthwordlower'}/gi;
		$listsubsub =~ s/{{weekendingweekdayuppershort}}/$archiveVars->{'loglistweekendingweekdayuppershort'}/gi;
		$listsubsub =~ s/{{weekendingmonthworduppershort}}/$archiveVars->{'loglistweekendingmonthworduppershort'}/gi;
		$listsubsub =~ s/{{weekendingweekdaylowershort}}/$archiveVars->{'loglistweekendingweekdaylowershort'}/gi;
		$listsubsub =~ s/{{weekendingmonthwordlowershort}}/$archiveVars->{'loglistweekendingmonthwordlowershort'}/gi;
	}

	if (($listsubsub =~ m/karma}}/i) || ($listsubsub =~ m/karmalink}}/i)) {
		$listsubsub =~ s/{{positivekarmalink}}/$archiveVars->{'loglistentrypositivekarmalink'}/gi;
		$listsubsub =~ s/{{negativekarmalink}}/$archiveVars->{'loglistentrynegativekarmalink'}/gi;
		$listsubsub =~ s/{{positivekarma}}/$archiveVars->{'loglistentrypositivekarma'}/gi;
		$listsubsub =~ s/{{negativekarma}}/$archiveVars->{'loglistentrynegativekarma'}/gi;
		$listsubsub =~ s/{{totalkarma}}/$archiveVars->{'loglistentrytotalkarma'}/gi;
	}

	if ($listsubsub =~ m/{{comments/i) {
		$listsubsub =~ s/{{commentsnumber}}/$archiveVars->{'loglistentrycommentsnumber'}/gi;
		$listsubsub =~ s/{{commentstatussmart}}/$archiveVars->{'loglistentrycommentstatussmart'}/gi;
		$listsubsub =~ s/{{commentstatussmartupper}}/$archiveVars->{'loglistentrycommentstatussmartupper'}/gi;
		$listsubsub =~ s/{{commentstatussmartlower}}/$archiveVars->{'loglistentrycommentstatussmartlower'}/gi;
	}

	if( $listsubsub =~ m/{{entry/i ){
		$listsubsub =~ s/{{entrymainbody}}/$archiveVars->{'loglistmainbody'}/gi;
		$listsubsub =~ s/{{entrymorebody}}/$archiveVars->{'loglistmorebody'}/gi;
	##	$listsubsub =~ s/{{entrycomments}}/$loglistcomments/gi; ## NO REFERENCE, COPY AND PASTE?

		if( $listsubsub =~ m/{{entrymainbodyfirstwords (\d+)}}/i ){
			until( $listsubsub !~ m/{{entrymainbodyfirstwords (\d+)}}/isg ){
				my $firstwordscount = $1;
				my $grabmainbodywords = $archiveVars->{'loglistmainbody'};
				if( $grabmainbodywords =~ m/{{link/i ){
					$grabmainbodywords =~ s/({{linkmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
					$grabmainbodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
					$grabmainbodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
	
					# {{linkblank}} TEMPLATE VARIABLE SO THAT CAN USE target="_blank" TO OPEN NEW WINDOWS
					$grabmainbodywords =~ s/({{linkblankmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
					$grabmainbodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
					$grabmainbodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
				}
				if( $grabmainbodywords =~ m/{{email/i ){
					$grabmainbodywords =~ s/({{emailmo) (\S+\@\S+?) (.+?)(\|)(.+?)(}})/$3/isg;
					$grabmainbodywords =~ s/({{email) (\S+\@\S+?)(}})/$2/isg;
					$grabmainbodywords =~ s/({{email) (\S+\@\S+?) (.+?)(}})/$3/isg;
				}
				## TODO: REFACTOR THIS TO UTIL
				$grabmainbodywords =~ s/<([^>]|\n)*>/ /g;
				$grabmainbodywords =~ s/{{(.*?)}}/ /g;
				$grabmainbodywords =~ s/\n/ /g;
				$grabmainbodywords =~ s/\r/ /g;
				$grabmainbodywords =~ s/\|\*\|/ /g;
				$grabmainbodywords =~ s/^\s+//;
				$grabmainbodywords =~ s/\s+$//;
				$grabmainbodywords =~ s/\s{2,}/ /g;
				my @grabmainbodywordslist = split (/ /, $grabmainbodywords);

				my @finalmainbodywordslist = ();
				if( $firstwordscount < 1 ){ 
					$firstwordscount = 1; 
				}

				for( my $i = 0; $i < $firstwordscount; $i++ ){
#					$finalmainbodywordslist[$i] = $grabmainbodywordslist[$i];
					push( @finalmainbodywordslist, $grabmainbodywordslist[$i] ) 
						if( defined( $grabmainbodywordslist[$i] ) );
				}
				my $finalmainbodyfirstwords = join (' ', @finalmainbodywordslist);
				$finalmainbodyfirstwords =~ s/^\s+//;
				$finalmainbodyfirstwords =~ s/\s+$//;
				$finalmainbodyfirstwords =~ s/\s{2,}//g;
				if( substr($finalmainbodyfirstwords, -1) =~ /\W/ ) { 
					chop($finalmainbodyfirstwords);
				}
				if( substr($finalmainbodyfirstwords, -1) eq ' ' ){ 
					chop($finalmainbodyfirstwords);
				}
				$listsubsub =~ s/{{entrymainbodyfirstwords ($firstwordscount)}}/$finalmainbodyfirstwords/isg;
			}
		}
		if( $listsubsub =~ m/{{entrymorebodyfirstwords (\d+)}}/i ){
			until( $listsubsub !~ m/{{entrymorebodyfirstwords (\d+)}}/isg ){
				my $firstwordscount = $1;
				if( $archiveVars->{'loglistmorebody'} eq Gm_Constants::EMPTY ){
					$listsubsub =~ s/{{entrymorebodyfirstwords ($firstwordscount)}}//isg;
				} else {
					my $grabmorebodywords = $archiveVars->{'loglistmorebody'};
					if ($grabmorebodywords =~ m/{{link/i) {
						$grabmorebodywords =~ s/({{linkmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
						$grabmorebodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
						$grabmorebodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;

						# ADDED {{linkblank}} TEMPLATE VARIABLE SO CAN USE target="_blank" TO OPEN NEW WINDOWS
						$grabmorebodywords =~ s/({{linkblankmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
						$grabmorebodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
						$grabmorebodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
					}
					if ($grabmorebodywords =~ m/{{email/i) {
						$grabmorebodywords =~ s/({{emailmo) (\S+\@\S+?) (.+?)(\|)(.+?)(}})/$3/isg;
						$grabmorebodywords =~ s/({{email) (\S+\@\S+?)(}})/$2/isg;
						$grabmorebodywords =~ s/({{email) (\S+\@\S+?) (.+?)(}})/$3/isg;
					}
					$grabmorebodywords =~ s/<([^>]|\n)*>/ /g;
					$grabmorebodywords =~ s/{{(.*?)}}/ /g;
					$grabmorebodywords =~ s/\n/ /g;
					$grabmorebodywords =~ s/\r/ /g;
					$grabmorebodywords =~ s/\|\*\|/ /g;
					$grabmorebodywords =~ s/^\s+//;
					$grabmorebodywords =~ s/\s+$//;
					$grabmorebodywords =~ s/\s{2,}/ /g;
					my @grabmorebodywordslist = split (/ /, $grabmorebodywords);
		
					my @finalmorebodywordslist = ();
					if( $firstwordscount < 1 ){ 
						$firstwordscount = 1; 
					}

					for( my $i = 0; $i < $firstwordscount; $i++ ){
#						$finalmorebodywordslist[$i] = $grabmorebodywordslist[$i];
						push( @finalmorebodywordslist, $grabmorebodywordslist[$i] ) 
							if( defined( $grabmorebodywordslist[$i] ) );
					}

					my $finalmorebodyfirstwords = join (' ', @finalmorebodywordslist);
					$finalmorebodyfirstwords =~ s/^\s+//;
					$finalmorebodyfirstwords =~ s/\s+$//;
					$finalmorebodyfirstwords =~ s/\s{2,}//g;
					if( substr($finalmorebodyfirstwords, -1) =~ /\W/ ){ 
						chop($finalmorebodyfirstwords);
					}
					if( substr($finalmorebodyfirstwords, -1) eq ' ' ){ 
						chop($finalmorebodyfirstwords); 
					}
					$listsubsub =~ s/{{entrymorebodyfirstwords ($firstwordscount)}}/$finalmorebodyfirstwords/isg;
				}
			}
		}
	} # End of 	if( $listsubsub =~ m/{{entry/i ){

	return( $listsubsub );
}


## Translate Entry Templates
# Takes all the templates setup by the getEntryVariables and applies them to
# and gm template tokens in the entry
# ARG template => the template to apply the tokens to
# ARG entryVars => the output of getEntryVariables
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a hash reference that contains the variables
# DEPRECATES: gm_formatentry
sub translateEntryTemplates {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $entrygetreturn = $params{'template'} || '';
	my $entryVars = $params{'entryVars'} || 
		&$errHandler('Invalid entryVars parameter passed to translateEntryTemplates');

	my $gmEntrylist = Gm_Storage::getEntrylist( errHandler=>$errHandler );
	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );
	

	my $domain = $CONFIGS->{'gmcgiwebpath'};
	$domain =~ s@http://([^\/]+)?.*@$1@;

	my $entryreturn = $entrygetreturn;

# $entryreturn =~ s/\|\*\|/\n/g;  ## WHY IS THIS COMMENTED OUT?  I DIDN'T DO THIS

## TODO: MAKE GENERIC TRANSLATE ENTRY, THIS IS NOT ENTRY SPECIFIC
	if( ($entryreturn =~ m/{{header}}/i) || ($entryreturn =~ m/{{footer}}/i) || 
		($entryreturn =~ m/{{sidebar}}/i) ){
		$entryreturn =~ s/{{header}}/$TEMPLATES->{'gmheadertemplate'}/gi;
		$entryreturn =~ s/{{footer}}/$TEMPLATES->{'gmfootertemplate'}/gi;
		$entryreturn =~ s/{{sidebar}}/$TEMPLATES->{'gmsidebartemplate'}/gi;
	}

## TODO: MAKE GENERIC TRANSLATE ENTRY, THIS IS NOT ENTRY SPECIFIC
	if ($entryreturn =~ m/{{custom/i) {
		$entryreturn =~ s/{{customone}}/$TEMPLATES->{'gmcustomonetemplate'}/gi;
		$entryreturn =~ s/{{customtwo}}/$TEMPLATES->{'gmcustomtwotemplate'}/gi;
		$entryreturn =~ s/{{customthree}}/$TEMPLATES->{'gmcustomthreetemplate'}/gi;
		$entryreturn =~ s/{{customfour}}/$TEMPLATES->{'gmcustomfourtemplate'}/gi;
		$entryreturn =~ s/{{customfive}}/$TEMPLATES->{'gmcustomfivetemplate'}/gi;
		$entryreturn =~ s/{{customsix}}/$TEMPLATES->{'gmcustomsixtemplate'}/gi;
		$entryreturn =~ s/{{customseven}}/$TEMPLATES->{'gmcustomseventemplate'}/gi;
		$entryreturn =~ s/{{customeight}}/$TEMPLATES->{'gmcustomeighttemplate'}/gi;
		$entryreturn =~ s/{{customnine}}/$TEMPLATES->{'gmcustomninetemplate'}/gi;
		$entryreturn =~ s/{{customten}}/$TEMPLATES->{'gmcustomtentemplate'}/gi;
	}

	if( $entryreturn =~ m/{{logarchivelist}}/i ){
		if( $CONFIGS->{'gmkeepmonthlyarchives'} eq Gm_Constants::NO ){
			$entryreturn =~ s/{{logarchivelist}}//gi;
		} else {
			my $logarchivelistfinal = generateArchiveLogList( entryVars=>$entryVars,
				errHandler=>$errHandler );
			$entryreturn =~ s/{{logarchivelist}}/$logarchivelistfinal/gi;
		}
	}

	if( $CONFIGS->{'gmgenerateentrypages'} eq Gm_Constants::YES ){
		if( ($entryreturn =~ m/{{logshortentrylist/i) || ($entryreturn =~ m/{{logmoreentrylist/i) || 
			($entryreturn =~ m/{{logentrylist/i) ){		
			my $entryLogVars = generateEntryLogList( errHandler=>$errHandler );
			
			$entryreturn =~ s/{{logshortentrylist}}/$entryLogVars->{'logshortentrylistfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist}}/$entryLogVars->{'logmoreentrylistfinal'}/gi;
			$entryreturn =~ s/{{logentrylist}}/$entryLogVars->{'logentrylistfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist month}}/$entryLogVars->{'logshortentrylistmonthfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist day}}/$entryLogVars->{'logshortentrylistdayfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist year}}/$entryLogVars->{'logshortentrylistyearfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist month}}/$entryLogVars->{'logmoreentrylistmonthfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist day}}/$entryLogVars->{'logmoreentrylistdayfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist year}}/$entryLogVars->{'logmoreentrylistyearfinal'}/gi;
			$entryreturn =~ s/{{logentrylist month}}/$entryLogVars->{'logentrylistmonthfinal'}/gi;
			$entryreturn =~ s/{{logentrylist day}}/$entryLogVars->{'logentrylistdayfinal'}/gi;
			$entryreturn =~ s/{{logentrylist year}}/$entryLogVars->{'logentrylistyearfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist number}}/$entryLogVars->{'logshortentrylistnumberfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist number}}/$entryLogVars->{'logmoreentrylistnumberfinal'}/gi;
			$entryreturn =~ s/{{logentrylist number}}/$entryLogVars->{'logentrylistnumberfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist firsthalf}}/$entryLogVars->{'logshortentrylistfirsthalffinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist secondhalf}}/$entryLogVars->{'logshortentrylistsecondhalffinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist firsthalf}}/$entryLogVars->{'logmoreentrylistfirsthalffinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist secondhalf}}/$entryLogVars->{'logmoreentrylistsecondhalffinal'}/gi;
			$entryreturn =~ s/{{logentrylist firsthalf}}/$entryLogVars->{'logentrylistfirsthalffinal'}/gi;
			$entryreturn =~ s/{{logentrylist secondhalf}}/$entryLogVars->{'logentrylistsecondhalffinal'}/gi;
		}
		if( ($entryreturn =~ m/{{logshortentrylist comments/i) || 
			($entryreturn =~ m/{{logmoreentrylist comments/i) || ($entryreturn =~ m/{{logentrylist comments/i) ){

			my $entryLogCommentVars = generateEntryLogListComments( errHandler=>$errHandler );

			$entryreturn =~ s/{{logshortentrylist comments}}/$entryLogCommentVars->{'logshortentrylistfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist comments}}/$entryLogCommentVars->{'logmoreentrylistfinal'}/gi;
			$entryreturn =~ s/{{logentrylist comments}}/$entryLogCommentVars->{'logentrylistfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist commentsminimum}}/$entryLogCommentVars->{'logshortminimumentrylistfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist commentsminimum}}/$entryLogCommentVars->{'logmoreminimumentrylistfinal'}/gi;
			$entryreturn =~ s/{{logentrylist commentsminimum}}/$entryLogCommentVars->{'logminimumentrylistfinal'}/gi;
			$entryreturn =~ s/{{logshortentrylist commentsnumber}}/$entryLogCommentVars->{'logshortnumberentrylistfinal'}/gi;
			$entryreturn =~ s/{{logmoreentrylist commentsnumber}}/$entryLogCommentVars->{'logmorenumberentrylistfinal'}/gi;
			$entryreturn =~ s/{{logentrylist commentsnumber}}/$entryLogCommentVars->{'lognumberentrylistfinal'}/gi;
		}
		if (($entryreturn =~ m/{{logshortentrylist /i) || ($entryreturn =~ m/{{logmoreentrylist /i) || 
				($entryreturn =~ m/{{logentrylist /i)) {
	
			my $gmauthors = Gm_Storage::getAuthors( errHandler=>$errHandler );
	
			foreach my $author ( keys( %$gmauthors ) ) {
				my $thisentryloglistauthor = $gmauthors->{$author}{'author'};

				my $entryLogAuthorVars = generateEntryLogListAuthor( author=>$thisentryloglistauthor, 
					errHandler=>$errHandler );

				$entryreturn =~ s/{{logshortentrylist $thisentryloglistauthor}}/$entryLogAuthorVars->{'logshortentrylistfinal'}/gi;
				$entryreturn =~ s/{{logmoreentrylist $thisentryloglistauthor}}/$entryLogAuthorVars->{'logmoreentrylistfinal'}/gi;
				$entryreturn =~ s/{{logentrylist $thisentryloglistauthor}}/$entryLogAuthorVars->{'logentrylistfinal'}/gi;
			}
		}
	} ## End of if generate entry pages

	if (($entryreturn =~ m/{{calendar}}/i) || ($entryreturn =~ m/{{calendarweek}}/i)) {
		my $usethisentryweekdaynumber = $entryVars->{'thisentryweekdaynumber'};
		my $usethisentryday = $entryVars->{'thisentryday'};
		my $usethisentrymonth = $entryVars->{'thisentrymonth'};
		my $usethisentrymonthmonth = $entryVars->{'thisentrymonthmonth'};
		my $usethisentrymonthword = $entryVars->{'thisentrymonthword'};
		my $usethisentryyear = $entryVars->{'thisentryyear'};
		my $usethisentryyearyear = $entryVars->{'thisentryyearyear'};
									
		my ($calendarfull, $calendarweekfull) = generateCalendar( entryVars=>$entryVars, 
			errHandler=>$errHandler );

		$entryreturn =~ s/{{calendar}}/$calendarfull/gi;
		$entryreturn =~ s/{{calendarweek}}/$calendarweekfull/gi;
	}

	if( $entryreturn =~ m/{{calendar (..)\/(..)}}/i ){
		my @sortedentries = sort { $gmEntrylist->{$b}{'id'} <=> $gmEntrylist->{$a}{'id'} } keys( %$gmEntrylist );
		until( $entryreturn !~ m/{{calendar (..)\/(..)}}/ig ){
	
			my $usethisentrymonthmonth = $1;
			my $usethisentryyear = $2;
	
			my $gotthecalendarmonth = Gm_Constants::NO;
			foreach my $entry ( @sortedentries ) {
				my $loglistnumber = $gmEntrylist->{$entry}{'id'};
				my $loglistauthor = $gmEntrylist->{$entry}{'author'};
				my $loglistsubject = $gmEntrylist->{$entry}{'subject'};
				my $loglistdate = $gmEntrylist->{$entry}{'created'};
				my $loglisttimeampm = $gmEntrylist->{$entry}{'createt'};
				my $loglistopenstatus = $gmEntrylist->{$entry}{'status'};
				my $loglistmorestatus = $gmEntrylist->{$entry}{'extended'};
				my $loglistentrymusic = $gmEntrylist->{$entry}{'music'};
				my $loglistentrymood = $gmEntrylist->{$entry}{'mood'};
				my $loglistemoticonstatus = $gmEntrylist->{$entry}{'emoticons'};
				my $gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$entry} , 
					errHandler=>$errHandler );
				if( ($gmLogListVars->{loglistmonthmonth} eq $usethisentrymonthmonth) && 
					($gmLogListVars->{'loglistyear'} eq $usethisentryyear) && 
					($gotthecalendarmonth eq Gm_Constants::NO) ){
					my %temp = ();
					$temp{'usethisentryweekdaynumber'} = $gmLogListVars->{'loglistentryweekdaynumber'};
					$temp{'usethisentryday'} = $gmLogListVars->{'loglistday'};
					$temp{'usethisentrymonth'} = $gmLogListVars->{'loglistmonth'};
					$temp{'usethisentrymonthword'} = $gmLogListVars->{'loglistmonthword'};
					$temp{'usethisentryyearyear'} = $gmLogListVars->{'loglistyearyear'};
					## wonky ness to not pollute entryVars
					%temp = ( %temp, %$entryVars );

					my ($calendarfull, $calendarweekfull) = generateCalendar( entryVars=>\%temp, 
						errHandler=>$errHandler );
					$entryreturn =~ s/{{calendar $usethisentrymonthmonth\/$usethisentryyear}}/$calendarfull/gi;
					$gotthecalendarmonth = Gm_Constants::YES;
				}
			}
			## seem to be deleting if not in the entries ( just finished looping )
			if ($entryreturn =~ m/{{calendar $usethisentrymonthmonth\/$usethisentryyear}}/i) {
				$entryreturn =~ s/{{calendar $usethisentrymonthmonth\/$usethisentryyear}}//gi;
			}
	
		}
	
	}

# emoticons can be off, so we provide {{smartemoticonscode}} to print them only when they are needed/wanted
	if( ($entryreturn =~ m/{{commentdivider}}/i) || ($entryreturn =~ m/{{entrycommentsform}}/i) || 
		($entryreturn =~ m/{{entrykarmaform}}/i) || ($entryreturn =~ m/{{searchform}}/i) ){
		$entryreturn =~ s/{{commentdivider}}/$entryVars->{'thisentrycommentdivider'}/gi;
		$entryreturn =~ s/{{entrycommentsform}}/$entryVars->{'thisentrycommentsform'}/gi;
		$entryreturn =~ s/{{entrykarmaform}}/$entryVars->{'thisentrykarmaform'}/gi;
		$entryreturn =~ s/{{searchform}}/$entryVars->{'thisentrysearchform'}/gi;
	}


	if( $entryreturn =~ m/{{entry/i ){
		$entryreturn =~ s/{{entrymainbody}}/$entryVars->{'thisentrymainbody'}/gi;
		$entryreturn =~ s/{{entrymorebody}}/$entryVars->{'thisentrymorebody'}/gi;
		$entryreturn =~ s/{{entrycomments}}/$entryVars->{'thisentrycomments'}/gi;
		if( $entryreturn =~ m/{{entrymainbodyfirstwords (\d+)}}/i ){
			until( $entryreturn !~ m/{{entrymainbodyfirstwords (\d+)}}/isg ){
				my $firstwordscount = $1;
				my $grabmainbodywords = $entryVars->{'thisentrymainbody'};
				if( $grabmainbodywords =~ m/{{link/i ){
					$grabmainbodywords =~ s/({{linkmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
					$grabmainbodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
					$grabmainbodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
					# ADDED {{linkblank}} TEMPLATE VARIABLE TO USE target="_blank" TO OPEN NEW WINDOWS
					$grabmainbodywords =~ s/({{linkblankmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
					$grabmainbodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
					$grabmainbodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
				}
				if( $grabmainbodywords =~ m/{{email/i ){
					$grabmainbodywords =~ s/({{emailmo) (\S+\@\S+?) (.+?)(\|)(.+?)(}})/$3/isg;
					$grabmainbodywords =~ s/({{email) (\S+\@\S+?)(}})/$2/isg;
					$grabmainbodywords =~ s/({{email) (\S+\@\S+?) (.+?)(}})/$3/isg;
				}
				## TODO: REFACTOR THIS TO UTILS
				$grabmainbodywords =~ s/<([^>]|\n)*>/ /g;
				$grabmainbodywords =~ s/{{(.*?)}}/ /g;
				$grabmainbodywords =~ s/\n/ /g;
				$grabmainbodywords =~ s/\r/ /g;
				$grabmainbodywords =~ s/\|\*\|/ /g;
				$grabmainbodywords =~ s/^\s+//;
				$grabmainbodywords =~ s/\s+$//;
				$grabmainbodywords =~ s/\s{2,}/ /g;

				my @grabmainbodywordslist = split (/ /, $grabmainbodywords);
				my @finalmainbodywordslist = ();
				if( $firstwordscount < 1 ){ 
					$firstwordscount = 1; 
				}
				
				for( my $i = 0; $i < $firstwordscount; $i++ ){
#					$finalmainbodywordslist[$i] = $grabmainbodywordslist[$i];
					push( @finalmainbodywordslist, $grabmainbodywordslist[$i] ) 
						if( defined( $grabmainbodywordslist[$i] ) );
				}
				my $finalmainbodyfirstwords = join (' ', @finalmainbodywordslist);
				$finalmainbodyfirstwords =~ s/^\s+//;
				$finalmainbodyfirstwords =~ s/\s+$//;
				$finalmainbodyfirstwords =~ s/\s{2,}//g;
				if( substr($finalmainbodyfirstwords, -1 ) =~ /\W/) { 
					chop($finalmainbodyfirstwords);  ## TODO: could this be chomped?
				}
				if( substr($finalmainbodyfirstwords, -1) eq ' '){ 
					chop($finalmainbodyfirstwords);  ## TODO: CHOMP?
				}
				$entryreturn =~ s/{{entrymainbodyfirstwords ($firstwordscount)}}/$finalmainbodyfirstwords/isg;
			}
		}
		## TODO: THIS SECTION SIMILAR TO ABOVE, MAKE SUBROUTINE?
		if( $entryreturn =~ m/{{entrymorebodyfirstwords (\d+)}}/i ){
			until( $entryreturn !~ m/{{entrymorebodyfirstwords (\d+)}}/isg ){
				my $firstwordscount = $1;
				if( $entryVars->{'thisentrymorebody'} eq Gm_Constants::EMPTY ){
					$entryreturn =~ s/{{entrymorebodyfirstwords ($firstwordscount)}}//isg;
				} else {
					my $grabmorebodywords = $entryVars->{'thisentrymorebody'};
					if( $grabmorebodywords =~ m/{{link/i ){
						$grabmorebodywords =~ s/({{linkmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
						$grabmorebodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
						$grabmorebodywords =~ s/({{link) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
						# ADDED {{linkblank}} TEMPLATE VARIABLE TO USE target="_blank" TO OPEN NEW WINDOWS
						$grabmorebodywords =~ s/({{linkblankmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/$4/isg;
						$grabmorebodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?)(}})/$2$3/isg;
						$grabmorebodywords =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/$4/isg;
					}
					if ($grabmorebodywords =~ m/{{email/i) {
						$grabmorebodywords =~ s/({{emailmo) (\S+\@\S+?) (.+?)(\|)(.+?)(}})/$3/isg;
						$grabmorebodywords =~ s/({{email) (\S+\@\S+?)(}})/$2/isg;
						$grabmorebodywords =~ s/({{email) (\S+\@\S+?) (.+?)(}})/$3/isg;
					}
					$grabmorebodywords =~ s/<([^>]|\n)*>/ /g;
					$grabmorebodywords =~ s/{{(.*?)}}/ /g;
					$grabmorebodywords =~ s/\n/ /g;
					$grabmorebodywords =~ s/\r/ /g;
					$grabmorebodywords =~ s/\|\*\|/ /g;
					$grabmorebodywords =~ s/^\s+//;
					$grabmorebodywords =~ s/\s+$//;
					$grabmorebodywords =~ s/\s{2,}/ /g;
					my @grabmorebodywordslist = split (/ /, $grabmorebodywords);
					my @finalmorebodywordslist = ();
					if( $firstwordscount < 1 ){ 
						$firstwordscount = 1; 
					}
					for( my $i = 0; $i < $firstwordscount; $i++ ){
#						$finalmorebodywordslist[$i] = $grabmorebodywordslist[$i];
						push( @finalmorebodywordslist, $grabmorebodywordslist[$i] ) 
							if( defined( $grabmorebodywordslist[$i] ) );
					}
					my $finalmorebodyfirstwords = join (' ', @finalmorebodywordslist);
					$finalmorebodyfirstwords =~ s/^\s+//;
					$finalmorebodyfirstwords =~ s/\s+$//;
					$finalmorebodyfirstwords =~ s/\s{2,}//g;
					if( substr($finalmorebodyfirstwords, -1) =~ /\W/ ){ 
						chop($finalmorebodyfirstwords);  ## TODO: CHOMP?
					}
					if( substr($finalmorebodyfirstwords, -1) eq ' ' ){ 
						chop($finalmorebodyfirstwords); ## TODO: CHOMP?
					}
					$entryreturn =~ s/{{entrymorebodyfirstwords ($firstwordscount)}}/$finalmorebodyfirstwords/isg;
				}
			}
		}
	}


	if (($entryreturn =~ m/link}}/i) || ($entryreturn =~ m/{{morepreface}}/i)) {
		$entryreturn =~ s/{{karmalink}}/$entryVars->{'thisentrykarmalink'}/gi;
		$entryreturn =~ s/{{commentslink}}/$entryVars->{'thisentrycommentslink'}/gi;
		$entryreturn =~ s/{{pagelink}}/$entryVars->{'thisentrypagelink'}/gi;
		$entryreturn =~ s/{{pageindexlink}}/$entryVars->{'thisentrypageindexlink'}/gi;
		$entryreturn =~ s/{{pagearchiveindexlink}}/$entryVars->{'thisentrypagearchiveindexlink'}/gi;
		$entryreturn =~ s/{{pagearchivelogindexlink}}/$entryVars->{'thisentrypagearchivelogindexlink'}/gi;
		$entryreturn =~ s/{{pagesmartindexlink}}/$entryVars->{'thisentrypagesmartindexlink'}/gi;
		$entryreturn =~ s/{{commentspostlink}}/$entryVars->{'thisentrycommentspostlink'}/gi;
		$entryreturn =~ s/{{authorsmartlink}}/$entryVars->{'thisentryauthorsmartlink'}/gi;
	}

	if( ($entryreturn =~ m/karma}}/i) || ($entryreturn =~ m/karmalink}}/i) ){
		$entryreturn =~ s/{{positivekarmalink}}/$entryVars->{'thisentrypositivekarmalink'}/gi;
		$entryreturn =~ s/{{negativekarmalink}}/$entryVars->{'thisentrynegativekarmalink'}/gi;
		$entryreturn =~ s/{{positivekarma}}/$entryVars->{'thisentrypositivekarma'}/gi;
		$entryreturn =~ s/{{negativekarma}}/$entryVars->{'thisentrynegativekarma'}/gi;
		$entryreturn =~ s/{{totalkarma}}/$entryVars->{'thisentrytotalkarma'}/gi;
	}

	if( $entryreturn =~ m/{{smart/i ){
		if ($entryVars->{'thisentrymusic'} ne Gm_Constants::EMPTY) {
				$entryreturn =~ s/{{smartentrymusic}}/$TEMPLATES->{'gmsmartentrymusictemplate'}/gi;
		} else {
					$entryreturn =~ s/{{smartentrymusic}}//gi;
			}
		if ($entryVars->{'thisentrymood'} ne Gm_Constants::EMPTY) {
				$entryreturn =~ s/{{smartentrymood}}/$TEMPLATES->{'gmsmartentrymoodtemplate'}/gi;
		} else {
					$entryreturn =~ s/{{smartentrymood}}//gi;
			}
	}

	if( $entryreturn =~ m/{{entry/i ){
		$entryreturn =~ s/{{entrysubject}}/$entryVars->{'thisentrysubject'}/gi;

		# ADDED 1 TEMPLATE VARIABLE SO THAT I CAN STRIP THE HTML CODE FROM THE ENTRYSUBJECT
		# WHEN IT IS USED IN THE <TITLE> TAG
		my $thisentrysubjectstripped = $entryVars->{'thisentrysubject'};
		$thisentrysubjectstripped =~ s/<.*?>//gi;
		$thisentrysubjectstripped =~ s/<\/.*?>//gi;
		$entryreturn =~ s/{{entrysubjectstripped}}/$thisentrysubjectstripped/gi;

		$entryreturn =~ s/{{entrynumber}}/$entryVars->{'thisentrynumber'}/gi;
		$entryreturn =~ s/{{entrynumberpadded}}/$entryVars->{'thisentrynumberpadded'}/gi;
	
		$entryreturn =~ s/{{entrymusic}}/$entryVars->{'thisentrymusic'}/gi;
		my $thisentrymood = translateEmoticons( $entryVars->{'thisentrymood'} );
		$entryreturn =~ s/{{entrymood}}/$thisentrymood/gi;
		# end additions
	}
	if( $entryreturn =~ m/{{author/i ){
		$entryreturn =~ s/{{author}}/$entryVars->{'thisentryauthor'}/gi;
		$entryreturn =~ s/{{authoremail}}/$entryVars->{'thisentryauthoremail'}/gi;
		$entryreturn =~ s/{{authorhomepage}}/$entryVars->{'thisentryauthorhomepage'}/gi;
		$entryreturn =~ s/{{authorentrycount}}/$entryVars->{'thisentryauthorentrycount'}/gi;
	}

	if (($entryreturn =~ m/{{authoremail /i) || ($entryreturn =~ m/{{authorhomepage /i) || 
		($entryreturn =~ m/{{authorentrycount /i) || ($entryreturn =~ m/{{authoremaillink /i) || 
		($entryreturn =~ m/{{authorhomepagelink /i) || ($entryreturn =~ m/{{authorsmartlink /i)) {
		$entryreturn = translateExternalAuthorVariables( line=>$entryreturn, entryVars=>$entryVars, 
			errHandler=>$errHandler );
	}

	if ($entryreturn =~ m/{{comments/i) {
		$entryreturn =~ s/{{commentstatussmart}}/$entryVars->{'thisentrycommentstatussmart'}/gi;
		$entryreturn =~ s/{{commentstatussmartupper}}/$entryVars->{'thisentrycommentstatussmartupper'}/gi;
		$entryreturn =~ s/{{commentstatussmartlower}}/$entryVars->{'thisentrycommentstatussmartlower'}/gi;
		$entryreturn =~ s/{{commentsnumber}}/$entryVars->{'thisentrycommentsnumber'}/gi;
	}

	if( ($entryreturn =~ m/{{day/i) || ($entryreturn =~ m/{{month/i) || 
		($entryreturn =~ m/{{year/i) || ($entryreturn =~ m/{{hour/i) || 
		($entryreturn =~ m/{{minute/i) || ($entryreturn =~ m/{{second/i) || 
		($entryreturn =~ m/{{weekday/i) || ($entryreturn =~ m/{{militaryhour}}/i) || 
		($entryreturn =~ m/{{ampm/i) || ($entryreturn =~ m/{{timezone}}/i) ){
		$entryreturn =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
		$entryreturn =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
		$entryreturn =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
		$entryreturn =~ s/{{hour}}/$entryVars->{'thisentryhour'}/gi;
		$entryreturn =~ s/{{minute}}/$entryVars->{'thisentryminute'}/gi;
		$entryreturn =~ s/{{second}}/$entryVars->{'thisentrysecond'}/gi;
		$entryreturn =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
		$entryreturn =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
		$entryreturn =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
		$entryreturn =~ s/{{hourhour}}/$entryVars->{'thisentryhourhour'}/gi;
		$entryreturn =~ s/{{minuteminute}}/$entryVars->{'thisentryminuteminute'}/gi;
		$entryreturn =~ s/{{secondsecond}}/$entryVars->{'thisentrysecondsecond'}/gi;
		$entryreturn =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
		$entryreturn =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;	
		$entryreturn =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
		$entryreturn =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;	
		$entryreturn =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
		$entryreturn =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
		$entryreturn =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
		$entryreturn =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
		$entryreturn =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
		$entryreturn =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
		$entryreturn =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
		$entryreturn =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
		$entryreturn =~ s/{{militaryhour}}/$entryVars->{'thisentrymilitaryhour'}/gi;
		$entryreturn =~ s/{{ampm}}/$entryVars->{'thisentryampm'}/gi;
		$entryreturn =~ s/{{ampmdot}}/$entryVars->{'thisentryampmdot'}/gi;
		$entryreturn =~ s/{{ampmlower}}/$entryVars->{'thisentryampmlower'}/gi;
		$entryreturn =~ s/{{ampmdotlower}}/$entryVars->{'thisentryampmdotlower'}/gi;
		$entryreturn =~ s/{{timezone}}/$CONFIGS->{'gmtimezone'}/gi;
		my $thisentrydayappend = Gm_Utils::toOrdinal( $entryVars->{'thisentryday'} );
		$entryreturn =~ s/{{dayappend}}/$thisentrydayappend/gi;
	}

	if( ($entryreturn =~ m/{{weekbeginning/i) || ($entryreturn =~ m/{{weekending/i) ){
		$entryreturn =~ s/{{weekbeginningday}}/$entryVars->{'thisentryweekbeginningday'}/gi;
		$entryreturn =~ s/{{weekbeginningdayday}}/$entryVars->{'thisentryweekbeginningdayday'}/gi;
		$entryreturn =~ s/{{weekbeginningmonth}}/$entryVars->{'thisentryweekbeginningmonth'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthmonth}}/$entryVars->{'thisentryweekbeginningmonthmonth'}/gi;
		$entryreturn =~ s/{{weekbeginningyear}}/$entryVars->{'thisentryweekbeginningyear'}/gi;
		$entryreturn =~ s/{{weekbeginningyearyear}}/$entryVars->{'thisentryweekbeginningyearyear'}/gi;
		$entryreturn =~ s/{{weekbeginningweekday}}/$entryVars->{'thisentryweekbeginningweekday'}/gi;
		$entryreturn =~ s/{{weekbeginningweekdayshort}}/$entryVars->{'thisentryweekbeginningweekdayshort'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthword}}/$entryVars->{'thisentryweekbeginningmonthword'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthwordshort}}/$entryVars->{'thisentryweekbeginningmonthwordshort'}/gi;
		$entryreturn =~ s/{{weekbeginningweekdayupper}}/$entryVars->{'thisentryweekbeginningweekdayupper'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthwordupper}}/$entryVars->{'thisentryweekbeginningmonthwordupper'}/gi;
		$entryreturn =~ s/{{weekbeginningweekdaylower}}/$entryVars->{'thisentryweekbeginningweekdaylower'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthwordlower}}/$entryVars->{'thisentryweekbeginningmonthwordlower'}/gi;
		$entryreturn =~ s/{{weekbeginningweekdayuppershort}}/$entryVars->{'thisentryweekbeginningweekdayuppershort'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthworduppershort}}/$entryVars->{'thisentryweekbeginningmonthworduppershort'}/gi;
		$entryreturn =~ s/{{weekbeginningweekdaylowershort}}/$entryVars->{'thisentryweekbeginningweekdaylowershort'}/gi;
		$entryreturn =~ s/{{weekbeginningmonthwordlowershort}}/$entryVars->{'thisentryweekbeginningmonthwordlowershort'}/gi;
		$entryreturn =~ s/{{weekendingday}}/$entryVars->{'thisentryweekendingday'}/gi;
		$entryreturn =~ s/{{weekendingdayday}}/$entryVars->{'thisentryweekendingdayday'}/gi;
		$entryreturn =~ s/{{weekendingmonth}}/$entryVars->{'thisentryweekendingmonth'}/gi;
		$entryreturn =~ s/{{weekendingmonthmonth}}/$entryVars->{'thisentryweekendingmonthmonth'}/gi;
		$entryreturn =~ s/{{weekendingyear}}/$entryVars->{'thisentryweekendingyear'}/gi;
		$entryreturn =~ s/{{weekendingyearyear}}/$entryVars->{'thisentryweekendingyearyear'}/gi;
		$entryreturn =~ s/{{weekendingweekday}}/$entryVars->{'thisentryweekendingweekday'}/gi;
		$entryreturn =~ s/{{weekendingweekdayshort}}/$entryVars->{'thisentryweekendingweekdayshort'}/gi;	
		$entryreturn =~ s/{{weekendingmonthword}}/$entryVars->{'thisentryweekendingmonthword'}/gi;
		$entryreturn =~ s/{{weekendingmonthwordshort}}/$entryVars->{'thisentryweekendingmonthwordshort'}/gi;	
		$entryreturn =~ s/{{weekendingweekdayupper}}/$entryVars->{'thisentryweekendingweekdayupper'}/gi;
		$entryreturn =~ s/{{weekendingmonthwordupper}}/$entryVars->{'thisentryweekendingmonthwordupper'}/gi;
		$entryreturn =~ s/{{weekendingweekdaylower}}/$entryVars->{'thisentryweekendingweekdaylower'}/gi;
		$entryreturn =~ s/{{weekendingmonthwordlower}}/$entryVars->{'thisentryweekendingmonthwordlower'}/gi;
		$entryreturn =~ s/{{weekendingweekdayuppershort}}/$entryVars->{'thisentryweekendingweekdayuppershort'}/gi;
		$entryreturn =~ s/{{weekendingmonthworduppershort}}/$entryVars->{'thisentryweekendingmonthworduppershort'}/gi;
		$entryreturn =~ s/{{weekendingweekdaylowershort}}/$entryVars->{'thisentryweekendingweekdaylowershort'}/gi;
		$entryreturn =~ s/{{weekendingmonthwordlowershort}}/$entryVars->{'thisentryweekendingmonthwordlowershort'}/gi;
	}

	if( $entryreturn =~ m/{{link/i ){
		$entryreturn =~ s/({{linkmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/<a href="$2$3" onmouseover="window.status='$6';return true" onmouseout="window.status='';return true">$4<\/a>/isg;
		$entryreturn =~ s/({{link) (http|https|ftp)(:\/\/\S+?)(}})/<a href="$2$3">$2$3<\/a>/isg;
		$entryreturn =~ s/({{link) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/<a href="$2$3">$4<\/a>/isg;
		# ADDED {{linkblank}} TEMPLATE VARIABLE TO USE target="_blank" TO OPEN NEW WINDOWS
		$entryreturn =~ s/({{linkblankmo) (http|https|ftp)(:\/\/\S+?) (.+?)(\|)(.+?)(}})/<A HREF="$2$3" onMouseOver="window.status='$6';return true" onMouseOut="window.status='';return true" target="_blank">$4<\/A>/isg;
		$entryreturn =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?)(}})/<A HREF="$2$3" target="_blank">$2$3<\/A>/isg;
		$entryreturn =~ s/({{linkblank) (http|https|ftp)(:\/\/\S+?) (.+?)(}})/<A HREF="$2$3" target="_blank">$4<\/A>/isg;	
	}

	if ($entryreturn =~ m/{{email/i) {
		$entryreturn =~ s/({{emailmo) (\S+\@\S+?) (.+?)(\|)(.+?)(}})/<a href="mailto:$2" onmouseover="window.status='$5';return true" onmouseout="window.status='';return true">$3<\/>/isg;
		$entryreturn =~ s/({{email) (\S+\@\S+?)(}})/<a href="mailto:$2">$2<\/a>/isg;
		$entryreturn =~ s/({{email) (\S+\@\S+?) (.+?)(}})/<a href="mailto:$2">$3<\/a>/isg;
	}

	if( $entryreturn =~ m/{{popup (\S+) (.+?) (\d+)x(\d+)}}/i ){
		until( $entryreturn !~ m/{{popup (\S+) (.+?) (\d+)x(\d+)}}/isg ){
	
			my $popupfile = $1;
			my $popuptitle = $2;
			my $popupwidth = $3;
			my $popupheight = $4;
			my $popuphtmlfile = $1;
			$popuphtmlfile =~ s/\.(\S+)$//;
			$popuphtmlfile .= '.'.$CONFIGS->{'gmentrysuffix'};
			my $popuppage = $TEMPLATES->{'gmpopuppagetemplate'};
			my $popupcode = $TEMPLATES->{'gmpopupcodetemplate'};
			$popuppage =~ s/{{popupfile}}/$popupfile/gi;
			$popuppage =~ s/{{popuphtmlfile}}/$popuphtmlfile/gi;
			$popuppage =~ s/{{popuptitle}}/$popuptitle/gi;
			$popuppage =~ s/{{popupwidth}}/$popupwidth/gi;
			$popuppage =~ s/{{popupheight}}/$popupheight/gi;
			$popupcode =~ s/{{popupfile}}/$popupfile/gi;
			$popupcode =~ s/{{popuphtmlfile}}/$popuphtmlfile/gi;
			$popupcode =~ s/{{popuptitle}}/$popuptitle/gi;
			$popupcode =~ s/{{popupwidth}}/$popupwidth/gi;
			$popupcode =~ s/{{popupheight}}/$popupheight/gi;
			$popuppage =~ s/{{cgiwebpath}}/$CONFIGS->{'gmcgiwebpath'}/gi;
			$popuppage =~ s/{{entrieswebpath}}/$CONFIGS->{'gmentrieswebpath'}/gi;
			$popuppage =~ s/{{logwebpath}}/$CONFIGS->{'gmlogwebpath'}/gi;
			$popuppage =~ s/{{emoticonspath}}/$CONFIGS->{'gmemoticonspath'}/gi;
	
			my $foundpopupmatch = Gm_Constants::NO;

			my $thisentrynumber = $entryVars->{'thisentrynumber'};  
			my $gmLogListVars = {};
			if( exists( $gmEntrylist->{$thisentrynumber} ) ){
				my $loglistnumber = $gmEntrylist->{$thisentrynumber}{'id'};
				my $loglistauthor = $gmEntrylist->{$thisentrynumber}{'author'};
				my $loglistsubject = $gmEntrylist->{$thisentrynumber}{'subject'};
				my $loglistdate = $gmEntrylist->{$thisentrynumber}{'created'};
				my $loglisttimeampm = $gmEntrylist->{$thisentrynumber}{'createt'};
				my $loglistopenstatus = $gmEntrylist->{$thisentrynumber}{'status'};
				my $loglistmorestatus = $gmEntrylist->{$thisentrynumber}{'extended'};
				$gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$thisentrynumber}, 
					errHandler=>$errHandler );
				$foundpopupmatch = Gm_Constants::YES;
			}
	
			my $listsubsub = translateArchiveTemplates( template=>$popuppage, 
				archiveVars=>$gmLogListVars, errHandler=>$errHandler );
	
			Gm_Storage::saveFile( loc=>"$CONFIGS->{'gmentriespath'}/$popuphtmlfile", content=>[$listsubsub],
				'new'=>1, errHandler=>$errHandler );
	
			$listsubsub = translateArchiveTemplates( template=>$popupcode, 
				archiveVars=>$gmLogListVars, errHandler=>$errHandler );
	
			$entryreturn =~ s/{{popup $popupfile $popuptitle ($popupwidth)x($popupheight)}}/$listsubsub/isg;
		}
	}

	if( ($entryreturn =~ m/{{previous/i) || ($entryreturn =~ m/{{next/i) ){
		$entryreturn =~ s/{{previousmore/{{moreprevious/isg;
		$entryreturn =~ s/{{nextmore/{{morenext/isg;
	
		if( $entryVars->{'thisentrynumber'} ne '1' ){
			my $thispreviousentrynumber = $entryVars->{'thisentrynumber'} - 1;
			my $foundregular = Gm_Constants::NO;
			my $foundmore = Gm_Constants::NO;
			my $foundboth = Gm_Constants::NO;
			my @sortedentries = sort { $gmEntrylist->{$a}{'id'} <=> $gmEntrylist->{$b}{'id'} } keys( %$gmEntrylist );
			@sortedentries = reverse( splice( @sortedentries, 0, $thispreviousentrynumber ) );
				foreach my $entry ( @sortedentries ) {
					my $loglistnumber = $gmEntrylist->{$entry}{'id'};
					my $loglistauthor = $gmEntrylist->{$entry}{'author'};
					my $loglistsubject = $gmEntrylist->{$entry}{'subject'};
					my $loglistdate = $gmEntrylist->{$entry}{'created'};
					my $loglisttimeampm = $gmEntrylist->{$entry}{'createt'};
					my $loglistopenstatus = $gmEntrylist->{$entry}{'status'};
					my $loglistmorestatus = $gmEntrylist->{$entry}{'extended'};
	
					## probably don't need this logic anymore, but it never hurts, it should always be true...
					if( ($loglistnumber < $entryVars->{'thisentrynumber'}) && 
						($foundregular eq Gm_Constants::NO) && ($loglistopenstatus ne 'C') ){
						$entryreturn =~ s/{{previouslink}}/$TEMPLATES->{'gmpreviouslinktemplate'}/isg;
						my $gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$entry}, 
							errHandler=>$errHandler );
						my $listsubsub = $entryreturn;
						$listsubsub =~ s/{{previous/{{/isg;
						$listsubsub = translateArchiveTemplates( template=>$listsubsub,
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$entryreturn = $listsubsub;
						$foundregular = Gm_Constants::YES;
					}
					if( ($loglistmorestatus eq 'Y') && 
						($loglistnumber < $entryVars->{'thisentrynumber'}) && ($foundmore eq Gm_Constants::NO) && 
						($loglistopenstatus ne 'C') ){
						$entryreturn =~ s/{{morepreviouslink}}/$TEMPLATES->{'gmpreviousmorelinktemplate'}/isg;
						$entryreturn =~ s/{{previousmore/{{moreprevious/isg;
						my $gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$entry}, 
							errHandler=>$errHandler );
						my $listsubsub = $entryreturn;
						$listsubsub =~ s/{{moreprevious/{{/isg;
						$listsubsub = translateArchiveTemplates( template=>$listsubsub,
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$entryreturn = $listsubsub;
						$foundmore = Gm_Constants::YES;
					}
					
					if( ($foundregular eq Gm_Constants::YES) && ($foundmore eq Gm_Constants::YES) ){ 
						$foundboth = Gm_Constants::YES; 
						last;
					}					
				}
	
		}

		if( $entryVars->{'thisentrynumber'} ne $gmCounters->{'entrytotal'} ){
			my $thisnextentrynumber = $entryVars->{'thisentrynumber'} + 1;
			my $foundregular = Gm_Constants::NO;
			my $foundmore = Gm_Constants::NO;
			my $foundboth = Gm_Constants::NO;
			my @sortedentries = sort { $gmEntrylist->{$a}{'id'} <=> $gmEntrylist->{$b}{'id'} } keys( %$gmEntrylist );
			@sortedentries = splice( @sortedentries, $thisnextentrynumber-1 );
				foreach my $entry ( @sortedentries ) {
					my $loglistnumber = $gmEntrylist->{$entry}{'id'};
					my $loglistauthor = $gmEntrylist->{$entry}{'author'};
					my $loglistsubject = $gmEntrylist->{$entry}{'subject'};
					my $loglistdate = $gmEntrylist->{$entry}{'created'};
					my $loglisttimeampm = $gmEntrylist->{$entry}{'createt'};
					my $loglistopenstatus = $gmEntrylist->{$entry}{'status'};
					my $loglistmorestatus = $gmEntrylist->{$entry}{'extended'};
	
					if( ($loglistnumber > $entryVars->{'thisentrynumber'}) && 
						($foundregular eq Gm_Constants::NO) && ($loglistopenstatus ne 'C') ){
						$entryreturn =~ s/{{nextlink}}/$TEMPLATES->{'gmnextlinktemplate'}/isg;
						my $gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$entry}, 
							errHandler=>$errHandler );
						my $listsubsub = $entryreturn;
						$listsubsub =~ s/{{next/{{/isg;
						$listsubsub = translateArchiveTemplates( template=>$listsubsub,
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$entryreturn = $listsubsub;
						$foundregular = Gm_Constants::YES;
					}
					if( ($loglistmorestatus eq 'Y') && 
						($loglistnumber > $entryVars->{'thisentrynumber'}) && ($foundmore eq Gm_Constants::NO) && 
						($loglistopenstatus ne 'C') ){
						$entryreturn =~ s/{{morenextlink}}/$TEMPLATES->{'gmnextmorelinktemplate'}/isg;
						$entryreturn =~ s/{{nextmore/{{morenext/isg;
						my $gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$entry}, 
							errHandler=>$errHandler );
						my $listsubsub = $entryreturn;
						$listsubsub =~ s/{{morenext/{{/isg;
						$listsubsub = translateArchiveTemplates( template=>$listsubsub,
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$entryreturn = $listsubsub;
						$foundmore = Gm_Constants::YES;
					}
					
					if( ($foundregular eq Gm_Constants::YES) && ($foundmore eq Gm_Constants::YES) ){ 
						$foundboth = Gm_Constants::YES; 
						last;
					}
				}
		}
	
		$entryreturn =~ s/{{previouspagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
		$entryreturn =~ s/{{nextpagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
		$entryreturn =~ s/{{previousmorepagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
		$entryreturn =~ s/{{nextmorepagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
		$entryreturn =~ s/{{morepreviouspagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
		$entryreturn =~ s/{{morenextpagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
		$entryreturn =~ s/{{previouslink}}//isg;
		$entryreturn =~ s/{{nextlink}}//isg;

		my $thisentrynumber = $entryVars->{'thisentrynumber'};	
		if( ($entryreturn =~ m/{{previous/i) || ($entryreturn =~ m/{{next/i) ){
			if( exists( $gmEntrylist->{$thisentrynumber} ) ){
				my $loglistnumber = $gmEntrylist->{$thisentrynumber}{'id'};
				my $loglistauthor = $gmEntrylist->{$thisentrynumber}{'author'};
				my $loglistsubject = $gmEntrylist->{$thisentrynumber}{'subject'};
				my $loglistdate = $gmEntrylist->{$thisentrynumber}{'created'};
				my $loglisttimeampm = $gmEntrylist->{$thisentrynumber}{'createt'};
				my $loglistopenstatus = $gmEntrylist->{$thisentrynumber}{'status'};
				my $loglistmorestatus = $gmEntrylist->{$thisentrynumber}{'extended'};
	
				my $gmLogListVars = getArchiveVariables( listEntry=>$gmEntrylist->{$thisentrynumber}, 
					errHandler=>$errHandler );
				my $listsubsub = $entryreturn;
				$listsubsub =~ s/{{previous/{{/isg;
				$listsubsub =~ s/{{next/{{/isg;
				$listsubsub = translateArchiveTemplates( template=>$listsubsub,
					archiveVars=>$gmLogListVars, errHandler=>$errHandler );
				$entryreturn = $listsubsub;
			}
		}
	
		$entryreturn =~ s/{{morepagelink}}/$entryVars->{'thisentrypagesmartindexlink'}/isg;
	}

	# should we be using:  quotemeta
	if ($entryreturn =~ m/window.status='(.*?)';/i) { 
		 $entryreturn =~ s/\(/GMLEFTPARENTHESES/g; 
		 $entryreturn =~ s/\)/GMRIGHTPARENTHESES/g; 
		 $entryreturn =~ s/\?/GMQUESTIONMARK/g; 
		 $entryreturn =~ s/\+/GMPLUS/g; 
		 $entryreturn =~ s/\[/GMLEFTSQUAREBRACKET/g; 
		 $entryreturn =~ s/\]/GMRIGHTSQUAREBRACKET/g; 
		 $entryreturn =~ s/\$/GMDOLLAR/g; 
		 $entryreturn =~ s/\^/GMCARET/g; 
		 $entryreturn =~ s/\|/GMPIPE/g; 
		 $entryreturn =~ s/\*/GMSPLAT/g; 
		 until( $entryreturn !~ m/window.status='(.*?)';/ig ){ 
				my $windowstatusorigstring = $1; 
				my $windowstatusmiddlenew = $1; 
				$windowstatusmiddlenew =~ s#'#\\'#isg; 
				$windowstatusmiddlenew =~ s#"#\\'#isg; 
				$entryreturn =~ s/window.status='$windowstatusorigstring';/WSPLACEHOLDER='$windowstatusmiddlenew';/isg; 
		 } 
		 $entryreturn =~ s/WSPLACEHOLDER=/window.status=/isg; 
		 $entryreturn =~ s/GMLEFTPARENTHESES/\(/g; 
		 $entryreturn =~ s/GMRIGHTPARENTHESES/\)/g; 
		 $entryreturn =~ s/GMQUESTIONMARK/\?/g; 
		 $entryreturn =~ s/GMPLUS/\+/g; 
		 $entryreturn =~ s/GMLEFTSQUAREBRACKET/\[/g; 
		 $entryreturn =~ s/GMRIGHTSQUAREBRACKET/\]/g; 
		 $entryreturn =~ s/GMDOLLAR/\$/g; 
		 $entryreturn =~ s/GMCARET/\^/g; 
		 $entryreturn =~ s/GMPIPE/\|/g; 
		 $entryreturn =~ s/GMSPLAT/\*/g; 
	}

	if( $entryreturn =~ m/{{randomnumber (\d+)-(\d+)}}/i ){
		until( $entryreturn !~ m/{{randomnumber (\d+)-(\d+)}}/isg ){
			my $minrand = $1;
			my $maxrand = $2;
			my $maxtemprand = $maxrand - $minrand;
			$maxtemprand++;
			my $randresult = int(rand $maxtemprand) + $minrand;
			$entryreturn =~ s/{{randomnumber ($minrand)-($maxrand)}}/$randresult/i;
		}
	}

	if( ($entryreturn =~ m/{{cgiwebpath}}/i) || ($entryreturn =~ m/{{entrieswebpath}}/i) || 
		($entryreturn =~ m/{{logwebpath}}/i) || ($entryreturn =~ m/{{emoticonspath}}/i) ){
		$entryreturn =~ s/{{cgiwebpath}}/$CONFIGS->{'gmcgiwebpath'}/gi;
		$entryreturn =~ s/{{entrieswebpath}}/$CONFIGS->{'gmentrieswebpath'}/gi;
		$entryreturn =~ s/{{logwebpath}}/$CONFIGS->{'gmlogwebpath'}/gi;
		$entryreturn =~ s/{{emoticonspath}}/$CONFIGS->{'gmemoticonspath'}/gi;
	}

	if (($entryreturn =~ m/{{gmversion}}/i) || ($entryreturn =~ m/{{gmicon}}/i)) {
		my $gmversion = Gm_Constants::GM_VERSION;
		$entryreturn =~ s/{{gmversion}}/$gmversion/gi;
		## TODO: this should use the constant!!
		$entryreturn =~ s/{{gmicon}}/<a href="http:\/\/greymatterforum.proboards82.com\/" target="_top"><img border="0" src="$CONFIGS->{'gmlogwebpath'}\/gm-icon.gif" alt="Powered By Greymatter" \/><\/a>/gi;
	}

	# {{cookiescode}} template to facilitate setting cookies on commenters
	$entryreturn =~ s/{{cookiescode}}/$TEMPLATES->{'gmcookiescodetemplate'}/gi;
	$entryreturn =~ s/{{emoticonspath}}/$CONFIGS->{'gmemoticonspath'}/gi;
	$entryreturn =~ s/{{entrysuffix}}/$CONFIGS->{'gmentrysuffix'}/gi;
	$entryreturn =~ s/{{archivesuffix}}/$CONFIGS->{'gmlogarchivesuffix'}/gi;
	$entryreturn =~ s/{{domain}}/$domain/gi;
	$entryreturn =~ s/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w{1,8});)/&amp;/g;

	return( $entryreturn );
}


# ---------------------------------
# get log list variables
# ---------------------------------
## Goes through a specific entrylist and setups some variables

# 	loglistnumberpadded =>  the entry number, padded with leading zeros 
# 	loglistnumber => the entry number (or entry id)
# 	loglistauthor => the author of this entry, based on entry vars passed
# 	loglistsubject => the subject of this entry
# 	loglistdate => the 'created' date of the entry mm/dd/yy (does include leading zeros)
# 	loglisttimeampm => the time of day when created, with 'AM' or 'PM' postfixed
# 	loglistopenstatus => whether the entry is open
# 	loglistmorestatus => whether the entry is an extended entry
# 	loglistyear => the year when created, last two digits, will assume that if < 80, its now 2000
# 	loglistmonth => the numberic month when created, 1-12
# 	loglistday => the day when created 1-31
#   loglistyearyear => the year when created, with leading zero
# 	loglistmonthmonth => the month when created, with leading zero
# 	loglistdayday => the day when created, with leading zero
# 	loglisttime => the time of day when created
# 	loglistampm => 'AM' or 'PM' depending on when created
# 	loglisthourhour => the hour of day created, with leadin zero
# 	loglistminuteminute => the minute when created, with leading zero
# 	loglisthour => the hour of the day when created 1 - 12
# 	loglistminute => the  minute when created 0 - 60
# 	loglistmilitaryhour => the hour of the day, in military time 0 - 23
# 	loglistampmdot => 'A.M.' or 'P.M.'
# 	loglistampmlower => 'am' or 'pm'
# 	loglistampmdotlower => 'a.m.' or 'p.m.'
# 	loglistmonthword => the month when created, January - December
# 	loglistmonthwordshort => the short month name when created, Jan - Dec
# 	loglistmonthwordupper => uppercase month, JANUARY - DECEMBER
# 	loglistmonthwordlower => the lowercase month, january - december
# 	loglistmonthworduppershort => the short name in uppercase, JAN - DEC
# 	loglistmonthwordlowershort => the short name in lowercase, jan - dec
# 	loglistentrynumber => the entry id, same as loglistnumber
# 	loglistentryauthor => the entry author, same as loglistauthor
# 	loglistentrysubject => the entry subject, same as loglistsubject
# 	loglistentryweekdaynumber => the day the entry was made 1-7
# 	loglistentrymonth => the month the entry was made 1-12
# 	loglistentryday => the day of the month the entry was made 1-31
# 	loglistentryyearyear => the year the entry was created, with leading zeros
# 	loglistentryhour => the hour the entry was created
# 	loglistentryminute => the minute the entry was created
# 	loglistentrysecond => the second the entry was created
# 	loglistentryampm =>  'AM' or 'PM' depending on when created
# 	loglistentrypositivekarma => the positive karma total for the entry
# 	loglistentrynegativekarma => the negative karma total for the entry
# 	loglistentrycommentsnumber => the number of comments on this entry
# 	loglistentryallowkarma => whether karma voting is allowed
# 	loglistentryallowcomments => whether commenting is allowed
# 	loglistentryopenstatus => whether this entry is open or closed 'O' or 'C'
# 	loglistentrymusic => the music value for this entry
# 	loglistentrymood => the mood value for this entry
# 	loglistentryemoticonsallowed => whether emoticons are allowed to be entered 
# 	loglistentrytotalkarma => the total karma value for this entry
# 	loglistentrypositivekarmalink => the link to cast a positive vote for this entry
# 	loglistentrynegativekarmalink => the link to cast a negative vote for this entry
# 	loglistentryauthoremail => the entry author's email
# 	loglistentryauthorhomepage => the entry author's homepage
# 	loglistentryauthorentrycount => the number of entries for this author
# 	loglistentrycommentstatussmart => the 0, 1, or Many comment template, depending on number of comments
# 	loglistentrycommentstatussmartupper => uppercase version of thisentrycommentstatussmart
# 	loglistentrycommentstatussmartlower => lowercase version of thisentrycommentstatussmart
# 	loglistweekbeginningmonth => the numeric month at the begining of the week of this entry
# 	loglistweekbeginningyearyear => the last two digits of year at the begining of the week of this entry
# 	loglistweekendingmonth => the numeric month at the ending of the week of this entry
# 	loglistweekendingyearyear => the last two digits of the year at the ending of the week of this entry
# 	loglistweekbeginningday => the numeric day at the begining of the week of this entry
# 	loglistweekendingday => the numeric day at the end of the week of this entry
# 	loglistweekbeginningyear => the numeric year at the end of the week of this entry
# 	loglistweekendingyear => the numeric year at the end of the week of this entry
# 	loglistweekbeginningdayday => zero padded day of the begining of the week
# 	loglistweekendingdayday => zero padded day of the ending of the week
# 	loglistweekbeginningmonthmonth => zero padded month of the begining of the week of this entry
# 	loglistweekendingmonthmonth => zero padded month of the ending of the week of this entry
# 	loglistweekbeginningweekday => 'Sunday'
# 	loglistweekbeginningmonthword => The name of the month in the start of the week of the entry
# 	loglistweekbeginningweekdayshort => 'Sun'
# 	loglistweekbeginningmonthwordshort => The three letter name of the month in the start of the week of the entry
# 	loglistweekbeginningweekdayupper => 'SUNDAY'
# 	loglistweekbeginningmonthwordupper => uppercase version of 'thisentryweekbeginningmonthword'
# 	loglistweekbeginningweekdaylower => 'sunday'
# 	loglistweekbeginningmonthwordlower => lowercase version of 'thisentryweekbeginningmonthword'
# 	loglistweekbeginningweekdayuppershort => 'SUN'
# 	loglistweekbeginningmonthworduppershort => updercase version of 'thisentryweekbeginningmonthwordshort'
# 	loglistweekbeginningweekdaylowershort => 'sun'
# 	loglistweekbeginningmonthwordlowershort => lowercase version of 'thisentryweekbeginningmonthwordshort'
# 	loglistweekendingweekday => 'Saturday'
# 	loglistweekendingmonthword => the name of the month at the end of the week of the entry
# 	loglistweekendingweekdayshort => 'Sat'
# 	loglistweekendingmonthwordshort => the three letter name of the month at the end of the week of the entry
# 	loglistweekendingweekdayupper => 'SATURDAY'
# 	loglistweekendingmonthwordupper => the name of the month at end of week of entry uppercase
# 	loglistweekendingweekdaylower => 'saturday'
# 	loglistweekendingmonthwordlower => the name of the month at end of week of entry lowercase
# 	loglistweekendingweekdayuppershort => 'SAT'
# 	loglistweekendingmonthworduppershort => the three letter name of the month at end of week of entry uppercase
# 	loglistweekendingweekdaylowershort => 'sat'
# 	loglistweekendingmonthwordlowershort => the three letter name of the month at end of week of entry lowercase
# 	loglistpagelink => the link to this page
# 	loglistpagearchivelogindexlink => the archive log page for this entry
# 	loglistmainbody => the text of the main entry
# 	loglistmorebody=> the text of the more entry
## NOTE loglistentry vars are from the actualy entries, otherwise from entrylist

# ARG listEntry => a hash of entrylist line item data, see Gm_Storage
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a hash reference that contains the variables
# DEPRECATES: gm_getloglistvariables
sub getArchiveVariables {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $listEntry = $params{'listEntry'} || 
		&$errHandler('Invalid listEntry parameter passed to translateArchiveTemplates');


	## Setting up vars
	my %logVars = ();

	my $loglistnumberpadded = Gm_Utils::toEntryPadded( $listEntry->{'id'} );

	my ($loglistmonthmonth, $loglistdayday, $loglistyear) = split (/\//, $listEntry->{'created'});
	
## WHY DO THIS?  WE ARE GETTING THE NON-PADDED VERSION BELOW
	my $loglistmonth = $loglistmonthmonth;
	if( (substr($loglistmonthmonth, 0, 1)) eq '0' ){
		$loglistmonth = substr($loglistmonthmonth, -1, 1);
	}

## WHY DO THIS?  WE ARE GETTING THE NON-PADDED VERSION BELOW
	my $loglistday = $loglistdayday;
	if ((substr($loglistdayday, 0, 1)) eq '0') {
		$loglistday = substr($loglistdayday, -1, 1);
	}

	## THIS WILL CAUSE AN ISSUE IN 2081, BUT LETS FIX BY DOING 4 DIGIT YEAR ... TODO
## WHY DO THIS?  WE ARE GETTING THE FULL VERSION BELOW
	my $loglistyearyear = "20$loglistyear";
	if ($loglistyear > 80) {
		$loglistyearyear = "19$loglistyear";
	}

	my ($loglisttime, $loglistampm) = split (' ', $listEntry->{'createt'});
	my ($loglisthourhour, $loglistminuteminute) = split (':', $loglisttime);

## WHY DO THIS?  WE ARE GETTING THE NON-PADDED VERSION BELOW
	my $loglisthour = $loglisthourhour;
	if( (substr($loglisthourhour, 0, 1)) eq "0" ){
		$loglisthour = substr($loglisthourhour, -1, 1);
	}

## WHY DO THIS?  WE ARE GETTING THE NON-PADDED VERSION BELOW
	my $loglistminute = $loglistminuteminute;
	if ((substr($loglistminuteminute, 0, 1)) eq "0") {
		$loglistminute = substr($loglistminuteminute, -1, 1);
	}

	## TODO: MORE MILITARY TIME STUFF, REFACTOR
	my $loglistmilitaryhour = $loglisthour;

	my $loglistampmdot = 'P.M.';
	my $loglistampmlower = 'pm';
	my $loglistampmdotlower = 'p.m.';
	if ($loglistampm eq 'AM') {
		$loglistampmdot = 'A.M.';
		$loglistampmlower = 'am';
		$loglistampmdotlower = 'a.m.';
	} else {
		$loglistmilitaryhour = $loglistmilitaryhour + 12;	
	}

	$loglistmilitaryhour = Gm_Utils::toTwoDigit( $loglistmilitaryhour );

	my $loglistmonthword = (Gm_Constants::MONTHS)[$loglistmonth-1];
	my $loglistmonthwordshort = (Gm_Constants::MONTHS_SHORT)[$loglistmonth-1];
	my $loglistmonthwordupper = uc($loglistmonthword);
	my $loglistmonthwordlower = lc($loglistmonthword);
	my $loglistmonthworduppershort = uc($loglistmonthwordshort);
	my $loglistmonthwordlowershort = lc($loglistmonthwordshort);

	my $gmEntry = Gm_Storage::getEntry( id=>$listEntry->{'id'}, errHandler=>$errHandler );

	my $loglistentrynumber = $gmEntry->{'entryinfo'}{'id'}; 
	my $loglistentryauthor = $gmEntry->{'entryinfo'}{'author'};
	my $loglistentrysubject = $gmEntry->{'entryinfo'}{'subject'};
	my $loglistentryweekdaynumber = $gmEntry->{'entryinfo'}{'weekday'}; 
	my $loglistentrymonth = $gmEntry->{'entryinfo'}{'month'};
	my $loglistentryday = $gmEntry->{'entryinfo'}{'day'};
	my $loglistentryyearyear = $gmEntry->{'entryinfo'}{'year'};
	my $loglistentryhour = $gmEntry->{'entryinfo'}{'hour'};
	my $loglistentryminute = $gmEntry->{'entryinfo'}{'minute'};
	my $loglistentrysecond = $gmEntry->{'entryinfo'}{'second'};
	my $loglistentryampm = $gmEntry->{'entryinfo'}{'ampm'};
	my $loglistentrypositivekarma = $gmEntry->{'entryinfo'}{'karmapos'}; 
	my $loglistentrynegativekarma = $gmEntry->{'entryinfo'}{'karmaneg'};
	my $loglistentrycommentsnumber = $gmEntry->{'entryinfo'}{'commenttotal'}; 
	my $loglistentryallowkarma = $gmEntry->{'entryinfo'}{'karma'};
	my $loglistentryallowcomments = $gmEntry->{'entryinfo'}{'comments'}; 
	my $loglistentryopenstatus = $gmEntry->{'entryinfo'}{'status'};
	my $loglistentrymusic = $gmEntry->{'entryinfo'}{'music'};
	my $loglistentrymood = $gmEntry->{'entryinfo'}{'mood'};
	my $loglistentryemoticonsallowed = $gmEntry->{'entryinfo'}{'emoticons'};
	

	my $loglistentrytotalkarma = $loglistentrypositivekarma - $loglistentrynegativekarma;

	my $loglistentrypositivekarmalink = $CONFIGS->{'gmcgiwebpath'}.
		"/gm-karma.cgi?vote=positive&entry=$loglistnumberpadded";
	my $loglistentrynegativekarmalink = $CONFIGS->{'gmcgiwebpath'}.
		"/gm-karma.cgi?vote=negative&entry=$loglistnumberpadded";

	my $gmauthors = Gm_Storage::getAuthors( errHandler=>$errHandler );
	my $selectedauthor;
	
	my $loglistentryauthoremail = Gm_Constants::EMPTY;
	my $loglistentryauthorhomepage = Gm_Constants::EMPTY;
	my $loglistentryauthorentrycount = Gm_Constants::EMPTY;

	if( exists( $gmauthors->{$loglistentryauthor} )){
		$selectedauthor = $gmauthors->{$loglistentryauthor};
		$loglistentryauthoremail = $selectedauthor->{'email'};
		$loglistentryauthorhomepage = $selectedauthor->{'homepage'};
		$loglistentryauthorentrycount = $selectedauthor->{'posttotal'};
	}

	my $loglistentrycommentstatussmart = $TEMPLATES->{'gmsmartlinkmanycommentstemplate'};

	if( $loglistentrycommentsnumber < 1 ){ 
		$loglistentrycommentstatussmart = $TEMPLATES->{'gmsmartlinknocommentstemplate'}
	}
	if( $loglistentrycommentsnumber == 1 ){ 
		$loglistentrycommentstatussmart = $TEMPLATES->{'gmsmartlinkonecommenttemplate'}
	}

	my $loglistentrycommentstatussmartupper = uc( $loglistentrycommentstatussmart );
	my $loglistentrycommentstatussmartlower = lc( $loglistentrycommentstatussmart );

	my $loglistmaxdaysinthismonth = Gm_Utils::getDays( $loglistmonth, $loglistyearyear  );
	my $loglistmaxdaysinpreviousmonth = '';
	if( $loglistmonth == 1 ){
		$loglistmaxdaysinpreviousmonth = Gm_Utils::getDays( 12, $loglistyearyear-1  );
	} else {
		$loglistmaxdaysinpreviousmonth = Gm_Utils::getDays( $loglistmonth-1, $loglistyearyear  );
	}

	my $loglistweekbeginningmonth = $loglistmonth;
	my $loglistweekbeginningyearyear = $loglistyearyear;
	my $loglistweekendingmonth = $loglistmonth;
	my $loglistweekendingyearyear = $loglistyearyear;

	my $loglistweekbeginningday = $loglistday - $loglistentryweekdaynumber;
	my $loglistweekendingday = $loglistweekbeginningday + 6;

	if ($loglistweekbeginningday < 1) {
		$loglistweekbeginningday = $loglistweekbeginningday + $loglistmaxdaysinpreviousmonth;
		if( $loglistweekbeginningday > $loglistday ){ 
			$loglistweekbeginningmonth--; 
		}
		if ($loglistweekbeginningmonth < 1) {
			$loglistweekbeginningmonth = 12;
			$loglistweekbeginningyearyear--;
		}
	}

	if ($loglistweekendingday > $loglistmaxdaysinthismonth) {
		$loglistweekendingday = $loglistweekendingday - $loglistmaxdaysinthismonth;
		if ($loglistweekendingday < $loglistday) { $loglistweekendingmonth++; }
		if ($loglistweekendingmonth > 12) {
			$loglistweekendingmonth = 1;
			$loglistweekendingyearyear++;
		}
	}

	my $loglistweekbeginningyear = substr($loglistweekbeginningyearyear, -2, 2);
	my $loglistweekendingyear = substr($loglistweekendingyearyear, -2, 2);

	my $loglistweekbeginningdayday = Gm_Utils::toTwoDigit( $loglistweekbeginningday);
	my $loglistweekendingdayday = Gm_Utils::toTwoDigit( $loglistweekendingday);
	my $loglistweekbeginningmonthmonth = Gm_Utils::toTwoDigit( $loglistweekbeginningmonth);
	my $loglistweekendingmonthmonth = Gm_Utils::toTwoDigit( $loglistweekendingmonth);

	## TODO: ALLOW USER TO DETERMINE WHICH DAY WEEK START ON, IF DO, NEED TO UPDATE HERE!
	my $loglistweekbeginningweekday = (Gm_Constants::DAYS)[0];
	my $loglistweekbeginningmonthword = (Gm_Constants::MONTHS)[$loglistweekbeginningmonth-1];
	my $loglistweekbeginningweekdayshort = (Gm_Constants::DAYS_SHORT)[0];
	my $loglistweekbeginningmonthwordshort = (Gm_Constants::MONTHS_SHORT)[$loglistweekbeginningmonth-1];

	## TODO: MAKE A GENERIC FUNCTION THAT RETURNS A HAS OF LC AND UC 
	my $loglistweekbeginningweekdayupper = uc($loglistweekbeginningweekday);
	my $loglistweekbeginningmonthwordupper = uc($loglistweekbeginningmonthword);
	my $loglistweekbeginningweekdaylower = lc($loglistweekbeginningweekday);
	my $loglistweekbeginningmonthwordlower = lc($loglistweekbeginningmonthword);
	my $loglistweekbeginningweekdayuppershort = uc($loglistweekbeginningweekdayshort);
	my $loglistweekbeginningmonthworduppershort = uc($loglistweekbeginningmonthwordshort);
	my $loglistweekbeginningweekdaylowershort = lc($loglistweekbeginningweekdayshort);
	my $loglistweekbeginningmonthwordlowershort = lc($loglistweekbeginningmonthwordshort);

## TODO: ALLOW USER TO DETERMINE WHICH DAY WEEK START ON, IF DO, NEED TO UPDATE HERE!
	my $loglistweekendingweekday = (Gm_Constants::DAYS)[6];
	my $loglistweekendingmonthword = (Gm_Constants::MONTHS)[$loglistweekendingmonth-1];
	my $loglistweekendingweekdayshort = (Gm_Constants::DAYS_SHORT)[6];
	my $loglistweekendingmonthwordshort = (Gm_Constants::MONTHS_SHORT)[$loglistweekendingmonth-1];

	## TODO: MAKE A GENERIC FUNCTION THAT RETURNS A HAS OF LC AND UC
	my $loglistweekendingweekdayupper = uc($loglistweekendingweekday);
	my $loglistweekendingmonthwordupper = uc($loglistweekendingmonthword);
	my $loglistweekendingweekdaylower = lc($loglistweekendingweekday);
	my $loglistweekendingmonthwordlower = lc($loglistweekendingmonthword);
	my $loglistweekendingweekdayuppershort = uc($loglistweekendingweekdayshort);
	my $loglistweekendingmonthworduppershort = uc($loglistweekendingmonthwordshort);
	my $loglistweekendingweekdaylowershort = lc($loglistweekendingweekdayshort);
	my $loglistweekendingmonthwordlowershort = lc($loglistweekendingmonthwordshort);

# $loglistpagelink = "$EntriesWebPath\/$loglistnumberpadded\.$entrysuffix";
	my $loglistpagelink = $CONFIGS->{'gmentrieswebpath'}.'/'.
		$loglistnumberpadded.'.'.$CONFIGS->{'gmentrysuffix'};

	## TODO: THIS IS FOCUSING HEAVILY ON THE ASSUMPTION THAT THE FILES ARE GOING TO BE
  # PREGENERATED, WHICH IS FINE, BUT IF THIS IS REFACTORED TO BE DYNAMIC, NOTE THIS AREA! 
  my $loglistpagearchivelogindexlink = '';

	if( $CONFIGS->{'gmkeepmonthlyarchives'} eq Gm_Constants::NO ){
		$loglistpagearchivelogindexlink = '{{pageindexlink}}';
	} else {
		if( $CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK ){
			$loglistpagearchivelogindexlink = $CONFIGS->{'gmentrieswebpath'}.
				"/archive-$loglistweekbeginningmonthmonth$loglistweekbeginningdayday".
				"$loglistweekbeginningyearyear-$loglistweekendingmonthmonth".
				"$loglistweekendingdayday$loglistweekendingyearyear\.".
				$CONFIGS->{'gmlogarchivesuffix'};
		} else {
			$loglistpagearchivelogindexlink = $CONFIGS->{'gmentrieswebpath'}.
      	"/archive-$loglistmonthmonth$loglistyearyear\.".$CONFIGS->{'gmlogarchivesuffix'};
		}
	}

	my $loglistmainbody = $gmEntry->{'maintext'};
	my $loglistmorebody = $gmEntry->{'extendedtext'};
	my $loglistsubject = $gmEntry->{'subject'};

###############################################################################
	## TODO: MAKE THIS GENERIC UTIL ??
	if( ($loglistmainbody =~ /\|\*\|/) || ($loglistmorebody =~ /\|\*\|/) ){
		$loglistmainbody =~ s/\|\*\|/<BR>/g;
		$loglistmorebody =~ s/\|\*\|/<BR>/g;
	}
	## TODO: MAKE THIS GENERIC UTIL  ??
	if( ($loglistmainbody =~ /\n/) || ($loglistmorebody =~ /\n/) ){
		$loglistmainbody =~ s/\n/<BR>/g;
		$loglistmorebody =~ s/\n/<BR>/g;
	}
	if( ($loglistmainbody =~ /<BR><BR>/) || ($loglistmorebody =~ /<BR><BR>/) ){
		$loglistmainbody =~ s/<BR><BR>/$TEMPLATES->{'gmparaseparationtemplate'}/g;
		$loglistmorebody =~ s/<BR><BR>/$TEMPLATES->{'gmparaseparationtemplate'}/g;
	}

	if( ($CONFIGS->{'gmcensorenabled'} eq Gm_Constants::BOTH) || 
		($CONFIGS->{'gmcensorenabled'} eq Gm_Constants::ENTRIES) ){
		unless( $CONFIGS->{'gmcensorlist'} eq Gm_Constants::EMPTY ){
			my @censoredterms = split(/\n/, $CONFIGS->{'gmcensorlist'} );
			foreach my $thisterm (@censoredterms) {
				unless ($thisterm eq Gm_Constants::EMPTY) {
					if ((substr($thisterm, 0, 1) eq '[') && (substr($thisterm, -1, 1) eq ']')) {
						my $thisrealterm = $thisterm;
						$thisrealterm =~ s/\[//g;
						$thisrealterm =~ s/\]//g;
						my $thisrealtermlength = length($thisrealterm);
						my $thisrealtermreplace = '*' x $thisrealtermlength;
						my $thisrealtermreplacedash = '-' x $thisrealtermlength;
						if ($loglistsubject =~ m/$thisrealterm/i) {
							$loglistsubject =~ s/\b$thisrealterm\b/$thisrealtermreplacedash/isg;
						}
						if ($loglistmainbody =~ m/$thisrealterm/i) {
							$loglistmainbody =~ s/\b$thisrealterm\b/$thisrealtermreplace/isg;
						}
						if ($loglistmorebody =~ m/$thisrealterm/i) {
							$loglistmorebody =~ s/\b$thisrealterm\b/$thisrealtermreplace/isg;
						}
						if ($loglistentryauthor =~ m/$thisrealterm/i) {
							$loglistentryauthor =~ s/\b$thisrealterm\b/$thisrealtermreplacedash/isg;
						}
					} else {
						my $thisrealtermlength = length($thisterm);
						my $thisrealtermreplace = "*" x $thisrealtermlength;
						my $thisrealtermreplacedash = "-" x $thisrealtermlength;
						if ($loglistsubject =~ m/$thisterm/i) {
							$loglistsubject =~ s/\b$thisterm\b/$thisrealtermreplacedash/isg;
						}
						if ($loglistmainbody =~ m/$thisterm/i) {
							$loglistmainbody =~ s/\b$thisterm\b/$thisrealtermreplace/isg;
						}
						if ($loglistmorebody =~ m/$thisterm/i) {
							$loglistmorebody =~ s/\b$thisterm\b/$thisrealtermreplace/isg;
						}
						if ($loglistentryauthor =~ m/$thisterm/i) {
							$loglistentryauthor =~ s/\b$thisterm\b/$thisrealtermreplacedash/isg;
						}
					}
				}
			}
		}
	}


	# changed deprecated <b>, <i>, and <u> to corresponding css properties
	if( ($CONFIGS->{'gminlineformatting'} eq Gm_Constants::ENTRIES) || 
		($CONFIGS->{'gminlineformatting'} eq Gm_Constants::BOTH) ){
		$loglistmainbody = _inlineFormating( $loglistmainbody );
		$loglistmorebody = _inlineFormating( $loglistmorebody );
	}

	## returning for archive log list to work off of, TODO: REFACTOR CODE ABOVE TO USE THESE DIRECTLY
	$logVars{'loglistnumberpadded'} = $loglistnumberpadded;
	$logVars{'loglistmonthmonth'} = $loglistmonthmonth;
	$logVars{'loglistdayday'} = $loglistdayday;
	$logVars{'loglistyear'} = $loglistyear;
	$logVars{'loglistyearyear'} = $loglistyearyear;
	$logVars{'loglistmonth'} = $loglistmonth;
	$logVars{'loglistday'} = $loglistday;

	$logVars{'loglisttime'} = $loglisttime, 
	$logVars{'loglistampm'} = $loglistampm;
	$logVars{'loglisthourhour'} = $loglisthourhour;
	$logVars{'loglistminuteminute'} = $loglistminuteminute;
	$logVars{'loglisthour'} = $loglisthour;
	$logVars{'loglistminute'} = $loglistminute;
	
	$logVars{'loglistmilitaryhour'} = $loglistmilitaryhour;
	$logVars{'loglistampmdot'} = $loglistampmdot;
	$logVars{'loglistampmlower'} = $loglistampmlower;
	$logVars{'loglistampmdotlower'} = $loglistampmdotlower;
	
	$logVars{'loglistmonthword'} = $loglistmonthword;
	$logVars{'loglistmonthwordshort'} = $loglistmonthwordshort;
	$logVars{'loglistmonthwordupper'} = $loglistmonthwordupper;
	$logVars{'loglistmonthwordlower'} = $loglistmonthwordlower;
	$logVars{'loglistmonthworduppershort'} = $loglistmonthworduppershort;
	$logVars{'loglistmonthwordlowershort'} = $loglistmonthwordlowershort;
	
	$logVars{'loglistentrynumber'} = $loglistentrynumber;
	$logVars{'loglistentryauthor'} = $loglistentryauthor;
	$logVars{'loglistentrysubject'} = $loglistentrysubject;
	$logVars{'loglistentryweekdaynumber'} = $loglistentryweekdaynumber;
	$logVars{'loglistentrymonth'} = $loglistentrymonth;
	$logVars{'loglistentryday'} = $loglistentryday;
	$logVars{'loglistentryyearyear'} = $loglistentryyearyear;
	$logVars{'loglistentryhour'} = $loglistentryhour;
	$logVars{'loglistentryminute'} = $loglistentryminute;
	$logVars{'loglistentrysecond'} = $loglistentrysecond;
	$logVars{'loglistentryampm'} = $loglistentryampm;
	$logVars{'loglistentrypositivekarma'} = $loglistentrypositivekarma;
	$logVars{'loglistentrynegativekarma'} = $loglistentrynegativekarma;
	$logVars{'loglistentrycommentsnumber'} = $loglistentrycommentsnumber;
	$logVars{'loglistentryallowkarma'} = $loglistentryallowkarma;
	$logVars{'loglistentryallowcomments'} = $loglistentryallowcomments;
	$logVars{'loglistentryopenstatus'} = $loglistentryopenstatus;
	$logVars{'loglistentrymusic'} = $loglistentrymusic;
	$logVars{'loglistentrymood'} = $loglistentrymood;
	$logVars{'loglistentryemoticonsallowed'} = $loglistentryemoticonsallowed;
	
	$logVars{'loglistentrytotalkarma'} = $loglistentrytotalkarma;	
	$logVars{'loglistentrypositivekarmalink'} = $loglistentrypositivekarmalink;
	$logVars{'loglistentrynegativekarmalink'} = $loglistentrynegativekarmalink;

	$logVars{'loglistentryauthoremail'} = $loglistentryauthoremail;
	$logVars{'loglistentryauthorhomepage'} = $loglistentryauthorhomepage;
	$logVars{'loglistentryauthorentrycount'} = $loglistentryauthorentrycount;
	
	$logVars{'loglistentrycommentstatussmart'} = $loglistentrycommentstatussmart;
	$logVars{'loglistentrycommentstatussmartupper'} = $loglistentrycommentstatussmartupper;
	$logVars{'loglistentrycommentstatussmartlower'} = $loglistentrycommentstatussmartlower;
	
	$logVars{'loglistweekbeginningmonth'} = $loglistweekbeginningmonth;
	$logVars{'loglistweekbeginningyearyear'} = $loglistweekbeginningyearyear;
	$logVars{'loglistweekendingmonth'} = $loglistweekendingmonth;
	$logVars{'loglistweekendingyearyear'} = $loglistweekendingyearyear;
	$logVars{'loglistweekbeginningday'} = $loglistweekbeginningday;
	$logVars{'loglistweekendingday'} = $loglistweekendingday;
	
	$logVars{'loglistweekbeginningyear'} = $loglistweekbeginningyear;
	$logVars{'loglistweekendingyear'} = $loglistweekendingyear;
	$logVars{'loglistweekbeginningdayday'} = $loglistweekbeginningdayday;
	$logVars{'loglistweekendingdayday'} = $loglistweekendingdayday;
	$logVars{'loglistweekbeginningmonthmonth'} = $loglistweekbeginningmonthmonth;
	$logVars{'loglistweekendingmonthmonth'} = $loglistweekendingmonthmonth;
	$logVars{'loglistweekbeginningweekday'} = $loglistweekbeginningweekday;
	$logVars{'loglistweekbeginningmonthword'} = $loglistweekbeginningmonthword;
	$logVars{'loglistweekbeginningweekdayshort'} = $loglistweekbeginningweekdayshort;
	$logVars{'loglistweekbeginningmonthwordshort'} = $loglistweekbeginningmonthwordshort;
	$logVars{'loglistweekbeginningweekdayupper'} = $loglistweekbeginningweekdayupper;
	$logVars{'loglistweekbeginningmonthwordupper'} = $loglistweekbeginningmonthwordupper;
	$logVars{'loglistweekbeginningweekdaylower'} = $loglistweekbeginningweekdaylower;
	$logVars{'loglistweekbeginningmonthwordlower'} = $loglistweekbeginningmonthwordlower;
	$logVars{'loglistweekbeginningweekdayuppershort'} = $loglistweekbeginningweekdayuppershort;
	$logVars{'loglistweekbeginningmonthworduppershort'} = $loglistweekbeginningmonthworduppershort;
	$logVars{'loglistweekbeginningweekdaylowershort'} = $loglistweekbeginningweekdaylowershort;
	$logVars{'loglistweekbeginningmonthwordlowershort'} = $loglistweekbeginningmonthwordlowershort;
	$logVars{'loglistweekendingweekday'} = $loglistweekendingweekday;
	$logVars{'loglistweekendingmonthword'} = $loglistweekendingmonthword;
	$logVars{'loglistweekendingweekdayshort'} = $loglistweekendingweekdayshort;
	$logVars{'loglistweekendingmonthwordshort'} = $loglistweekendingmonthwordshort;
	$logVars{'loglistweekendingweekdayupper'} = $loglistweekendingweekdayupper;
	$logVars{'loglistweekendingmonthwordupper'} = $loglistweekendingmonthwordupper;
	$logVars{'loglistweekendingweekdaylower'} = $loglistweekendingweekdaylower;
	$logVars{'loglistweekendingmonthwordlower'} = $loglistweekendingmonthwordlower;
	$logVars{'loglistweekendingweekdayuppershort'} = $loglistweekendingweekdayuppershort;
	$logVars{'loglistweekendingmonthworduppershort'} = $loglistweekendingmonthworduppershort;
	$logVars{'loglistweekendingweekdaylowershort'} = $loglistweekendingweekdaylowershort;
	$logVars{'loglistweekendingmonthwordlowershort'} = $loglistweekendingmonthwordlowershort;
	
	$logVars{'loglistpagelink'} = $loglistpagelink;
	$logVars{'loglistpagearchivelogindexlink'} = $loglistpagearchivelogindexlink;
	$logVars{'loglistmainbody'} = $loglistmainbody;
	$logVars{'loglistmorebody'} = $loglistmorebody;
	
	$logVars{'loglistnumber'} = $listEntry->{'id'};
	$logVars{'loglistauthor'} = $listEntry->{'author'};
	$logVars{'loglistsubject'} = $listEntry->{'subject'};
	$logVars{'loglistdate'} = $listEntry->{'created'};
	$logVars{'loglisttimeampm'} = $listEntry->{'createt'};
	$logVars{'loglistopenstatus'} = $listEntry->{'status'};
	$logVars{'loglistmorestatus'} = $listEntry->{'extended'};
	
	return( \%logVars );
}



# ---------------------------------
# get entry variables
# ---------------------------------
## Sets up many variables based on the given entry that can be used for
# token substitution:

# 	thisentrynumber => the entry number, without leading zeros
# 	thisentrynumberpadded => the entry number, with leading zeros (8 digits total)
# 	thisentryauthor => the author of the entry
# 	thisentrysubject => subject of entry
# 	thisentryweekdaynumber => a number between 0 and 6 (Sun - Sat)
# 	thisentrymonth => month number, no leading zeros
# 	thisentryday => day number, no leading zeros
# 	thisentryyearyear	=> year, four digits
# 	thisentryhour	=> hour of entry, no leading zero
# 	thisentryminute	=> minutes of entry, no leading zero
# 	thisentrysecond	=> seconds of entry, no leading zero
# 	thisentryampm	=> whether its AM or PM, all caps, no periods
# 	thisentrypositivekarma => number of positive karma
# 	thisentrynegativekarma => number of negative karma
# 	thisentrycommentsnumber	=> number of comments
# 	thisentryallowkarma	=> whether this entry allows karma voting
# 	thisentryallowcomments => whether this entry allows comments
# 	thisentryopenstatus	=> whether this entry is open
# 	thisentrymusic => the music of the entry
# 	thisentrymood	=> the mood of the entry
# 	thisentryemoticonsallowed => whether emoticons are allowed
# 	thisentryyear => the two digit year
# 	thisentryweekday => the name of the week day Sunday - Saturday
# 	thisentryweekdayshort => the name of the week day short Sun - Sat
# 	thisentrymonthword => the name of the month January - December
# 	thisentrymonthwordshort => the name of the month short Jan - Dec
# 	thisentryweekdayupper => the name of the week day, uppercase
# 	thisentrymonthwordupper => the name of the month, uppercase
# 	thisentryweekdaylower => the name of the week day, lowercase
# 	thisentrymonthwordlower => the name of the month, lowercase
# 	thisentryweekdayuppershort => the short name of the day of the week, uppercase
# 	thisentrymonthworduppershort => the short name of the month, uppercase
# 	thisentryweekdaylowershort => the short name of the day of the week, lowercase
# 	thisentrymonthwordlowershort => the short name of the month, lowercase
# 	thisentrymonthmonth => the numeric month, with leading zero
# 	thisentrydayday => the numeric day, with leading zero
# 	thisentryhourhour => the hour, with leading zero
# 	thisentryminuteminute => the minute, with leading zero
# 	thisentrysecondsecond => the second, with leading zero
# 	thisentryampmdot => whether this entry was entered in A.M. or P.M.
# 	thisentrymilitaryhour =>  the military hour of the entry, 0 - 23
# 	thisentryampmlower => the am/pm lowercase, without dots
# 	thisentryampmdotlower =>  the a.m./p.m. lowercase, with dots
# 	thisentryweekbeginningmonth => the numeric month at the begining of the week of this entry
# 	thisentryweekbeginningyearyear => the last two digits of year at the begining of the week of this entry
# 	thisentryweekendingmonth => the numeric month at the ending of the week of this entry 
# 	thisentryweekendingyearyear => the last two digits of the year at the ending of the week of this entry
# 	thisentryweekbeginningday => the numeric day at the begining of the week of this entry
# 	thisentryweekendingday => the numeric day at the end of the week of this entry
# 	thisentryweekbeginningyear => the numeric year at the begining of the week of this entry
# 	thisentryweekendingyear => the numeric year at the end of the week of this entry
# 	thisentryweekbeginningdayday => zero padded day of the begining of the week
# 	thisentryweekendingdayday => zero padded day of the ending of the week
# 	thisentryweekbeginningmonthmonth => zero padded month of the begining of the week of this entry
# 	thisentryweekendingmonthmonth => zero padded month of the ending of the week of this entry
# 	thisentryweekbeginningweekday => 'Sunday'
# 	thisentryweekbeginningmonthword => The name of the month in the start of the week of the entry
# 	thisentryweekbeginningweekdayshort => 'Sun'
# 	thisentryweekbeginningmonthwordshort => The three letter name of the month in the start of the week of the entry
# 	thisentryweekbeginningweekdayupper => 'SUNDAY'
# 	thisentryweekbeginningmonthwordupper => uppercase version of 'thisentryweekbeginningmonthword'
# 	thisentryweekbeginningweekdaylower => 'sunday'
# 	thisentryweekbeginningmonthwordlower => lowercase version of 'thisentryweekbeginningmonthword'
# 	thisentryweekbeginningweekdayuppershort => 'SUN'
# 	thisentryweekbeginningmonthworduppershort => updercase version of 'thisentryweekbeginningmonthwordshort'
# 	thisentryweekbeginningweekdaylowershort => 'sun'
# 	thisentryweekbeginningmonthwordlowershort => lowercase version of 'thisentryweekbeginningmonthwordshort'
# 	thisentryweekendingweekday => 'Saturday'
# 	thisentryweekendingmonthword => the name of the month at the end of the week of the entry
# 	thisentryweekendingweekdayshort => 'Sat'
# 	thisentryweekendingmonthwordshort => the three letter name of the month at the end of the week of the entry
# 	thisentryweekendingweekdayupper => 'SATURDAY'
# 	thisentryweekendingmonthwordupper => the name of the month at end of week of entry uppercase
# 	thisentryweekendingweekdaylower => 'saturday'
# 	thisentryweekendingmonthwordlower =>  the name of the month at end of week of entry lowercase
# 	thisentryweekendingweekdayuppershort => 'SAT'
# 	thisentryweekendingmonthworduppershort =>  the three letter name of the month at end of week of entry uppercase
# 	thisentryweekendingweekdaylowershort => 'sat'
# 	thisentryweekendingmonthwordlowershort =>  the three letter name of the month at end of week of entry lowercase
# 	thisentryauthoremail => the author's email 
# 	thisentryauthorhomepage => the author's homepage
# 	thisentryauthorentrycount => the author's post total
# 	thisentrycommentspostlink => the link to the comment for this entry
# 	thisentrycommentstatussmart => the 0, 1, or Many comment template, depending on number of comments
# 	thisentrycommentstatussmartupper => uppercase version of thisentrycommentstatussmart
# 	thisentrycommentstatussmartlower => lowercase version of thisentrycommentstatussmart
# 	thisentrypagelink => the link to this page
# 	thisentrypageindexlink => link to the main index page
# 	thisentrypagearchiveindexlink => link to the archive index page
# 	thisentrypagearchivelogindexlink => the archive log page for this entry
# 	thisentrypagesmartindexlink => if this page is now an archive page, points to thisentrypagearchivelogindexlink, else entry index
# 	thisentrycommentslink => A link to comment on the entry, the {{commentslink}} template
# 	thisentrycommentsform	=> the form to post comments, the {{entrycommentsform}} template
# 	thisentrykarmalink => a link to change karma, for an entry, {{karmalink}} template
# 	thisentrykarmaform => the form to change karma on an entry, {{karmaform}} template
# 	thisentrysearchform => the form to search entries, the {{searchform}} template
# 	thisentrypositivekarmalink => this is a link to change the entries karma to positive, the {{positivekarmalink}} template
# 	thisentrynegativekarmalink => this is a link to change the entries karma to negative, the {{negativekarmalink}} template
# 	thisentrytotalkarma => the total karma for this entry, Postive - Negative
# 	thisentrymainbody => the text of the main entry
# 	thisentrymorebody => the text of the more entry
# 	thisentryauthorsmartlink => the author'name, either an email addr or a web addr, the {{authorsmartlink}} template
# 	thisentrycommentdivider => the {{commentdivider}} template, put between each comment
# 	thisentrycomments => the {{entrycomments}} template, all the comments collated into one string
# 	thisentryisanarchive => whether this entry is an archive entry

# ARG entryid => the id of the entry to work on
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a hash reference that contains the variables
# DEPRECATES: gm_getentryvariables
sub getEntryVariables {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $thisentrygetmynumber = $params{'entryid'} || 
		&$errHandler('Invalid entryid parameter passed to getEntryVariables');
	my %entryVars = ();
	
	my $previewMain = $params{'previewMain'} || '';
	my $previewMore = $params{'previewMore'} || '';

	## Gotta have an entry otherwise, whats point?  Since no vars setup, lets stop here
	unless( $thisentrygetmynumber ){
		&$errHandler( 'An unrecoverable error occurred: Invalid id passed to getEntryVariables.' );
	}

	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );

	my $thisentrynumberpadded = Gm_Utils::toEntryPadded( $thisentrygetmynumber );

	my $gmEntry = Gm_Storage::getEntry( id=>$thisentrygetmynumber,
		errHandler=>$errHandler );
		
	if( $previewMain || $previewMore ){
		$gmEntry->{'maintext'} = $previewMain;
		$gmEntry->{'extendedtext'} = $previewMore;
	}

## TODO: refactor out usage of variables, make work directly off of entry
	my $thisentrynumber = $gmEntry->{'entryinfo'}{'id'};
	my $thisentryauthor = $gmEntry->{'entryinfo'}{'author'};
	my $thisentrysubject = $gmEntry->{'entryinfo'}{'subject'};
	my $thisentryweekdaynumber = $gmEntry->{'entryinfo'}{'weekday'};
	my $thisentrymonth = $gmEntry->{'entryinfo'}{'month'};
	my $thisentryday = $gmEntry->{'entryinfo'}{'day'};
	my $thisentryyearyear = $gmEntry->{'entryinfo'}{'year'};
	my $thisentryhour = $gmEntry->{'entryinfo'}{'hour'};
	my $thisentryminute = $gmEntry->{'entryinfo'}{'minute'};
	my $thisentrysecond = $gmEntry->{'entryinfo'}{'second'};
	my $thisentryampm = $gmEntry->{'entryinfo'}{'ampm'};
	my $thisentrypositivekarma = $gmEntry->{'entryinfo'}{'karmapos'};
	my $thisentrynegativekarma = $gmEntry->{'entryinfo'}{'karmaneg'};
	my $thisentrycommentsnumber = $gmEntry->{'entryinfo'}{'commenttotal'};
	my $thisentryallowkarma = $gmEntry->{'entryinfo'}{'karma'};
	my $thisentryallowcomments = $gmEntry->{'entryinfo'}{'comments'};
	my $thisentryopenstatus = $gmEntry->{'entryinfo'}{'status'};
	my $thisentrymusic = $gmEntry->{'entryinfo'}{'music'};
	my $thisentrymood = $gmEntry->{'entryinfo'}{'mood'};
	my $thisentryemoticonsallowed = $gmEntry->{'entryinfo'}{'emoticons'};

	my $thisentryisanarchive = Gm_Constants::NO; 
	## checking the counter to see if this is an archived entry
	if( $thisentrynumber <= $gmCounters->{'archivetotal'} ){ 
		$thisentryisanarchive = Gm_Constants::YES; 
	}

	if( $CONFIGS->{'gmgenerateentrypages'} eq Gm_Constants::NO ){ 
		$thisentryallowcomments = Gm_Constants::NO; 
	}

## THIS IS SIMILAR TO GM_UTILS::GETSTDDATE, HOWEVER, ITS WORKING OFF OF A PREDETERMINED DATE
	my $thisentryyear = substr($thisentryyearyear, -2, 2);

	my $thisentryweekday = (Gm_Constants::DAYS)[$thisentryweekdaynumber];
	my $thisentryweekdayshort = (Gm_Constants::DAYS_SHORT)[$thisentryweekdaynumber];
	my $thisentrymonthword = (Gm_Constants::MONTHS)[$thisentrymonth-1];
	my $thisentrymonthwordshort = (Gm_Constants::MONTHS_SHORT)[$thisentrymonth-1];

	## This is for tag replacement, TODO: MAKE GENERIC SO RETURNS HAS WITH LC UC VALS?
	my $thisentryweekdayupper = uc($thisentryweekday);
	my $thisentrymonthwordupper = uc($thisentrymonthword);
	my $thisentryweekdaylower = lc($thisentryweekday);
	my $thisentrymonthwordlower = lc($thisentrymonthword);
	my $thisentryweekdayuppershort = uc($thisentryweekdayshort);
	my $thisentrymonthworduppershort = uc($thisentrymonthwordshort);
	my $thisentryweekdaylowershort = lc($thisentryweekdayshort);
	my $thisentrymonthwordlowershort = lc($thisentrymonthwordshort);

	## This is for tag replacement, TODO: MAKE GENERIC SO RETURNS HAS WITH LC UC VALS?
	my $thisentrymonthmonth = Gm_Utils::toTwoDigit( $thisentrymonth );
	my $thisentrydayday = Gm_Utils::toTwoDigit( $thisentryday );
	my $thisentryhourhour = Gm_Utils::toTwoDigit( $thisentryhour );
	my $thisentryminuteminute = Gm_Utils::toTwoDigit( $thisentryminute );
	my $thisentrysecondsecond = Gm_Utils::toTwoDigit( $thisentrysecond );

	my $thisentryampmdot = 'A.M.';
	my $thisentrymilitaryhour = $thisentryhour;
	if( $thisentryampm eq 'PM' ){
		$thisentryampmdot = 'P.M.';
		if( $thisentryhour ne '12' ){ 
			$thisentrymilitaryhour = $thisentryhour + 12; 
		}
	}

	$thisentrymilitaryhour = Gm_Utils::toTwoDigit( $thisentrymilitaryhour );
	my $thisentryampmlower = lc($thisentryampm);
	my $thisentryampmdotlower = lc($thisentryampmdot);

	# Military hour is 00 for 12 AM
	if (($thisentryhour eq '12') && ($thisentryampm eq 'AM')) {
		$thisentrymilitaryhour = '00';
	}

	my $thisentrymaxdaysinthismonth = Gm_Utils::getDays( $thisentrymonth, $thisentryyearyear  );
	my $thisentrymaxdaysinpreviousmonth = '';
	if( $thisentrymonth == 1 ){
		$thisentrymaxdaysinpreviousmonth = Gm_Utils::getDays( 12, $thisentryyearyear-1  );
	} else {
		$thisentrymaxdaysinpreviousmonth = Gm_Utils::getDays( $thisentrymonth-1, $thisentryyearyear  );
	}

	## TODO: REFACTOR THIS DATE MAGIC, CAN CREATE SEVERAL UTIL FUNCTIONS HERE 
	my $thisentryweekbeginningmonth = $thisentrymonth;
	my $thisentryweekbeginningyearyear = $thisentryyearyear;
	my $thisentryweekendingmonth = $thisentrymonth;
	my $thisentryweekendingyearyear = $thisentryyearyear;

	my $thisentryweekbeginningday = $thisentryday - $thisentryweekdaynumber;
	my $thisentryweekendingday = $thisentryweekbeginningday + 6;
	
	## Seems to be getting next year, if the curr month is Dec ?, make func, get next month, year?
	if ($thisentryweekbeginningday < 1) {
		$thisentryweekbeginningday = $thisentryweekbeginningday + $thisentrymaxdaysinpreviousmonth;
		if( $thisentryweekbeginningday > $thisentryday ){ 
			$thisentryweekbeginningmonth--; 
		}
		if( $thisentryweekbeginningmonth < 1 ){
			$thisentryweekbeginningmonth = 12;
			$thisentryweekbeginningyearyear--;
		}
	}
	## Seems to be getting next year, if the curr month is Dec ?, make func, get next month, year?
	if ($thisentryweekendingday > $thisentrymaxdaysinthismonth) {
		$thisentryweekendingday = $thisentryweekendingday - $thisentrymaxdaysinthismonth;
		if ($thisentryweekendingday < $thisentryday) { $thisentryweekendingmonth++; }
		if ($thisentryweekendingmonth > 12) {
			$thisentryweekendingmonth = 1;
			$thisentryweekendingyearyear++;
		}
	}

	my $thisentryweekbeginningyear = substr($thisentryweekbeginningyearyear, -2, 2);
	my $thisentryweekendingyear = substr($thisentryweekendingyearyear, -2, 2);

	my $thisentryweekbeginningdayday = Gm_Utils::toTwoDigit( $thisentryweekbeginningday);
	my $thisentryweekendingdayday = Gm_Utils::toTwoDigit( $thisentryweekendingday);
	my $thisentryweekbeginningmonthmonth = Gm_Utils::toTwoDigit( $thisentryweekbeginningmonth);
	my $thisentryweekendingmonthmonth = Gm_Utils::toTwoDigit( $thisentryweekendingmonth);

	## TODO: ALLOW USER TO DETERMINE WHICH DAY WEEK START ON, IF DO, NEED TO UPDATE HERE!
	my $thisentryweekbeginningweekday = (Gm_Constants::DAYS)[0];
	my $thisentryweekbeginningmonthword = (Gm_Constants::MONTHS)[$thisentryweekbeginningmonth-1];
	my $thisentryweekbeginningweekdayshort = (Gm_Constants::DAYS_SHORT)[0]; 
	my $thisentryweekbeginningmonthwordshort = (Gm_Constants::MONTHS_SHORT)[$thisentryweekbeginningmonth-1];
	
	## TODO: MAKE A GENERIC FUNCTION THAT RETURNS A HAS OF LC AND UC 
	my $thisentryweekbeginningweekdayupper = uc($thisentryweekbeginningweekday);
	my $thisentryweekbeginningmonthwordupper = uc($thisentryweekbeginningmonthword);
	my $thisentryweekbeginningweekdaylower = lc($thisentryweekbeginningweekday);
	my $thisentryweekbeginningmonthwordlower = lc($thisentryweekbeginningmonthword);
	my $thisentryweekbeginningweekdayuppershort = uc($thisentryweekbeginningweekdayshort);
	my $thisentryweekbeginningmonthworduppershort = uc($thisentryweekbeginningmonthwordshort);
	my $thisentryweekbeginningweekdaylowershort = lc($thisentryweekbeginningweekdayshort);
	my $thisentryweekbeginningmonthwordlowershort = lc($thisentryweekbeginningmonthwordshort);

	## TODO: ALLOW USER TO DETERMINE WHICH DAY WEEK START ON, IF DO, NEED TO UPDATE HERE!
	my $thisentryweekendingweekday = (Gm_Constants::DAYS)[6];
	my $thisentryweekendingmonthword = (Gm_Constants::MONTHS)[$thisentryweekendingmonth-1];
	my $thisentryweekendingweekdayshort = (Gm_Constants::DAYS_SHORT)[6];
	my $thisentryweekendingmonthwordshort = (Gm_Constants::MONTHS_SHORT)[$thisentryweekendingmonth-1];
	
	## TODO: MAKE A GENERIC FUNCTION THAT RETURNS A HAS OF LC AND UC 
	my $thisentryweekendingweekdayupper = uc($thisentryweekendingweekday);
	my $thisentryweekendingmonthwordupper = uc($thisentryweekendingmonthword);
	my $thisentryweekendingweekdaylower = lc($thisentryweekendingweekday);
	my $thisentryweekendingmonthwordlower = lc($thisentryweekendingmonthword);
	my $thisentryweekendingweekdayuppershort = uc($thisentryweekendingweekdayshort);
	my $thisentryweekendingmonthworduppershort = uc($thisentryweekendingmonthwordshort);
	my $thisentryweekendingweekdaylowershort = lc($thisentryweekendingweekdayshort);
	my $thisentryweekendingmonthwordlowershort = lc($thisentryweekendingmonthwordshort);

	my $gmauthors = Gm_Storage::getAuthors( errHandler=>$errHandler );
	my $selectedauthor;

	my $thisentryauthoremail = Gm_Constants::EMPTY;
	my $thisentryauthorhomepage = Gm_Constants::EMPTY;
	my $thisentryauthorentrycount = Gm_Constants::EMPTY;

	if( exists( $gmauthors->{$thisentryauthor} )){
		$selectedauthor = $gmauthors->{$thisentryauthor};
		$thisentryauthoremail = $selectedauthor->{'email'};
		$thisentryauthorhomepage = $selectedauthor->{'homepage'};
		$thisentryauthorentrycount = $selectedauthor->{'posttotal'};
	}

	my $thisentryfilename = $CONFIGS->{'gmentrieswebpath'}.'/'.
		$thisentrynumberpadded.'.'.$CONFIGS->{'gmentrysuffix'};

	my $thisentrycommentspostlink = "$thisentryfilename\#comments";

	## Init to many commentss
	my $thisentrycommentstatussmart = $TEMPLATES->{'gmsmartlinkmanycommentstemplate'};

# if ($thisentrycommentsnumber eq "0") { $thisentrycommentstatussmart = $gmsmartlinknocommentstemplate; }
# if ($thisentrycommentsnumber eq "1") { $thisentrycommentstatussmart = $gmsmartlinkonecommenttemplate; }
	if( $thisentrycommentsnumber < 1 ){ 
		$thisentrycommentstatussmart = $TEMPLATES->{'gmsmartlinknocommentstemplate'};
	} elsif( $thisentrycommentsnumber == 1 ){ 
		$thisentrycommentstatussmart = $TEMPLATES->{'gmsmartlinkonecommenttemplate'}; 
	}

## THESE ARE USED IN GM_FORMATENTRY !!!
	my $thisentrycommentstatussmartupper = uc($thisentrycommentstatussmart);
	my $thisentrycommentstatussmartlower = lc($thisentrycommentstatussmart);
	my $thisentrypagelink = $thisentryfilename;

	my $indexfilenamesmartcheck = '/'.$CONFIGS->{'gmindexfilename'};

	if( $CONFIGS->{'gmindexfilename'} =~ m/^index\./ ){
		## shortening url automatically
		$indexfilenamesmartcheck = '/';
	}

	my $thisentrypageindexlink = $CONFIGS->{'gmlogwebpath'}."$indexfilenamesmartcheck";
	my $thisentrypagearchiveindexlink = $CONFIGS->{'gmentrieswebpath'}."$indexfilenamesmartcheck";

	## TODO: THIS IS FOCUSING HEAVILY ON THE ASSUMPTION THAT THE FILES ARE GOING TO BE
	# PREGENERATED, WHICH IS FINE, BUT IF THIS IS REFACTORED TO BE DYNAMIC, NOTE THIS	AREA!
	my $thisentrypagearchivelogindexlink = '';
	if( $CONFIGS->{'gmkeepmonthlyarchives'} eq Gm_Constants::NO ){
		$thisentrypagearchivelogindexlink = $thisentrypageindexlink;
	} else {
		## NOTE this is where the ending/begining day/month/year vars are used, to create unique archive
		# filenames
		if ($CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK) {
			$thisentrypagearchivelogindexlink = $CONFIGS->{'gmentrieswebpath'}.
				"/archive-$thisentryweekbeginningmonthmonth$thisentryweekbeginningdayday".
				"$thisentryweekbeginningyearyear-$thisentryweekendingmonthmonth".
				"$thisentryweekendingdayday$thisentryweekendingyearyear\.".
				$CONFIGS->{'gmlogarchivesuffix'};

		} else {
			$thisentrypagearchivelogindexlink = $CONFIGS->{'gmentrieswebpath'}.
				"/archive-$thisentrymonthmonth$thisentryyearyear\.".$CONFIGS->{'gmlogarchivesuffix'};
		}
	}
	
	my $thisentrypagesmartindexlink = $thisentrypageindexlink;

	if( ($thisentrynumber <= $gmCounters->{'archivetotal'} ) && 
		($CONFIGS->{'gmkeepmonthlyarchives'} ne Gm_Constants::NO) ){
		$thisentrypagesmartindexlink = $thisentrypagearchivelogindexlink;
	}

#######
## THESE ARE USED IN GM_FORMATENTRY !!!	
	my $thisentrycommentslink = Gm_Constants::EMPTY;
	my $thisentrycommentsform = Gm_Constants::EMPTY;
	if( $thisentryallowcomments eq Gm_Constants::YES ){
		if( ($CONFIGS->{'gmallowkarmaorcomments'} eq Gm_Constants::COMMENTS) || 
			($CONFIGS->{'gmallowkarmaorcomments'} eq Gm_Constants::BOTH) ){
			$thisentrycommentslink = $TEMPLATES->{'gmcommentslinktemplate'};
			$thisentrycommentsform = $TEMPLATES->{'gmcommentsformtemplate'};
		}
	}

	if( (($CONFIGS->{'gmemoticonsallowed'} eq Gm_Constants::BOTH) || 
		($CONFIGS->{'gmemoticonsallowed'} eq Gm_Constants::COMMENTS)) &&
		$thisentryemoticonsallowed eq Gm_Constants::YES ){
			my $gmsmartemoticonscodetemplate = $TEMPLATES->{'gmsmartemoticonscodetemplate'};
			$thisentrycommentsform =~ s/{{smartemoticonscode}}/$gmsmartemoticonscodetemplate/;
	} else {
			$thisentrycommentsform =~ s/{{smartemoticonscode}}//;
	}  

	#######
	## THESE ARE USED IN GM_FORMATENTRY !!!	
	my $thisentrykarmalink = Gm_Constants::EMPTY;
	my $thisentrykarmaform = Gm_Constants::EMPTY;
	if( $thisentryallowkarma eq Gm_Constants::YES ){
		if( ($CONFIGS->{'gmallowkarmaorcomments'} eq Gm_Constants::KARMA) || 
			($CONFIGS->{'gmallowkarmaorcomments'} eq Gm_Constants::BOTH) ){
			$thisentrykarmalink = $TEMPLATES->{'gmkarmalinktemplate'};
			$thisentrykarmaform = $TEMPLATES->{'gmkarmaformtemplate'};
		}
	}

	if( ($thisentryisanarchive eq Gm_Constants::YES) && 
		($CONFIGS->{'gmposttoarchives'} eq Gm_Constants::NO) ){
		$thisentrykarmalink = Gm_Constants::EMPTY;
		$thisentrykarmaform = Gm_Constants::EMPTY;
		$thisentrycommentslink = Gm_Constants::EMPTY;
		$thisentrycommentsform = Gm_Constants::EMPTY;
	}

	my $thisentrysearchform = $TEMPLATES->{'gmsearchformtemplate'};

	if( $CONFIGS->{'gmgenerateentrypages'} eq Gm_Constants::NO ){
		$thisentrycommentslink = Gm_Constants::EMPTY;
		$thisentrycommentsform = Gm_Constants::EMPTY;
		$thisentrysearchform = Gm_Constants::EMPTY;
	}

#######
## THESE ARE USED IN GM_FORMATENTRY !!!
	## TODO: can we remove amp; and just have &
	my $thisentrypositivekarmalink = $CONFIGS->{'gmcgiwebpath'}.
		"/gm-karma.cgi?vote=positive&amp;entry=$thisentrynumberpadded";
	my $thisentrynegativekarmalink = $CONFIGS->{'gmcgiwebpath'}.
		"/gm-karma.cgi?vote=negative&amp;entry=$thisentrynumberpadded";

	my $thisentrytotalkarma = $thisentrypositivekarma - $thisentrynegativekarma;

	my $thisentrymainbody = $gmEntry->{'maintext'};
	my $thisentrymorebody = $gmEntry->{'extendedtext'};

	## TODO: refactor this out so it is done generically, can be reused righ there at least
	if (($thisentrymainbody =~ /\|\*\|\|\*\|/) || ($thisentrymorebody =~ /\|\*\|\|\*\|/)) {
		$thisentrymainbody =~ s/\|\*\|\|\*\|/<PARABREAK>/g;
		$thisentrymorebody =~ s/\|\*\|\|\*\|/<PARABREAK>/g;
	}
	if (($thisentrymainbody =~ /\n\n/) || ($thisentrymorebody =~ /\n\n/)) {
		$thisentrymainbody =~ s/\n\n/<PARABREAK>/g;
		$thisentrymorebody =~ s/\n\n/<PARABREAK>/g;
	}
	my $gmlinebreaktemplate = $TEMPLATES->{'gmlinebreaktemplate'};
	my $gmparaseparationtemplate = $TEMPLATES->{'gmparaseparationtemplate'};
	if (($thisentrymainbody =~ /\|\*\|/) || ($thisentrymorebody =~ /\|\*\|/)) {
		$thisentrymainbody =~ s/\|\*\|/$gmlinebreaktemplate/g;
		$thisentrymorebody =~ s/\|\*\|/$gmlinebreaktemplate/g;
	}
	if (($thisentrymainbody =~ /\n/) || ($thisentrymorebody =~ /\n/)) {
		$thisentrymainbody =~ s/\n/$gmlinebreaktemplate/g;
		$thisentrymorebody =~ s/\n/$gmlinebreaktemplate/g;
	}
	if (($thisentrymainbody =~ /<PARABREAK>/) || ($thisentrymorebody =~ /<PARABREAK>/)) {
		$thisentrymainbody =~ s/<PARABREAK>/$gmparaseparationtemplate/g;
		$thisentrymorebody =~ s/<PARABREAK>/$gmparaseparationtemplate/g;
	}

	## CENSORING  
	## TODO: CAN THIS BE GENERIZIED INTO A UTIL OR WEB FUNCTION
	if( ($CONFIGS->{'gmcensorenabled'} eq Gm_Constants::BOTH) || 
		($CONFIGS->{'gmcensorenabled'} eq Gm_Constants::ENTRIES) ){
	# 	unless ($censorlist eq Gm_Constants::EMPTY) {
	# 		@censoredterms = split(/\n/, $censorlist);
		unless ($CONFIGS->{'gmcensorlist'} eq Gm_Constants::EMPTY) {
			my @censoredterms = split(/\n/, $CONFIGS->{'gmcensorlist'});		
			foreach my $thisterm (@censoredterms) {
				unless ($thisterm eq Gm_Constants::EMPTY) {
					if ((substr($thisterm, 0, 1) eq '[') && (substr($thisterm, -1, 1) eq ']')) {
						my $thisrealterm = $thisterm;
						$thisrealterm =~ s/\[//g;
						$thisrealterm =~ s/\]//g;
						my $thisrealtermlength = length($thisrealterm);
						my $thisrealtermreplace = "*" x $thisrealtermlength;
						my $thisrealtermreplacedash = "-" x $thisrealtermlength;
						if ($thisentrysubject =~ m/$thisrealterm/i) {
							$thisentrysubject =~ s/\b$thisrealterm\b/$thisrealtermreplacedash/isg;
						}
						if ($thisentrymainbody =~ m/$thisrealterm/i) {
							$thisentrymainbody =~ s/\b$thisrealterm\b/$thisrealtermreplace/isg;
						}
						if ($thisentrymorebody =~ m/$thisrealterm/i) {
							$thisentrymorebody =~ s/\b$thisrealterm\b/$thisrealtermreplace/isg;
						}
						if ($thisentryauthor =~ m/$thisrealterm/i) {
							$thisentryauthor =~ s/\b$thisrealterm\b/$thisrealtermreplacedash/isg;
						}
					} else {
						my $thisrealtermlength = length($thisterm);
						my $thisrealtermreplace = "*" x $thisrealtermlength;
						my $thisrealtermreplacedash = "-" x $thisrealtermlength;
						if ($thisentrysubject =~ m/$thisterm/i) {
							$thisentrysubject =~ s/\b$thisterm\b/$thisrealtermreplacedash/isg;
						}
						if ($thisentrymainbody =~ m/$thisterm/i) {
							$thisentrymainbody =~ s/\b$thisterm\b/$thisrealtermreplace/isg;
						}
						if ($thisentrymorebody =~ m/$thisterm/i) {
							$thisentrymorebody =~ s/\b$thisterm\b/$thisrealtermreplace/isg;
						}
						if ($thisentryauthor =~ m/$thisterm/i) {
							$thisentryauthor =~ s/\b$thisterm\b/$thisrealtermreplacedash/isg;
						}
					}
				}
			}
		}
	}

	my $thisentryauthorsmartlink = $thisentryauthor;
## FIX FOR CENSORING?  JUST MOVE AFTER CENSORING PROBABLY
	## TODO: MAKE A GETSMARTAUTHORLINKS FOR HOMEPAGE AND EMAIL SINCE THIS IS DUPPED +3 TIMES
	if( $thisentryauthoremail ne Gm_Constants::EMPTY ){ 
		$thisentryauthorsmartlink = "<a href=\"mailto:$thisentryauthoremail\">$thisentryauthor</a>"; 
	}
	if( $thisentryauthorhomepage ne Gm_Constants::EMPTY ){ 
		my $gmlinktargettemplate = $TEMPLATES->{'gmlinktargettemplate'};
		$thisentryauthorsmartlink = "<a href=\"$thisentryauthorhomepage\" $gmlinktargettemplate>$thisentryauthor</a>"; 
	}

###  PER THE GM MANUAL, THESE ARE DEPRECATED, CLAIMS TO KEEP THEM, BUT THE TEMPLATE VARIABLES ARE GONE (NOT IN 1.3.1)!
# 	my $thisentrymorepreface = Gm_Constants::EMPTY;
# 	my $thisentrymorelink = Gm_Constants::EMPTY;
# 	if( ($thisentrymorebody ne Gm_Constants::EMPTY) && 
# 		($configs->{'gmgenerateentrypages'} ne Gm_Constants::NO) ){
# 		$thisentrymorepreface = $gmmoreprefacetemplate;
# 		$thisentrymorelink = $gmmorelinktemplate;
# 	}


	my $thisentrycommentdivider = Gm_Constants::EMPTY;
	if( $thisentrycommentsnumber > 0 ){	
		$thisentrycommentdivider = $TEMPLATES->{'gmcommentdividertemplate'}
	}

	# changed deprecated <b>, <i>, and <u> tags to corresponding css properties
	## TODO make generic since we are just doing simple substitutions, Web?  Util?
	if( ($CONFIGS->{'gminlineformatting'} eq Gm_Constants::ENTRIES) || 
		($CONFIGS->{'gminlineformatting'} eq Gm_Constants::BOTH) ){
		$thisentrymainbody = _inlineFormating( $thisentrymainbody );
		$thisentrymorebody = _inlineFormating( $thisentrymorebody );
	}

	if( (($CONFIGS->{'gmemoticonsallowed'} eq Gm_Constants::BOTH) 
		|| ($CONFIGS->{'gmemoticonsallowed'} eq Gm_Constants::COMMENTS)) 
		&& ($gmEntry->{'entryinfo'}{'emoticons'} eq Gm_Constants::YES) ) {
		$thisentrymainbody = translateEmoticons( $thisentrymainbody );
		$thisentrymorebody = translateEmoticons( $thisentrymorebody );
	}

	my $thisentrycomments = Gm_Constants::EMPTY;
	if( ($thisentrycommentsnumber > 0) && 
		($CONFIGS->{'gmgenerateentrypages'} ne Gm_Constants::NO) ){
		$thisentrycomments = collateComments( entry=>$gmEntry, errHandler=>$errHandler );
		$thisentrycomments =~ s/\&quot;/"/g; ## TODO: MAKE THIS GENERIC UNTIL? WEB?
	}


## TODO: COMMENT OUT COLLATE COMMENTS ONCE EVERYTHING USING THIS ...
## TODO: UPDATE WHAT THIS METHOD DOES !!!

	## returning for format entry to work off of
	$entryVars{'thisentrynumber'} = $thisentrynumber;
	$entryVars{'thisentrynumberpadded'} = $thisentrynumberpadded;
	$entryVars{'thisentryauthor'} = $thisentryauthor;
	$entryVars{'thisentrysubject'} = $thisentrysubject;	
	$entryVars{'thisentryweekdaynumber'} = $thisentryweekdaynumber;	
	$entryVars{'thisentrymonth'} = $thisentrymonth;	
	$entryVars{'thisentryday'} = $thisentryday;	
	$entryVars{'thisentryyearyear'} = $thisentryyearyear;	
	$entryVars{'thisentryhour'} = $thisentryhour;	
	$entryVars{'thisentryminute'} = $thisentryminute;	
	$entryVars{'thisentrysecond'} = $thisentrysecond;	
	$entryVars{'thisentryampm'} = $thisentryampm;	
	$entryVars{'thisentrypositivekarma'} = $thisentrypositivekarma;	
	$entryVars{'thisentrynegativekarma'} = $thisentrynegativekarma;	
	$entryVars{'thisentrycommentsnumber'} = $thisentrycommentsnumber;	
	$entryVars{'thisentryallowkarma'} = $thisentryallowkarma;	
	$entryVars{'thisentryallowcomments'} = $thisentryallowcomments;	
	$entryVars{'thisentryopenstatus'} = $thisentryopenstatus;	
	$entryVars{'thisentrymusic'} = $thisentrymusic;	
	$entryVars{'thisentrymood'} = $thisentrymood;	
	$entryVars{'thisentryemoticonsallowed'} = $thisentryemoticonsallowed;	

	$entryVars{'thisentryyear'} = $thisentryyear;
	$entryVars{'thisentryweekday'} = $thisentryweekday;
	$entryVars{'thisentryweekdayshort'} = $thisentryweekdayshort;
	$entryVars{'thisentrymonthword'} = $thisentrymonthword;
	$entryVars{'thisentrymonthwordshort'} = $thisentrymonthwordshort;
	$entryVars{'thisentryweekdayupper'} = $thisentryweekdayupper;
	$entryVars{'thisentrymonthwordupper'} = $thisentrymonthwordupper;
	$entryVars{'thisentryweekdaylower'} = $thisentryweekdaylower;
	$entryVars{'thisentrymonthwordlower'} = $thisentrymonthwordlower;
	$entryVars{'thisentryweekdayuppershort'} = $thisentryweekdayuppershort;
	$entryVars{'thisentrymonthworduppershort'} = $thisentrymonthworduppershort;
	$entryVars{'thisentryweekdaylowershort'} = $thisentryweekdaylowershort;
	$entryVars{'thisentrymonthwordlowershort'} = $thisentrymonthwordlowershort;

	$entryVars{'thisentrymonthmonth'} = $thisentrymonthmonth;
	$entryVars{'thisentrydayday'} = $thisentrydayday;
	$entryVars{'thisentryhourhour'} = $thisentryhourhour;
	$entryVars{'thisentryminuteminute'} = $thisentryminuteminute;
	$entryVars{'thisentrysecondsecond'} = $thisentrysecondsecond;
	$entryVars{'thisentryampmdot'} = $thisentryampmdot;
	$entryVars{'thisentrymilitaryhour'} = $thisentrymilitaryhour;
	$entryVars{'thisentryampmlower'} = $thisentryampmlower;
	$entryVars{'thisentryampmdotlower'} = $thisentryampmdotlower;

	$entryVars{'thisentryweekbeginningmonth'} = $thisentryweekbeginningmonth;
	$entryVars{'thisentryweekbeginningyearyear'} = $thisentryweekbeginningyearyear;
	$entryVars{'thisentryweekendingmonth'} = $thisentryweekendingmonth;
	$entryVars{'thisentryweekendingyearyear'} = $thisentryweekendingyearyear;
	$entryVars{'thisentryweekbeginningday'} = $thisentryweekbeginningday;
	$entryVars{'thisentryweekendingday'} = $thisentryweekendingday;

	$entryVars{'thisentryweekbeginningyear'} = $thisentryweekbeginningyear;
	$entryVars{'thisentryweekendingyear'} = $thisentryweekendingyear;

	$entryVars{'thisentryweekbeginningdayday'} = $thisentryweekbeginningdayday;
	$entryVars{'thisentryweekendingdayday'} = $thisentryweekendingdayday;
	$entryVars{'thisentryweekbeginningmonthmonth'} = $thisentryweekbeginningmonthmonth;
	$entryVars{'thisentryweekendingmonthmonth'} = $thisentryweekendingmonthmonth;
	
	$entryVars{'thisentryweekbeginningweekday'} = $thisentryweekbeginningweekday;
	$entryVars{'thisentryweekbeginningmonthword'} = $thisentryweekbeginningmonthword;
	$entryVars{'thisentryweekbeginningweekdayshort'} = $thisentryweekbeginningweekdayshort;
	$entryVars{'thisentryweekbeginningmonthwordshort'} = $thisentryweekbeginningmonthwordshort;
	$entryVars{'thisentryweekbeginningweekdayupper'} = $thisentryweekbeginningweekdayupper;
	$entryVars{'thisentryweekbeginningmonthwordupper'} = $thisentryweekbeginningmonthwordupper;
	$entryVars{'thisentryweekbeginningweekdaylower'} = $thisentryweekbeginningweekdaylower;
	$entryVars{'thisentryweekbeginningmonthwordlower'} = $thisentryweekbeginningmonthwordlower;
	$entryVars{'thisentryweekbeginningweekdayuppershort'} = $thisentryweekbeginningweekdayuppershort;
	$entryVars{'thisentryweekbeginningmonthworduppershort'} = $thisentryweekbeginningmonthworduppershort;
	$entryVars{'thisentryweekbeginningweekdaylowershort'} = $thisentryweekbeginningweekdaylowershort;
	$entryVars{'thisentryweekbeginningmonthwordlowershort'} = $thisentryweekbeginningmonthwordlowershort;
	
	$entryVars{'thisentryweekendingweekday'} = $thisentryweekendingweekday;
	$entryVars{'thisentryweekendingmonthword'} = $thisentryweekendingmonthword;
	$entryVars{'thisentryweekendingweekdayshort'} = $thisentryweekendingweekdayshort;
	$entryVars{'thisentryweekendingmonthwordshort'} = $thisentryweekendingmonthwordshort;
	
	$entryVars{'thisentryweekendingweekdayupper'} = $thisentryweekendingweekdayupper;
	$entryVars{'thisentryweekendingmonthwordupper'} = $thisentryweekendingmonthwordupper;
	$entryVars{'thisentryweekendingweekdaylower'} = $thisentryweekendingweekdaylower;
	$entryVars{'thisentryweekendingmonthwordlower'} = $thisentryweekendingmonthwordlower;
	$entryVars{'thisentryweekendingweekdayuppershort'} = $thisentryweekendingweekdayuppershort;
	$entryVars{'thisentryweekendingmonthworduppershort'} = $thisentryweekendingmonthworduppershort;
	$entryVars{'thisentryweekendingweekdaylowershort'} = $thisentryweekendingweekdaylowershort;
	$entryVars{'thisentryweekendingmonthwordlowershort'} = $thisentryweekendingmonthwordlowershort;

	$entryVars{'thisentryauthoremail'} = $thisentryauthoremail;
	$entryVars{'thisentryauthorhomepage'} = $thisentryauthorhomepage;
	$entryVars{'thisentryauthorentrycount'} = $thisentryauthorentrycount;
	
	$entryVars{'thisentrycommentspostlink'} = $thisentrycommentspostlink;
	$entryVars{'thisentrycommentstatussmart'} = $thisentrycommentstatussmart;
	$entryVars{'thisentrycommentstatussmartupper'} = $thisentrycommentstatussmartupper;
	$entryVars{'thisentrycommentstatussmartlower'} = $thisentrycommentstatussmartlower;
	$entryVars{'thisentrypagelink'} = $thisentrypagelink;

	$entryVars{'thisentrypageindexlink'} = $thisentrypageindexlink;
	$entryVars{'thisentrypagearchiveindexlink'} = $thisentrypagearchiveindexlink;

	$entryVars{'thisentrypagearchivelogindexlink'} = $thisentrypagearchivelogindexlink;
	$entryVars{'thisentrypagesmartindexlink'} = $thisentrypagesmartindexlink;

	$entryVars{'thisentrycommentslink'} = $thisentrycommentslink;
	$entryVars{'thisentrycommentsform'} = $thisentrycommentsform;	
	$entryVars{'thisentrykarmalink'} = $thisentrykarmalink;
	$entryVars{'thisentrykarmaform'} = $thisentrykarmaform;
	
	$entryVars{'thisentrysearchform'} = $thisentrysearchform;
	$entryVars{'thisentrypositivekarmalink'} = $thisentrypositivekarmalink;
	$entryVars{'thisentrynegativekarmalink'} = $thisentrynegativekarmalink;
	$entryVars{'thisentrytotalkarma'} = $thisentrytotalkarma;
	
	$entryVars{'thisentrymainbody'} = $thisentrymainbody;
	$entryVars{'thisentrymorebody'} = $thisentrymorebody;	
	$entryVars{'thisentryauthorsmartlink'} = $thisentryauthorsmartlink;
	$entryVars{'thisentrycommentdivider'} = $thisentrycommentdivider;
	$entryVars{'thisentrycomments'} = $thisentrycomments;
	$entryVars{'thisentryisanarchive'} = $thisentryisanarchive;

	return( \%entryVars );
}


# ---------------
# Generate Archive Log List
# ---------------
## Generate Archive Log List will create a list of the archive logs
# ARG entryVars => the output of getEntryVariables
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a string of the archive log list
# DEPRECATES: gm_generatearchiveloglist
sub generateArchiveLogList {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $entryVars = $params{'entryVars'} || 
		&$errHandler('Invalid entryVars parameter passed to generateArchiveLogList');

	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );

	my $thisentrymonth = $entryVars->{'thisentrymonth'};
	my $thisentryday = $entryVars->{'thisentryday'};
	my $thisentryhour = $entryVars->{'thisentryhour'};
	my $thisentryminute = $entryVars->{'thisentryminute'};
	my $thisentrysecond = $entryVars->{'thisentrysecond'};
	my $thisentryweekdaynumber = $entryVars->{'thisentryweekdaynumber'};
	my $thisentryweekday = $entryVars->{'thisentryweekday'};
	my $thisentrymonthword = $entryVars->{'thisentrymonthword'};
	my $thisentrymonthmonth = $entryVars->{'thisentrymonthmonth'};
	my $thisentrydayday = $entryVars->{'thisentrydayday'};
	my $thisentryhourhour = $entryVars->{'thisentryhourhour'};
	my $thisentryminuteminute = $entryVars->{'thisentryminuteminute'};
	my $thisentrysecondsecond = $entryVars->{'thisentrysecondsecond'};


# Problem: If the last archived entry is a different month/year from the current month/year, the
# {{calendar}} on the Archive Master Index page displays the month/year of the last archived
# entry instead of the current month/year.  For example, my last archived entry was 8/21/2001
# but the current date was 9/3/2001 when I discovered this problem.  The {{calendar}} displayed
# on the Archive Master Index page was for August 2001 not for September 2001.
# The following section of code corrects this problem by getting the current date and using
# the current date instead of the last archived date to create the {{calendar}} on the
# Archive Master Index page.
	my ($tsec,$tmin,$thour,$tmday,$tmon,$tyear,$twday,$tyday,$tisdst) = localtime(time);
	$tmon += 1;
	$tyear += 1900;

	if( ($tmon != $thisentrymonth) || ($tyear != $entryVars->{'thisentryyearyear'}) ){ 
		$thisentrymonth = $tmon;
		$thisentryday = $tmday;  
		$thisentryhour = $thour;  
		$thisentryminute = $tmin;  
		$thisentrysecond = $tsec;  
		$thisentryweekdaynumber = $twday;  

		$thisentryweekday = (Gm_Constants::DAYS)[$twday];  
		$thisentrymonthword = (Gm_Constants::MONTHS)[$tmon];  
		$thisentrymonthmonth = Gm_Utils::toTwoDigit( $thisentrymonth );  
		$thisentrydayday = Gm_Utils::toTwoDigit( $thisentryday );  
		$thisentryhourhour = Gm_Utils::toTwoDigit( $thisentryhour );  
		$thisentryminuteminute = Gm_Utils::toTwoDigit( $thisentryminute );  
		$thisentrysecondsecond = Gm_Utils::toTwoDigit( $thisentrysecond );  
	}
###########################################################
## Should this permanently affect calling routine? seems like  yes

	my $gmentrylist = Gm_Storage::getEntrylist( errHandler=>$errHandler );

	my $listcountmonthyear = 'begin';
	my $listcountweek = 'begin';

	my $logarchivelistfinal = Gm_Constants::EMPTY;

	foreach my $entry ( sort { $gmentrylist->{$b}{'id'} <=> $gmentrylist->{$a}{'id'} } keys( %$gmentrylist ) ) {
		my $loglistnumber = $gmentrylist->{$entry}{'id'};
		my $loglistauthor = $gmentrylist->{$entry}{'author'};
		my $loglistsubject = $gmentrylist->{$entry}{'subject'};
		my $loglistdate = $gmentrylist->{$entry}{'created'};
		my $loglisttimeampm = $gmentrylist->{$entry}{'createt'};
		my $loglistopenstatus = $gmentrylist->{$entry}{'status'};
		my $loglistmorestatus = $gmentrylist->{$entry}{'extended'};

		my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$entry} , 
			errHandler=>$errHandler );

## TODO: REFACTORE TO USE STANDARD CONSTANT CLOSED VAR, INSTEAD OF C, O, ETC.	
		unless( $loglistopenstatus eq 'C' ){

			my $thisloglistmonthyear = "$gmLogListVars->{loglistmonthmonth} $gmLogListVars->{loglistyearyear}";
			my $thisloglistweek = "$gmLogListVars->{loglistweekbeginningdayday}$gmLogListVars->{loglistweekendingdayday}";

			if( $CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK ){
				if( $thisloglistweek ne $listcountweek ){

					my $listsubsub = translateArchiveTemplates( 
						template=>$TEMPLATES->{'gmlogarchiveslinkweeklytemplate'},
						archiveVars=>$gmLogListVars, errHandler=>$errHandler );
					
					$listsubsub .= '|*|';
					$logarchivelistfinal .= $listsubsub;
					$listcountweek = $thisloglistweek;
				}
			} else {
				if ($thisloglistmonthyear ne $listcountmonthyear) {

					my $listsubsub = translateArchiveTemplates( 
						template=>$TEMPLATES->{'gmlogarchiveslinktemplate'},
						archiveVars=>$gmLogListVars, errHandler=>$errHandler );

					$listsubsub .= '|*|';
					$logarchivelistfinal .= $listsubsub;
					$listcountmonthyear = $thisloglistmonthyear;
				}
			}
		}
	}

	my @loglistfinalcollection = split (/\|\*\|/, $logarchivelistfinal);

	if( $CONFIGS->{'gmentrylistsortorder'} eq Gm_Constants::DESCENDING ){
		@loglistfinalcollection = reverse @loglistfinalcollection; 
	}

	$logarchivelistfinal = join( $TEMPLATES->{'gmlogarchiveslinkseparatortemplate'}, 
		@loglistfinalcollection);

	return( $logarchivelistfinal );
}

# -----------------
# generate calendar
# -----------------
## Generate Calendar will do the calendar tab substitution
# ARG entryVars => the output of getEntryVariables
# (opt) ARG errHandler => the error handler used to display errors
# RETURN1: a string of the calendar with templates extrapolated
# RETURN2: calendarweekfull => a string of the calendarweek with templates extrapolated
# DEPRECATES: gm_generatecalendar
sub generateCalendar {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $entryVars = $params{'entryVars'} || 
		&$errHandler('Invalid entryVars parameter passed to generateCalendar');


	my $usethisentrydayday = Gm_Utils::toTwoDigit( $entryVars->{'thisentryday'} );
	my $usethisentrymonthmonth = Gm_Utils::toTwoDigit( $entryVars->{'thisentrymonth'} );
	my $usethisentryyear = substr( $entryVars->{'thisentryyearyear'}, -2, 2 );
	my $usethisentrymonthwordupper = uc( $entryVars->{'thisentrymonthword'} );
	my $usethisentrymonthwordlower = lc( $entryVars->{'thisentrymonthword'} );
	my $usethisentrymonthwordshort = substr( $entryVars->{'thisentrymonthword'}, 0, 3 );
	my $usethisentrymonthworduppershort = uc( $usethisentrymonthwordshort );
	my $usethisentrymonthwordlowershort = lc( $usethisentrymonthwordshort );

	my $maxdaysinthismonth = Gm_Utils::getDays( $entryVars->{'thisentrymonth'}, 
		$entryVars->{'thisentryyearyear'} );
	my $maxdaysinpreviousmonth = '';
	if( $entryVars->{'thisentrymonth'} == 1 ){
		$maxdaysinpreviousmonth = Gm_Utils::getDays( 12, 
			$entryVars->{'thisentryyearyear'}-1  );
	} else {
		$maxdaysinpreviousmonth = Gm_Utils::getDays( $entryVars->{'thisentrymonth'}-1, 
			$entryVars->{'thisentryyearyear'}  );
	}


	my @calendarweekday = ();
	$calendarweekday[$entryVars->{'thisentryweekdaynumber'}] = $entryVars->{'thisentryday'};
	my $weekcountfrom = $entryVars->{'thisentryweekdaynumber'};
	my $weekcountfromday = $entryVars->{'thisentryday'};
	my $weekcountspecial = Gm_Constants::NONE;


	unless( $weekcountfrom < 1 ){
		do {
			$weekcountfrom--;
			$weekcountfromday--;

			if( $weekcountfromday < 1 ){
				$weekcountfromday = $maxdaysinpreviousmonth;
				$weekcountspecial = 'gotolastmonth';
			}
			unless( $weekcountfrom < 0 ){ 
				$calendarweekday[$weekcountfrom] = $weekcountfromday; 
			}

		} until( $weekcountfrom < 1 );
	}

	$weekcountfrom = $entryVars->{'thisentryweekdaynumber'};
	$weekcountfromday = $entryVars->{'thisentryday'};

	unless( $weekcountfrom > 5 ){ ## INFINI loop bad
		do {
			$weekcountfrom++;
			$weekcountfromday++;
			if( $weekcountfromday > $maxdaysinthismonth ){
				$weekcountfromday = 1;
				$weekcountspecial = 'gotonextmonth';
			}
			unless( $weekcountfrom > 6 ){ 
				$calendarweekday[$weekcountfrom] = $weekcountfromday; 
			}
		} until( $weekcountfrom > 5 );
	}

	my $countfromhere = $entryVars->{'thisentryday'};
	my @calendardataday = ();
	$calendardataday[$entryVars->{'thisentryday'}] = $entryVars->{'thisentryweekdaynumber'};

	unless( $countfromhere < 2 ){
		do {
			my $thistempday = $calendardataday[$countfromhere];
			$thistempday--;
			$countfromhere--;
			if( $thistempday < 0 ){ 
				$thistempday = 6; 
			}
			$calendardataday[$countfromhere] = $thistempday;
		} until( $countfromhere < 2 );
	}

	$weekcountfromday = $entryVars->{'thisentryday'};
	$countfromhere = $entryVars->{'thisentryday'};

	unless( $countfromhere eq $maxdaysinthismonth ){
		do {
			my $thistempday = $calendardataday[$countfromhere];
			$thistempday++;
			$countfromhere++;
			if( $thistempday > 6 ){ 
				$thistempday = 0; 
			}
			$calendardataday[$countfromhere] = $thistempday;
		} until( $countfromhere eq $maxdaysinthismonth );
	}

	my $calendarfull = $TEMPLATES->{'gmcalendartablebeginningtemplate'};

	$calendarfull .= "$TEMPLATES->{'gmcalendarblankcelltemplate'}" x $calendardataday[1];

	my $gmentrylist = Gm_Storage::getEntrylist( errHandler=>$errHandler );
	my @sortedentries = sort { $gmentrylist->{$b}{'id'} <=> $gmentrylist->{$a}{'id'} } keys( %$gmentrylist );

	my $loglistdates = Gm_Constants::EMPTY;
	foreach my $entry ( @sortedentries ) {
		my $thisloglistdate = $gmentrylist->{$entry}{'created'};
		my $thisloglistopenstatus = $gmentrylist->{$entry}{'status'};
		
		## Making list of loglistdates space seperated?
		unless( $thisloglistopenstatus eq 'C' ){ 
			$loglistdates .= "$thisloglistdate "; 
		}
	}

	$weekcountfrom = 0;
	my $calendarweekfull = Gm_Constants::EMPTY;

	do {
		my $currentcountday = $calendarweekday[$weekcountfrom];
		my $currentcountmonth = $entryVars->{'thisentrymonth'};
		my $currentcountyearyear = $entryVars->{'thisentryyearyear'};
		## TODO: FIGURE WHAT DOING, SIMPLIFY, MODULARIZE
		if( ($currentcountday > 20) && ($weekcountspecial eq 'gotolastmonth') ) {
			$currentcountmonth--;
			if ($currentcountmonth < 1) {
				$currentcountmonth = 12;
				$currentcountyearyear--;
			}
		}
		## TODO: FIGURE WHAT DOING, SIMPLIFY, MODULARIZE
		if( ($currentcountday < 10) && ($weekcountspecial eq 'gotonextmonth') ){
			$currentcountmonth++;
			if ($currentcountmonth > 12) {
				$currentcountmonth = 1;
				$currentcountyearyear++;
			}
		}

		my $currentcountdayday = Gm_Utils::toTwoDigit( $currentcountday);
		my $currentcountmonthmonth = Gm_Utils::toTwoDigit( $currentcountmonth);
		my $currentcountyear = substr($currentcountyearyear, -2, 2);
		my $thisweeklistdate = "$currentcountmonthmonth\/$currentcountdayday\/$currentcountyear";
		## TODO: THIS IS A MATCH, MAKE IT EXPLICIT, ADD GI?
		if( $loglistdates =~ /$thisweeklistdate/ ){ 
			if( $CONFIGS->{'gmgenerateentrypages'} eq Gm_Constants::NO ){
			
				foreach my $entry ( @sortedentries ){
					my $loglistdate = $gmentrylist->{$entry}{'created'};
	
					if( $loglistdate eq $thisweeklistdate ){
						my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$entry}, 
							errHandler=>$errHandler );
						my $listsubsub = translateArchiveTemplates( 
							template=>$TEMPLATES->{'gmcalendarweekfulldaytemplate'},
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$calendarweekfull .= $listsubsub;
					}
				}
			} else {
				my $thiscalendarweeklink = Gm_Constants::EMPTY;
				
				foreach my $entry ( @sortedentries ){
					my $loglistdate = $gmentrylist->{$entry}{'created'};
 					my $loglistmorestatus = $gmentrylist->{$entry}{'extended'};
	
					if( ($loglistdate eq $thisweeklistdate) && 
						($thiscalendarweeklink eq Gm_Constants::EMPTY) ){
						unless( ($loglistmorestatus eq 'N') && 
							($CONFIGS->{'gmlinktocalendarentries'} eq Gm_Constants::MORE) ){
							$thiscalendarweeklink = Gm_Constants::YES;
						}
					}
				}
				
				## TODO: What are we doing?
				if( $thiscalendarweeklink eq Gm_Constants::EMPTY ){
					my $listsubsub = $TEMPLATES->{'gmcalendarweekfulldaytemplate'};
					$listsubsub =~ s/{{day}}/$currentcountday/g;
					$listsubsub =~ s/{{day}}/$currentcountday/g;
					$listsubsub =~ s/{{month}}/$currentcountmonth/g;
					$listsubsub =~ s/{{monthmonth}}/$currentcountmonthmonth/g;
					$listsubsub =~ s/{{year}}/$currentcountyear/g;
					$listsubsub =~ s/{{yearyear}}/$currentcountyearyear/g;
					$calendarweekfull .= $listsubsub;
				} else {
					## Loopking through in desc sort
					foreach my $entry ( @sortedentries ) {
						my $loglistdate = $gmentrylist->{$entry}{'created'};
						my $loglistopenstatus = $gmentrylist->{$entry}{'status'};
	
						if( ($loglistdate eq $thisweeklistdate) && 
							($thiscalendarweeklink eq Gm_Constants::YES) && 
							($loglistopenstatus ne 'C') ){
							my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$entry}, 
								errHandler=>$errHandler );
							my $listsubsub = translateArchiveTemplates( 
								template=>$TEMPLATES->{'gmcalendarweekfulldaylinktemplate'},
								archiveVars=>$gmLogListVars, errHandler=>$errHandler );
							$calendarweekfull .= $listsubsub;
							$thiscalendarweeklink = Gm_Constants::EMPTY;
						}
					}
				}
			}
		} else {

			my $listsubsub = $TEMPLATES->{'gmcalendarweekfulldaytemplate'};
			$listsubsub =~ s/{{day}}/$currentcountday/g;
			$listsubsub =~ s/{{day}}/$currentcountday/g;
			$listsubsub =~ s/{{month}}/$currentcountmonth/g;
			$listsubsub =~ s/{{monthmonth}}/$currentcountmonthmonth/g;
			$listsubsub =~ s/{{year}}/$currentcountyear/g;
			$listsubsub =~ s/{{yearyear}}/$currentcountyearyear/g;
			$calendarweekfull .= $listsubsub;
		}
		$weekcountfrom++;
	} until( $weekcountfrom > 6 );

	## Resetting counter
	$countfromhere = 1;

	do {
		my $countfromherepadded = Gm_Utils::toTwoDigit( $countfromhere );
		my $thislistdate = "$usethisentrymonthmonth\/$countfromherepadded\/$usethisentryyear";
		if( $loglistdates =~ /$thislistdate/ ){
			if( $CONFIGS->{'gmgenerateentrypages'} eq Gm_Constants::NO ){
			
				foreach my $entry ( @sortedentries ) {
					my $loglistdate = $gmentrylist->{$entry}{'created'};
	
					if( $loglistdate eq $thislistdate ){
						my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$entry} , 
							errHandler=>$errHandler );
						my $listsubsub = translateArchiveTemplates( 
							template=>$TEMPLATES->{'gmcalendarfullcelltemplate'},
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$calendarfull .= $listsubsub;
					}
				}
			} else {
				my $thiscalendarlink = Gm_Constants::EMPTY;
				foreach my $entry ( @sortedentries ) {
					my $loglistdate = $gmentrylist->{$entry}{'created'};
					my $loglistmorestatus = $gmentrylist->{$entry}{'extended'};
	
					if( ($loglistdate eq $thislistdate) && ($thiscalendarlink eq Gm_Constants::EMPTY) ){
						unless( ($loglistmorestatus eq 'N') && 
							($CONFIGS->{'gmlinktocalendarentries'} eq Gm_Constants::MORE) ){
							$thiscalendarlink = Gm_Constants::YES;
						}
					}
				}
				if( $thiscalendarlink eq Gm_Constants::EMPTY ){
					my $listsubsub = $TEMPLATES->{'gmcalendarfullcelltemplate'};
					$listsubsub =~ s/{{day}}/$countfromhere/g;
					$listsubsub =~ s/{{day}}/$countfromherepadded/g;
					$calendarfull .= $listsubsub;
				} else {
				
					foreach my $entry ( @sortedentries ) {
						my $loglistdate = $gmentrylist->{$entry}{'created'};
						my $loglistopenstatus = $gmentrylist->{$entry}{'status'};
	
						## TODO: USE STANDARDS INSTEAD OF 'C', BUT WILL HAVE TO MODIFY ENTRYLISTS
						if( ($loglistdate eq $thislistdate) && 
							($thiscalendarlink eq Gm_Constants::YES) && ($loglistopenstatus ne 'C') ){
							my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$entry} , 
								errHandler=>$errHandler );
							my $listsubsub = translateArchiveTemplates( 
								template=>$TEMPLATES->{'gmcalendarfullcelllinktemplate'},
								archiveVars=>$gmLogListVars, errHandler=>$errHandler );
							$calendarfull .= $listsubsub;
							$thiscalendarlink = Gm_Constants::EMPTY;
						}
					}
				}
			}
			## TODO: DIFFERENCE BETWEEN ABOVE AND HERE SEEMS TO BE LIST VS. WEEKLIST
			# CAN THIS BE REFACTORED TO SMALLER CODE BASE?
		} else {
			my $listsubsub = $TEMPLATES->{'gmcalendarfullcelltemplate'};
			$listsubsub =~ s/{{day}}/$countfromhere/g;
			$listsubsub =~ s/{{day}}/$countfromherepadded/g;
			$calendarfull .= $listsubsub;
		}
	## calendar fix addressing when last day of month falls on Saturday
		if( ($calendardataday[$countfromhere] eq '6') && ($countfromhere ne $maxdaysinthismonth) ){ 
			$calendarfull .= "</tr>\n<tr>"; 
		}
		$countfromhere++;
	} until $countfromhere > $maxdaysinthismonth;
	## TODO, WHAT IS THIS LOOP DOING? GOING THROUGH EACH DAY IN MONTH?

	my $endofcaldisplay = 6 - $calendardataday[$maxdaysinthismonth];
	$calendarfull .= "$TEMPLATES->{'gmcalendarblankcelltemplate'}" x $endofcaldisplay;
	$calendarfull .= $TEMPLATES->{'gmcalendartableendingtemplate'};
	
	$calendarfull =~ s/{{month}}/$entryVars->{'thisentrymonth'}/g;	
	$calendarfull =~ s/{{monthmonth}}/$usethisentrymonthmonth/g;
	$calendarfull =~ s/{{year}}/$usethisentryyear/g;
	$calendarfull =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/g;
	$calendarfull =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/g;
	$calendarfull =~ s/{{monthwordupper}}/$usethisentrymonthwordupper/g;
	$calendarfull =~ s/{{monthwordlower}}/$usethisentrymonthwordlower/g;
	$calendarfull =~ s/{{monthwordshort}}/$usethisentrymonthwordshort/g;
	$calendarfull =~ s/{{monthworduppershort}}/$usethisentrymonthworduppershort/g;
	$calendarfull =~ s/{{monthwordlowershort}}/$usethisentrymonthwordlowershort/g;

	return( $calendarfull, $calendarweekfull );
}


# ---------------
# Generate Entry Log List
# ---------------
## Generate Entry Log List will create a list of the entry logs

# 	logshortentrylistfinal => 
# 	logmoreentrylistfinal => 
# 	logentrylistfinal => 
# 	logshortentrylistmonthfinal => 
# 	logshortentrylistdayfinal => 
# 	logshortentrylistyearfinal => 
# 	logmoreentrylistmonthfinal => 
# 	logmoreentrylistdayfinal => 
# 	logmoreentrylistyearfinal => 
# 	logentrylistmonthfinal => 
# 	logentrylistdayfinal => 
# 	logentrylistyearfinal => 
# 	logshortentrylistnumberfinal => 
# 	logmoreentrylistnumberfinal => 
# 	logentrylistnumberfinal => 
# 	logshortentrylistfirsthalffinal => 
# 	logshortentrylistsecondhalffinal => 
# 	logmoreentrylistfirsthalffinal => 
# 	logmoreentrylistsecondhalffinal => 
# 	logentrylistfirsthalffinal => 
# 	logentrylistsecondhalffinal => 

# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a hash of the entry log list variables
# DEPRECATES: gm_generateentryloglist
sub generateEntryLogList {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	

	my %entryLogVars = ();

	my $logshortentrylistfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistfinal = Gm_Constants::EMPTY;
	my $logentrylistfinal = Gm_Constants::EMPTY;
	my $logshortentrylistmonthfinal = Gm_Constants::EMPTY;
	my $logshortentrylistdayfinal = Gm_Constants::EMPTY;
	my $logshortentrylistyearfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistmonthfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistdayfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistyearfinal = Gm_Constants::EMPTY;
	my $logentrylistmonthfinal = Gm_Constants::EMPTY;
	my $logentrylistdayfinal = Gm_Constants::EMPTY;
	my $logentrylistyearfinal = Gm_Constants::EMPTY;
	my $logshortentrylistnumberfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistnumberfinal = Gm_Constants::EMPTY;
	my $logentrylistnumberfinal = Gm_Constants::EMPTY;
	my $logshortentrylistfirsthalffinal = Gm_Constants::EMPTY;
	my $logshortentrylistsecondhalffinal = Gm_Constants::EMPTY;
	my $logmoreentrylistfirsthalffinal = Gm_Constants::EMPTY;
	my $logmoreentrylistsecondhalffinal = Gm_Constants::EMPTY;
	my $logentrylistfirsthalffinal = Gm_Constants::EMPTY;
	my $logentrylistsecondhalffinal = Gm_Constants::EMPTY;

	my $gmentrylist = Gm_Storage::getEntrylist( errHandler=>$errHandler );
	
	my @gmsortkeys = keys( %$gmentrylist );
	@gmsortkeys = sort {
			lc($gmentrylist->{$b}{'id'}) <=> lc($gmentrylist->{$a}{'id'});
		} @gmsortkeys;
	
	# If the order is descending change the order
	if( $CONFIGS->{'gmentrylistsortorder'} eq Gm_Constants::DESCENDING ){ 
		@gmsortkeys = reverse @gmsortkeys; 
	}


	my $toploglistnumber = $gmentrylist->{$gmsortkeys[0]}{'id'};
	my $toploglistauthor = $gmentrylist->{$gmsortkeys[0]}{'author'};
	my $toploglistsubject = $gmentrylist->{$gmsortkeys[0]}{'subject'};
	my $toploglistdate = $gmentrylist->{$gmsortkeys[0]}{'created'};
	my $toploglisttimeampm = $gmentrylist->{$gmsortkeys[0]}{'createt'};
	my $toploglistopenstatus = $gmentrylist->{$gmsortkeys[0]}{'status'};
	my $toploglistmorestatus = $gmentrylist->{$gmsortkeys[0]}{'extended'};

	my ($toploglistmonthmonth, $toploglistdayday, $toploglistyear) = split (/\//, $toploglistdate);

	my $shortentrycounter = 0;
	my $moreentrycounter = 0;
	my $allentrycounter = 0;

	my $shorttotalentrycounter = 0;
	my $moretotalentrycounter = 0;
	my $alltotalentrycounter = 0;

	## TODO: WHAT IS BEING DONE HERE?
	foreach my $elkey ( @gmsortkeys ){
		my $loglistcounternumber = $gmentrylist->{$elkey}{'id'};
		my $loglistcounterauthor = $gmentrylist->{$elkey}{'author'};
		my $loglistcountersubject = $gmentrylist->{$elkey}{'subject'};
		my $loglistcounterdate = $gmentrylist->{$elkey}{'created'};
		my $loglistcountertimeampm = $gmentrylist->{$elkey}{'createt'};
		my $loglistcounteropenstatus = $gmentrylist->{$elkey}{'status'};
		my $loglistcountermorestatus = $gmentrylist->{$elkey}{'extended'};

		## TODO: CHANGE TO USE CONSTANT CLOSE VAR	
		unless( $loglistcounteropenstatus eq 'C' ){
			$alltotalentrycounter++;
			if( $loglistcountermorestatus eq 'Y' ){ 
				$moretotalentrycounter++; 
			} else { 
				$shorttotalentrycounter++; 
			}
		}
	}

	my $shorttotalentryhalfcounter = Gm_Utils::toNoDec( ($shorttotalentrycounter / 2));
	my $moretotalentryhalfcounter = Gm_Utils::toNoDec( ($moretotalentrycounter / 2));
	my $alltotalentryhalfcounter = Gm_Utils::toNoDec( ($alltotalentrycounter / 2));

	my $listdaymarker = 'tommy';
	my $listmonthmarker = 'tommy';
	my $listyearmarker = 'tommy';

	foreach my $elkey ( @gmsortkeys ){
		my $loglistnumber = $gmentrylist->{$elkey}{'id'};
		my $loglistauthor = $gmentrylist->{$elkey}{'author'};
		my $loglistsubject = $gmentrylist->{$elkey}{'subject'};
		my $loglistdate = $gmentrylist->{$elkey}{'created'};
		my $loglisttimeampm = $gmentrylist->{$elkey}{'createt'};
		my $loglistopenstatus = $gmentrylist->{$elkey}{'status'};
		my $loglistmorestatus = $gmentrylist->{$elkey}{'extended'};
	
		## TODO: CHANGE TO USE CONSTANT CLOSE VAR
		unless( $loglistopenstatus eq 'C' ){
	
			my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$elkey}, 
				errHandler=>$errHandler );
	
			my $usethismorelinktemplate = $TEMPLATES->{'gmmoreentrypagelinktemplate'};
			my $usethislinktemplate = $TEMPLATES->{'gmentrypagelinktemplate'};			
	
			if( ($TEMPLATES->{'gmentrypagelinkdayseparatortemplate'} ne Gm_Constants::EMPTY) && 
				($listdaymarker ne $gmLogListVars->{'loglistday'} ) ){
				$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkdayseparatortemplate'}".
					"|*|$usethismorelinktemplate";
				$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkdayseparatortemplate'}".
					"|*|$usethislinktemplate";
			}
	
			if( ($TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'} ne Gm_Constants::EMPTY) && 
				($listmonthmarker ne $gmLogListVars->{'loglistmonth'} ) ){
				$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'}".
					"|*|$usethismorelinktemplate";
				$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'}".
					"|*|$usethislinktemplate";
			}
			
			if( ($TEMPLATES->{'gmentrypagelinkyearseparatortemplate'} ne Gm_Constants::EMPTY) && 
				($listyearmarker ne $gmLogListVars->{'loglistyear'} ) ){
				$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkyearseparatortemplate'}".
					"|*|$usethismorelinktemplate";
				$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkyearseparatortemplate'}".
					"|*|$usethislinktemplate";
			}
	
			my $listsubsub = '';
			if ($loglistmorestatus eq 'Y') {
				$moreentrycounter++;

				$listsubsub = translateArchiveTemplates( 
					template=>$usethismorelinktemplate,
					archiveVars=>$gmLogListVars, errHandler=>$errHandler );
				
				$listsubsub .= '|*|';
				$logmoreentrylistfinal .= $listsubsub;
				if( $gmLogListVars->{'loglistmonthmonth'} eq $toploglistmonthmonth ){ 
					$logmoreentrylistmonthfinal .= $listsubsub; 
				}
				if( $gmLogListVars->{'loglistdayday'} eq $toploglistdayday ){ 
					$logmoreentrylistdayfinal .= $listsubsub; 
				}
				if( $gmLogListVars->{'loglistyear'} eq $toploglistyear ){ 
					$logmoreentrylistyearfinal .= $listsubsub; 
				}
				unless( $moreentrycounter > $CONFIGS->{'gmentrylistcountnumber'} ){ 
					$logmoreentrylistnumberfinal .= $listsubsub; 
				}
				if( $moreentrycounter <= $moretotalentryhalfcounter ){
					$logmoreentrylistfirsthalffinal .= $listsubsub;
				} else {
					$logmoreentrylistsecondhalffinal .= $listsubsub;
				}
			} else {
				$shortentrycounter++;

				$listsubsub = translateArchiveTemplates( 
					template=>$usethislinktemplate,
					archiveVars=>$gmLogListVars, errHandler=>$errHandler );
				
				$listsubsub .= '|*|';
				$logshortentrylistfinal .= $listsubsub;
				if( $gmLogListVars->{'loglistmonthmonth'} eq $toploglistmonthmonth ){ 
					$logshortentrylistmonthfinal .= $listsubsub; 
				}
				if( $gmLogListVars->{'loglistdayday'} eq $toploglistdayday ){ 
					$logshortentrylistdayfinal .= $listsubsub; 
				}
				if( $gmLogListVars->{'loglistyear'} eq $toploglistyear ){ 
					$logshortentrylistyearfinal .= $listsubsub; 
				}
				unless ($shortentrycounter > $CONFIGS->{'gmentrylistcountnumber'} ){ 
					$logshortentrylistnumberfinal .= $listsubsub; 
				}
				if ($shortentrycounter <= $shorttotalentryhalfcounter) {
					$logshortentrylistfirsthalffinal .= $listsubsub;
				} else {
					$logshortentrylistsecondhalffinal .= $listsubsub;
				}
			}
	
			$allentrycounter++;
			$logentrylistfinal .= $listsubsub;
			if( $gmLogListVars->{'loglistmonthmonth'} eq $toploglistmonthmonth ){ 
				$logentrylistmonthfinal .= $listsubsub; 
			}
			if( $gmLogListVars->{'loglistdayday'} eq $toploglistdayday ){ 
				$logentrylistdayfinal .= $listsubsub; 
			}
			if( $gmLogListVars->{'loglistyear'} eq $toploglistyear ){ 
				$logentrylistyearfinal .= $listsubsub; 
			}
			unless( $allentrycounter > $CONFIGS->{'gmentrylistcountnumber'} ){ 
				$logentrylistnumberfinal .= $listsubsub; 
			}
			if ($allentrycounter <= $alltotalentryhalfcounter) {
				$logentrylistfirsthalffinal .= $listsubsub;
			} else {
				$logentrylistsecondhalffinal .= $listsubsub;
			}
	
			$listdaymarker = $gmLogListVars->{'loglistday'};
			$listmonthmarker = $gmLogListVars->{'loglistmonth'};
			$listyearmarker = $gmLogListVars->{'loglistyear'};
		}
	} ## end of foreach


	my @logshortentrylistfinalcollection = split (/\|\*\|/, $logshortentrylistfinal);
	my @logmoreentrylistfinalcollection = split (/\|\*\|/, $logmoreentrylistfinal);
	my @logentrylistfinalcollection = split (/\|\*\|/, $logentrylistfinal);
	my @logshortentrylistmonthfinalcollection = split (/\|\*\|/, $logshortentrylistmonthfinal);
	my @logshortentrylistdayfinalcollection = split (/\|\*\|/, $logshortentrylistdayfinal);
	my @logshortentrylistyearfinalcollection = split (/\|\*\|/, $logshortentrylistyearfinal);
	my @logmoreentrylistmonthfinalcollection = split (/\|\*\|/, $logmoreentrylistmonthfinal);
	my @logmoreentrylistdayfinalcollection = split (/\|\*\|/, $logmoreentrylistdayfinal);
	my @logmoreentrylistyearfinalcollection = split (/\|\*\|/, $logmoreentrylistyearfinal);
	my @logentrylistmonthfinalcollection = split (/\|\*\|/, $logentrylistmonthfinal);
	my @logentrylistdayfinalcollection = split (/\|\*\|/, $logentrylistdayfinal);
	my @logentrylistyearfinalcollection = split (/\|\*\|/, $logentrylistyearfinal);
	my @logshortentrylistnumberfinalcollection = split (/\|\*\|/, $logshortentrylistnumberfinal);
	my @logmoreentrylistnumberfinalcollection = split (/\|\*\|/, $logmoreentrylistnumberfinal);
	my @logentrylistnumberfinalcollection = split (/\|\*\|/, $logentrylistnumberfinal);
	my @logshortentrylistfirsthalffinalcollection = split (/\|\*\|/, $logshortentrylistfirsthalffinal);
	my @logshortentrylistsecondhalffinalcollection = split (/\|\*\|/, $logshortentrylistsecondhalffinal);
	my @logmoreentrylistfirsthalffinalcollection = split (/\|\*\|/, $logmoreentrylistfirsthalffinal);
	my @logmoreentrylistsecondhalffinalcollection = split (/\|\*\|/, $logmoreentrylistsecondhalffinal);
	my @logentrylistfirsthalffinalcollection = split (/\|\*\|/, $logentrylistfirsthalffinal);
	my @logentrylistsecondhalffinalcollection = split (/\|\*\|/, $logentrylistsecondhalffinal);

	$logshortentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistfinalcollection);
	$logmoreentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistfinalcollection);
	$logentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistfinalcollection);
	$logshortentrylistmonthfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistmonthfinalcollection);
	$logshortentrylistdayfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistdayfinalcollection);
	$logshortentrylistyearfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistyearfinalcollection);
	$logmoreentrylistmonthfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistmonthfinalcollection);
	$logmoreentrylistdayfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistdayfinalcollection);
	$logmoreentrylistyearfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistyearfinalcollection);
	$logentrylistmonthfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistmonthfinalcollection);
	$logentrylistdayfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistdayfinalcollection);
	$logentrylistyearfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistyearfinalcollection);
	$logshortentrylistnumberfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistnumberfinalcollection);
	$logmoreentrylistnumberfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistnumberfinalcollection);
	$logentrylistnumberfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistnumberfinalcollection);
	$logshortentrylistfirsthalffinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistfirsthalffinalcollection);
	$logshortentrylistsecondhalffinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistsecondhalffinalcollection);
	$logmoreentrylistfirsthalffinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistfirsthalffinalcollection);
	$logmoreentrylistsecondhalffinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistsecondhalffinalcollection);
	$logentrylistfirsthalffinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistfirsthalffinalcollection);
	$logentrylistsecondhalffinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistsecondhalffinalcollection);

	$entryLogVars{'logshortentrylistfinal'} = $logshortentrylistfinal;
	$entryLogVars{'logmoreentrylistfinal'} = $logmoreentrylistfinal;
	$entryLogVars{'logentrylistfinal'} = $logentrylistfinal;
	$entryLogVars{'logshortentrylistmonthfinal'} = $logshortentrylistmonthfinal;
	$entryLogVars{'logshortentrylistdayfinal'} = $logshortentrylistdayfinal;
	$entryLogVars{'logshortentrylistyearfinal'} = $logshortentrylistyearfinal;
	$entryLogVars{'logmoreentrylistmonthfinal'} = $logmoreentrylistmonthfinal;
	$entryLogVars{'logmoreentrylistdayfinal'} = $logmoreentrylistdayfinal;
	$entryLogVars{'logmoreentrylistyearfinal'} = $logmoreentrylistyearfinal;
	$entryLogVars{'logentrylistmonthfinal'} = $logentrylistmonthfinal;
	$entryLogVars{'logentrylistdayfinal'} = $logentrylistdayfinal;
	$entryLogVars{'logentrylistyearfinal'} = $logentrylistyearfinal;
	$entryLogVars{'logshortentrylistnumberfinal'} = $logshortentrylistnumberfinal;
	$entryLogVars{'logmoreentrylistnumberfinal'} = $logmoreentrylistnumberfinal;
	$entryLogVars{'logentrylistnumberfinal'} = $logentrylistnumberfinal;
	$entryLogVars{'logshortentrylistfirsthalffinal'} = $logshortentrylistfirsthalffinal;
	$entryLogVars{'logshortentrylistsecondhalffinal'} = $logshortentrylistsecondhalffinal;
	$entryLogVars{'logmoreentrylistfirsthalffinal'} = $logmoreentrylistfirsthalffinal;
	$entryLogVars{'logmoreentrylistsecondhalffinal'} = $logmoreentrylistsecondhalffinal;
	$entryLogVars{'logentrylistfirsthalffinal'} = $logentrylistfirsthalffinal;
	$entryLogVars{'logentrylistsecondhalffinal'} = $logentrylistsecondhalffinal;

	return( \%entryLogVars );
}


# -------------------------------------------
# generate log entry list for comment sorting
# -------------------------------------------
## Generate Entry Log List will create a list of the entry logs

# 	logshortentrylistfinal => 
# 	logmoreentrylistfinal => 
# 	logentrylistfinal => 
# 	logshortminimumentrylistfinal => 
# 	logmoreminimumentrylistfinal => 
# 	logminimumentrylistfinal => 
# 	logshortnumberentrylistfinal => 
# 	logmorenumberentrylistfinal => 
# 	lognumberentrylistfinal => 

# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a hash of the entry log list Comment variables
# DEPRECATES: gm_generateentryloglistcomments
sub generateEntryLogListComments {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my %entryLogCommentVars = ();

	my $gmcounters = Gm_Storage::getCounters( errHandler=>$errHandler );

	my $logshortentrylistfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistfinal = Gm_Constants::EMPTY;
	my $logentrylistfinal = Gm_Constants::EMPTY;
	my $logshortminimumentrylistfinal = Gm_Constants::EMPTY;
	my $logmoreminimumentrylistfinal = Gm_Constants::EMPTY;
	my $logminimumentrylistfinal = Gm_Constants::EMPTY;
	my $logshortnumberentrylistfinal = Gm_Constants::EMPTY;
	my $logmorenumberentrylistfinal = Gm_Constants::EMPTY;
	my $lognumberentrylistfinal = Gm_Constants::EMPTY;

	my $countfromhere = 1;
	my @countfromherelist = ();

	do {
		my $countfromherenumberpadded = Gm_Utils::toEntryPadded( $countfromhere );

		my $gmEntry = Gm_Storage::getEntry( id=>$countfromherenumberpadded, errHandler=>$errHandler );	
	
		my $countfromhereentrynumber = $gmEntry->{'entryinfo'}{'id'};
		my $countfromhereentryauthor = $gmEntry->{'entryinfo'}{'author'}; 
		my $countfromhereentrysubject = $gmEntry->{'entryinfo'}{'subject'}; 
		my $countfromhereentryweekdaynumber = $gmEntry->{'entryinfo'}{'weekday'}; 
		my $countfromhereentrymonth = $gmEntry->{'entryinfo'}{'month'}; 
		my $countfromhereentryday = $gmEntry->{'entryinfo'}{'day'}; 
		my $countfromhereentryyearyear = $gmEntry->{'entryinfo'}{'year'}; 
		my $countfromhereentryhour = $gmEntry->{'entryinfo'}{'hour'};
		my $countfromhereentryminute = $gmEntry->{'entryinfo'}{'minute'};
		my $countfromhereentrysecond = $gmEntry->{'entryinfo'}{'second'}; 
		my $countfromhereentryampm = $gmEntry->{'entryinfo'}{'ampm'}; 
		my $countfromhereentrypositivekarma = $gmEntry->{'entryinfo'}{'karmapos'}; 
		my $countfromhereentrynegativekarma = $gmEntry->{'entryinfo'}{'karmaneg'}; 
		my $countfromhereentrycommentsnumber = $gmEntry->{'entryinfo'}{'commenttotal'}; 
		my $countfromhereentryallowkarma = $gmEntry->{'entryinfo'}{'karma'}; 
		my $countfromhereentryallowcomments = $gmEntry->{'entryinfo'}{'comments'}; 
		my $countfromhereentryopenstatus = $gmEntry->{'entryinfo'}{'status'}; 
		my $countfromhereentrymusic = $gmEntry->{'entryinfo'}{'music'}; 
		my $countfromhereentrymood = $gmEntry->{'entryinfo'}{'mood'};
		my $countfromhereentryemoticonsallowed = $gmEntry->{'entryinfo'}{'emoticons'};

		my $countfromcanpost = 'Y';
		if( $countfromhereentryallowcomments eq Gm_Constants::NO ){ 
			$countfromcanpost = 'N'; 
		}

		if( ($CONFIGS->{'gmposttoarchives'} eq Gm_Constants::NO) && 
			($countfromhereentrynumber <= $gmcounters->{'archivetotal'}) ){ 
			$countfromcanpost = 'N'; 
		}
	
		unless( $countfromhereentryopenstatus eq Gm_Constants::CLOSED ){
			## Could we just push onto the array here?  It is doing a closed check
			my $countslot = $countfromhere - 1;
			$countfromherelist[$countslot] = "$countfromhereentrycommentsnumber|".
				"$countfromhereentrynumber|$countfromcanpost";
		}
	
		$countfromhere++;
	
	} until $countfromhere > $gmcounters->{'entrytotal'};

	## doing a numerical sort, not util, because tailored, sortina string 00|00|Y
	@countfromherelist = sort _numLogListCommentSort @countfromherelist;

	unless( $CONFIGS->{'gmentrylistsortorder'} eq Gm_Constants::DESCENDING ){ 
		@countfromherelist = reverse @countfromherelist; 
	}

	my $gmentrylist = Gm_Storage::getEntrylist( errHandler=>$errHandler );

	my $shortentrycounter = 0;
	my $moreentrycounter = 0;
	my $allentrycounter = 0;

	my $listdaymarker = "tommy";
	my $listmonthmarker = "tommy";
	my $listyearmarker = "tommy";

	foreach my $countfromhereline ( @countfromherelist ){
	
		my ($countfromherecommentsnumber, $countfromhereentrynumber, $countfromherecanpost) = 
			split (/\|/, $countfromhereline);
	
SCAN: foreach my $entry ( sort { $gmentrylist->{$b}{'id'} <=> $gmentrylist->{$a}{'id'} } keys( %$gmentrylist ) ) {
	
			my $loglistnumber = $gmentrylist->{$entry}{'id'};
			my $loglistauthor = $gmentrylist->{$entry}{'author'};
			my $loglistsubject = $gmentrylist->{$entry}{'subject'};
			my $loglistdate = $gmentrylist->{$entry}{'created'};
			my $loglisttimeampm = $gmentrylist->{$entry}{'createt'};
			my $loglistopenstatus = $gmentrylist->{$entry}{'status'};
			my $loglistmorestatus = $gmentrylist->{$entry}{'extended'};
	
			if( $loglistnumber eq $countfromhereentrynumber ){
				unless( ($countfromherecanpost eq 'N') && 
					($CONFIGS->{'gmcommententrylistonlyifokay'} eq Gm_Constants::YES) ){
	
					my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$entry}, 
        		errHandler=>$errHandler );
	
					my $usethismorelinktemplate = $TEMPLATES->{'gmmoreentrypagelinktemplate'};
					my $usethislinktemplate = $TEMPLATES->{'gmentrypagelinktemplate'};
	
					if( ($TEMPLATES->{'gmentrypagelinkdayseparatortemplate'} ne Gm_Constants::EMPTY) && 
						($listdaymarker ne $gmLogListVars->{'loglistdayday'}) ){
						$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkdayseparatortemplate'}".
							"|*|$usethismorelinktemplate";
						$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkdayseparatortemplate'}".
							"|*|$usethislinktemplate";
					}
					
					if( ($TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'} ne Gm_Constants::EMPTY) && 
						($listmonthmarker ne $gmLogListVars->{'loglistmonth'}) ){
						$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'}".
							"|*|$usethismorelinktemplate";
						$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'}".
							"|*|$usethislinktemplate";
					}

					if( ($TEMPLATES->{'gmentrypagelinkyearseparatortemplate'} ne Gm_Constants::EMPTY) && 
						($listyearmarker ne $gmLogListVars->{'loglistyear'}) ){
						$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkyearseparatortemplate'}".
							"|*|$usethismorelinktemplate";
						$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkyearseparatortemplate'}".
							"|*|$usethislinktemplate";
					}
					
					my $listsubsub = '';
					if ($loglistmorestatus eq 'Y') {
						$moreentrycounter++;
						$listsubsub = translateArchiveTemplates( 
							template=>$usethismorelinktemplate,
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$listsubsub .= "|*|";
						$logmoreentrylistfinal .= $listsubsub;
						unless( $countfromherecommentsnumber < 1 ){ 
							$logmoreminimumentrylistfinal .= $listsubsub; 
						}
						unless( $moreentrycounter > $CONFIGS->{'gmentrylistcountnumber'} ){ 
							$logmorenumberentrylistfinal .= $listsubsub; 
						}

					} else {
						$shortentrycounter++;
						$listsubsub = translateArchiveTemplates( 
							template=>$usethislinktemplate,
							archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						$listsubsub .= "|*|";
						$logshortentrylistfinal .= $listsubsub;
						unless( $countfromherecommentsnumber < 1 ){ 
							$logshortminimumentrylistfinal .= $listsubsub; 
						}
						unless( $shortentrycounter > $CONFIGS->{'gmentrylistcountnumber'} ){
							$logshortnumberentrylistfinal .= $listsubsub; 
						}
					}
	
					$allentrycounter++;
					$logentrylistfinal .= $listsubsub;
					unless( $countfromherecommentsnumber < 1 ){ 
						$logminimumentrylistfinal .= $listsubsub; 
					}
					unless( $allentrycounter > $CONFIGS->{'gmentrylistcountnumber'} ){ 
						$lognumberentrylistfinal .= $listsubsub; 
					}

	
					$listdaymarker = $gmLogListVars->{'loglistday'};
					$listmonthmarker = $gmLogListVars->{'loglistmonth'};
					$listyearmarker = $gmLogListVars->{'loglistyear'};
					# we found a match, let's bail
							last SCAN;
				}
			}
		}
	}

	my @logshortentrylistfinalcollection = split (/\|\*\|/, $logshortentrylistfinal);
	my @logmoreentrylistfinalcollection = split (/\|\*\|/, $logmoreentrylistfinal);
	my @logentrylistfinalcollection = split (/\|\*\|/, $logentrylistfinal);
	my @logshortminimumentrylistfinalcollection = split (/\|\*\|/, $logshortminimumentrylistfinal);
	my @logmoreminimumentrylistfinalcollection = split (/\|\*\|/, $logmoreminimumentrylistfinal);
	my @logminimumentrylistfinalcollection = split (/\|\*\|/, $logminimumentrylistfinal);
	my @logshortnumberentrylistfinalcollection = split (/\|\*\|/, $logshortnumberentrylistfinal);
	my @logmorenumberentrylistfinalcollection = split (/\|\*\|/, $logmorenumberentrylistfinal);
	my @lognumberentrylistfinalcollection = split (/\|\*\|/, $lognumberentrylistfinal);

	$logshortentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistfinalcollection );
	$logmoreentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistfinalcollection );
	$logentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistfinalcollection );
	$logshortminimumentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortminimumentrylistfinalcollection );
	$logmoreminimumentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreminimumentrylistfinalcollection );
	$logminimumentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logminimumentrylistfinalcollection );
	$logshortnumberentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortnumberentrylistfinalcollection );
	$logmorenumberentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmorenumberentrylistfinalcollection );
	$lognumberentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@lognumberentrylistfinalcollection );

	$entryLogCommentVars{'logshortentrylistfinal'} = $logshortentrylistfinal;
	$entryLogCommentVars{'logmoreentrylistfinal'} = $logmoreentrylistfinal;
	$entryLogCommentVars{'logentrylistfinal'} = $logentrylistfinal;
	$entryLogCommentVars{'logshortminimumentrylistfinal'} = $logshortminimumentrylistfinal;
	$entryLogCommentVars{'logmoreminimumentrylistfinal'} = $logmoreminimumentrylistfinal;
	$entryLogCommentVars{'logminimumentrylistfinal'} = $logminimumentrylistfinal;
	$entryLogCommentVars{'logshortnumberentrylistfinal'} = $logshortnumberentrylistfinal;
	$entryLogCommentVars{'logmorenumberentrylistfinal'} = $logmorenumberentrylistfinal;
	$entryLogCommentVars{'lognumberentrylistfinal'} = $lognumberentrylistfinal;

	return( \%entryLogCommentVars );
}


# ----------------------------------------------
# generate log entry list for individual authors
# ----------------------------------------------
## Generate Entry Log List will create a list of the entry logs

# 	logshortentrylistfinal => 
# 	logmoreentrylistfinal => 
# 	logentrylistfinal => 

# ARG author => the author to base the variables on
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: a hash of the entry log list Author variables
# DEPRECATES: gm_generateentryloglistauthor
sub generateEntryLogListAuthor {
	my (%params) = @_;

	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $thisentryloglistauthor = $params{'author'} || '';
	my %entryLogAuthorVars = ();

	my $logshortentrylistfinal = Gm_Constants::EMPTY;
	my $logmoreentrylistfinal = Gm_Constants::EMPTY;
	my $logentrylistfinal = Gm_Constants::EMPTY;

	my $gmentrylist = Gm_Storage::getEntrylist( errHandler=>$errHandler );

	my @gmsortkeys = keys( %$gmentrylist );
	@gmsortkeys = sort {
			lc($gmentrylist->{$b}{'id'}) <=> lc($gmentrylist->{$a}{'id'});
		} @gmsortkeys;

	# If the order is descending change the order
	if ($CONFIGS->{'gmentrylistsortorder'} eq Gm_Constants::DESCENDING) { 
		@gmsortkeys = reverse @gmsortkeys; 
	}

	my $toploglistnumber = $gmentrylist->{$gmsortkeys[0]}{'id'};
	my $toploglistauthor = $gmentrylist->{$gmsortkeys[0]}{'author'};
	my $toploglistsubject = $gmentrylist->{$gmsortkeys[0]}{'subject'};
	my $toploglistdate = $gmentrylist->{$gmsortkeys[0]}{'created'};
	my $toploglisttimeampm = $gmentrylist->{$gmsortkeys[0]}{'createt'};
	my $toploglistopenstatus = $gmentrylist->{$gmsortkeys[0]}{'status'};
	my $toploglistmorestatus = $gmentrylist->{$gmsortkeys[0]}{'extended'};

	my ($toploglistmonthmonth, $toploglistdayday, $toploglistyear) = split (/\//, $toploglistdate);

	my $shortentrycounter = 0;
	my $moreentrycounter = 0;
	my $allentrycounter = 0;

	my $listdaymarker = "tommy";
	my $listmonthmarker = "tommy";
	my $listyearmarker = "tommy";

	foreach my $elkey (@gmsortkeys) {
		my $loglistnumber = $gmentrylist->{$elkey}{'id'};
		my $loglistauthor = $gmentrylist->{$elkey}{'author'};
		my $loglistsubject = $gmentrylist->{$elkey}{'subject'};
		my $loglistdate = $gmentrylist->{$elkey}{'created'};
		my $loglisttimeampm = $gmentrylist->{$elkey}{'createt'};
		my $loglistopenstatus = $gmentrylist->{$elkey}{'status'};
		my $loglistmorestatus = $gmentrylist->{$elkey}{'extended'};
	
		unless (($loglistopenstatus eq 'C') || ($thisentryloglistauthor ne $loglistauthor)) {
	
			#&gm_getloglistvariables;
			my $gmLogListVars = getArchiveVariables( listEntry=>$gmentrylist->{$elkey}, 
				errHandler=>$errHandler );
	
			my $usethismorelinktemplate = $TEMPLATES->{'gmmoreentrypagelinktemplate'};
			my $usethislinktemplate = $TEMPLATES->{'gmentrypagelinktemplate'};	
	
			if( ($TEMPLATES->{'gmentrypagelinkdayseparatortemplate'} ne Gm_Constants::EMPTY) && 
				($listdaymarker ne $gmLogListVars->{'loglistday'}) ){
				$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkdayseparatortemplate'}".
					"|*|$usethismorelinktemplate";
				$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkdayseparatortemplate'}".
					"|*|$usethislinktemplate";
			}
	
			if( ($TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'} ne Gm_Constants::EMPTY) && 
				($listmonthmarker ne $gmLogListVars->{'loglistmonth'}) ){
				$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'}".
					"|*|$usethismorelinktemplate";
				$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkmonthseparatortemplate'}".
					"|*|$usethislinktemplate";
			}
	
			if( ($TEMPLATES->{'gmentrypagelinkyearseparatortemplate'} ne Gm_Constants::EMPTY) && 
				($listyearmarker ne $gmLogListVars->{'loglistyear'}) ){
				$usethismorelinktemplate = "$TEMPLATES->{'gmentrypagelinkyearseparatortemplate'}".
					"|*|$usethismorelinktemplate";
				$usethislinktemplate = "$TEMPLATES->{'gmentrypagelinkyearseparatortemplate'}".
					"|*|$usethislinktemplate";
			}
			
			my $listsubsub = '';
			if ($loglistmorestatus eq 'Y') {
				$moreentrycounter++;
				my $listsubsub = translateArchiveTemplates( 
					template=>$usethismorelinktemplate,
					archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						
				$listsubsub .= "|*|";
				$logmoreentrylistfinal .= $listsubsub;
			} else {
				$shortentrycounter++;
				my $listsubsub = translateArchiveTemplates( 
					template=>$usethislinktemplate,
					archiveVars=>$gmLogListVars, errHandler=>$errHandler );
						
				$listsubsub .= "|*|";
				$logshortentrylistfinal .= $listsubsub;
			}
	
			$allentrycounter++;
			$logentrylistfinal .= $listsubsub;
	
			$listdaymarker = $gmLogListVars->{'loglistday'};
			$listmonthmarker = $gmLogListVars->{'loglistmonth'};
			$listyearmarker = $gmLogListVars->{'loglistyear'};
	
		}
	}

	my @logshortentrylistfinalcollection = split (/\|\*\|/, $logshortentrylistfinal);
	my @logmoreentrylistfinalcollection = split (/\|\*\|/, $logmoreentrylistfinal);
	my @logentrylistfinalcollection = split (/\|\*\|/, $logentrylistfinal);

	$logshortentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logshortentrylistfinalcollection);
	$logmoreentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logmoreentrylistfinalcollection);
	$logentrylistfinal = join( $TEMPLATES->{'gmentrypagelinkseparatortemplate'}, 
		@logentrylistfinalcollection);
		
	$entryLogAuthorVars{'logshortentrylistfinal'} = $logshortentrylistfinal;
	$entryLogAuthorVars{'logmoreentrylistfinal'} = $logmoreentrylistfinal;
	$entryLogAuthorVars{'logentrylistfinal'} = $logentrylistfinal;

	return( \%entryLogAuthorVars );
}


# ---------------
# Collate Comments
# ---------------
## Collates the Comments into one string, doing template tag replacement, censoring, etc.
# ARG entry => the entry with which to work on (should follow the 
#    entry object format, per Gm_Storage::getEntry)
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: string that has all this entries comments 'htmlized'
# DEPRECATES: gm_collatecomments
## TODO should be translateComments
sub collateComments {
	my (%params) = @_;
	
	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $theEntry = $params{'entry'} || 
		&$errHandler('Invalid entry parameter passed to collateComments');
	my $collatedText = '';  ## this will be returned later
	
	my @entryComments = @{$theEntry->{'comments'}};
	my $commentDisplayNumber = 1;
	
	## Reversing sort order
	if( $CONFIGS->{'gmcommentsorder'} eq Gm_Constants::ASCENDING ){
		@entryComments = reverse @entryComments;
		## TODO MAKE THIS WORK OFF OF COMMENT_ID, since we don't have that if ascending we start from bottom
		$commentDisplayNumber = scalar( @entryComments );
	}

	## Looping through each comment
	foreach my $currComment ( @entryComments ){

		## TODO: GO THROUGH AND REPLACE VARIABLE INSTANCE WITH HASH REFERENCE
		my $thiscommentauthor = $currComment->{'name'};
		my $thiscommentauthorip = $currComment->{'ip'};
		my $thiscommentauthoremailabsolute = $currComment->{'email'};
		my $thiscommentauthorhomepageabsolute = $currComment->{'homepage'};
		my $thiscommentweekdaynumber = $currComment->{'weekday'};
		my $thiscommentmonth = $currComment->{'month'};
		my $thiscommentday = $currComment->{'day'};
		my $thiscommentyearyear = $currComment->{'year'};
		my $thiscommenthour = $currComment->{'hour'};
		my $thiscommentminute = $currComment->{'minute'};
		my $thiscommentsecond = $currComment->{'second'};
		my $thiscommentampm = $currComment->{'ampm'};
		my $thiscommenttext = $currComment->{'comment'};

		my $thiscommentyear = substr($thiscommentyearyear, -2, 2);

		my $thiscommentmonthword = (Gm_Constants::MONTHS)[$thiscommentmonth-1];
		my $thiscommentmonthwordshort = (Gm_Constants::MONTHS_SHORT)[$thiscommentmonth-1];
		my $thiscommentweekday = (Gm_Constants::DAYS)[$thiscommentweekdaynumber];
		my $thiscommentweekdayshort = (Gm_Constants::DAYS_SHORT)[$thiscommentweekdaynumber];

		## This is for tag replacement, TODO: MAKE GENERIC SO RETURNS HAS WITH LC UC VALS?
		my $thiscommentweekdayupper = uc($thiscommentweekday);
		my $thiscommentmonthwordupper = uc($thiscommentmonthword);
		my $thiscommentweekdaylower = lc($thiscommentweekday);
		my $thiscommentmonthwordlower = lc($thiscommentmonthword);
		my $thiscommentweekdayuppershort = uc($thiscommentweekdayshort);
		my $thiscommentmonthworduppershort = uc($thiscommentmonthwordshort);
		my $thiscommentweekdaylowershort = lc($thiscommentweekdayshort);
		my $thiscommentmonthwordlowershort = lc($thiscommentmonthwordshort);

		## This is for tag replacement, TODO: MAKE GENERIC SO RETURNS HAS WITH LC UC VALS?
		my $thiscommentmonthmonth = Gm_Utils::toTwoDigit( $thiscommentmonth );
		my $thiscommentdayday = Gm_Utils::toTwoDigit( $thiscommentday );
		my $thiscommenthourhour = Gm_Utils::toTwoDigit( $thiscommenthour );
		my $thiscommentminuteminute = Gm_Utils::toTwoDigit( $thiscommentminute );
		my $thiscommentsecondsecond = Gm_Utils::toTwoDigit( $thiscommentsecond );

		## Defaults to AM
		my $thiscommentampmdot = 'A.M.';
		my $thiscommentmilitaryhour = $thiscommenthour;  ## TODO: FIX SO 12 AM is 00
		if ($thiscommentampm eq 'PM') {
			$thiscommentampmdot = 'P.M.';
			if ($thiscommenthour ne '12') { 
				$thiscommentmilitaryhour = $thiscommenthour + 12; 
			}
		}
		if (($thiscommenthour eq '12') && ($thiscommentampm eq 'AM')) {
			$thiscommentmilitaryhour = '00';
		}
		$thiscommentmilitaryhour = Gm_Utils::toTwoDigit( $thiscommentmilitaryhour );

		my $thiscommentampmlower = lc($thiscommentampm);
		my $thiscommentampmdotlower = lc($thiscommentampmdot);

		# new  ordinal numbers for {{dayappend}} variable
		my $thiscommentdayappend = Gm_Utils::toOrdinal($thiscommentday); 

		### should we just be making thise webSafe?  TODO, TRY WITH WEB SAFE
		$thiscommentauthor =~ s/"/\&quot;/g;
		$thiscommentauthoremailabsolute =~ s/"/\&quot;/g;
		$thiscommentauthorhomepageabsolute =~ s/"/\&quot;/g;
		
		# TODO: SHOULD LINKBOLDITAL AND LINKONLY BE CONSTANTS?
		# TODO: TAG REPLACEMENT SHOULD BE REMOVED TO CORE HELPER FUNCTION OR UTIL FUNCTION
		if (($CONFIGS->{'gmallowhtmlincomments'} eq 'linkboldital') || 
				($CONFIGS->{'gmallowhtmlincomments'} eq 'linkonly')) {
			if ($thiscommenttext =~ m/\*/i) { 
				$thiscommenttext =~ s/\*/\|AMP\|/g; 
			}
			if (($thiscommenttext =~ m/<a href/i) && ($thiscommenttext =~ m/<\/a>/i)) {
				$thiscommenttext =~ s/<a href/\*a href\*/isg;
				$thiscommenttext =~ s/<\/a>/\*a\*/isg;
			}
			if ($CONFIGS->{'gmallowhtmlincomments'} eq 'linkboldital') {
				if (($thiscommenttext =~ m/<b>/i) && ($thiscommenttext =~ m/<\/b>/i)) {
					$thiscommenttext =~ s/<b>/\*b\*/isg;
					$thiscommenttext =~ s/<\/b>/\*bb\*/isg;
				}
				if (($thiscommenttext =~ m/<i>/i) && ($thiscommenttext =~ m/<\/i>/i)) {
					$thiscommenttext =~ s/<i>/\*i\*/isg;
					$thiscommenttext =~ s/<\/i>/\*ii\*/isg;
				}
			}
		}

		unless ($CONFIGS->{'gmallowhtmlincomments'} eq Gm_Constants::YES) { 
			$thiscommenttext =~ s(<[^>]*>)()gs; 
		}

		## Auto linking magic, own function?
		if ($CONFIGS->{'gmautolinkurls'} eq Gm_Constants::YES) {
			$thiscommenttext =~ s#(^|\s)(\w+://)([A-Za-z0-9?=_\-/.%+&'~\#@!\^]+)#$1<a href="$2$3" rel="nofollow">$2$3</a>#isg;
			$thiscommenttext =~ s#(^|\s)(www.[A-Za-z0-9?=_\-/.%+&'~\#@!\^]+)#$1<a href="http://$2" rel="nofollow" target="_blank">$2</a>#isg;
			$thiscommenttext =~ s/(\w+\@\w+\.\w+)/<a href="mailto:$1">$1<\/a>/isg;
		}

		
		## If emoticons are allowed in both or comments and of course, the local per
		# comment setting overrides so it must be Yes
		if( (($CONFIGS->{'gmemoticonsallowed'} eq Gm_Constants::BOTH) 
 			|| ($CONFIGS->{'gmemoticonsallowed'} eq Gm_Constants::COMMENTS)) 
 		&& ($theEntry->{'entryinfo'}{'emoticons'} eq Gm_Constants::YES) ) {
			$thiscommenttext = translateEmoticons($thiscommenttext);
		}

		## changing text into links and bold or italic, if allowed
		if( ($CONFIGS->{'gmallowhtmlincomments'} eq 'linkboldital') || 
			($CONFIGS->{'gmallowhtmlincomments'} eq 'linkonly') ) {
			if (($thiscommenttext =~ m/\*a href\*/i) && ($thiscommenttext =~ m/\*a\*/i)) {
				$thiscommenttext =~ s/\*a href\*/<a href/isg;
				$thiscommenttext =~ s/\*a\*/<\/a>/isg;
			}
			
			# changed deprecated <b>, and <i> to corresponding css properties
			if ($CONFIGS->{'gmallowhtmlincomments'} eq 'linkboldital') {
				if (($thiscommenttext =~ m/\*b\*/i) && ($thiscommenttext =~ m/\*bb\*/i)) {
					$thiscommenttext =~ s/\*b\*/<span style="font-weight:bold;">/isg;
					$thiscommenttext =~ s/\*bb\*/<\/span>/isg;
				}
				if (($thiscommenttext =~ m/\*i\*/i) && ($thiscommenttext =~ m/\*ii\*/i)) {
					$thiscommenttext =~ s/\*i\*/<span style="font-style:italic;">/isg;
					$thiscommenttext =~ s/\*ii\*/<\/span>/isg;
				}
			}
			
			## We are reversing out ampersand to * translation, TODO: WHY? some sort of sanitizing?
			if ($thiscommenttext =~ m/\|AMP\|/i) { 
				$thiscommenttext =~ s/\|AMP\|/\*/g; 
			}
		}

		## this is doing bold, italic, and underline stranslations TODO: MAKE THIS A FUNCTION IN CORE
		if( ($CONFIGS->{'gminlineformatting'} eq Gm_Constants::COMMENTS) || 
			($CONFIGS->{'gminlineformatting'} eq Gm_Constants::BOTH) ) {
			$thiscommenttext = _inlineFormating( $thiscommenttext );
		}

		## Are new lines allowed in the comment?
		if ($CONFIGS->{'gmstriplinesfromcomments'} eq Gm_Constants::YES) {
			if (($thiscommenttext =~ /\|\*\|/) || ($thiscommenttext =~ /\n/)) {
				## Making internal newlines and 'real' newlines as spaces.
				$thiscommenttext =~ s/\|\*\|/ /g; 
				$thiscommenttext =~ s/\n/ /g;
			}
		} else {
			if (($thiscommenttext =~ /\|\*\|/) || ($thiscommenttext =~ /\n/)) {
				my $gmlinebreaktemplate = $TEMPLATES->{'gmlinebreaktemplate'};
				my $gmparaseparationtemplate = $TEMPLATES->{'gmparaseparationtemplate'};
				$thiscommenttext =~ s/\|\*\|\|\*\|/<PARABREAK>/g;
				$thiscommenttext =~ s/\n\n/<PARABREAK>/g;
				$thiscommenttext =~ s/\|\*\|/$gmlinebreaktemplate/g;
				$thiscommenttext =~ s/\n/$gmlinebreaktemplate/g;
				$thiscommenttext =~ s/<PARABREAK>/$gmparaseparationtemplate/g;
				$thiscommenttext =~ s/a href/a rel="nofollow" href/g;
				$thiscommenttext =~ s/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w{1,8});)/&amp;/g;
			}
		}

		## TODO: CAN THIS BE GENERIZIED INTO A UTIL OR WEB FUNCTION
		if (($CONFIGS->{'gmcensorenabled'} eq Gm_Constants::BOTH) || 
			($CONFIGS->{'gmcensorenabled'} eq Gm_Constants::COMMENTS)) {
			unless ($CONFIGS->{'gmcensorlist'} eq Gm_Constants::EMPTY) {
				my @censoredterms = split(/\n/, $CONFIGS->{'gmcensorlist'});
				
				## Looping through
				foreach my $thisterm (@censoredterms) {
					unless ($thisterm eq Gm_Constants::EMPTY) {
						if ((substr($thisterm, 0, 1) eq '[') && (substr($thisterm, -1, 1) eq ']')) {
							my $thisrealterm = $thisterm;
							$thisrealterm =~ s/\[//g;
							$thisrealterm =~ s/\]//g;
							my $thisrealtermlength = length($thisrealterm);
							my $thisrealtermreplace = "*" x $thisrealtermlength;
							my $thisrealtermreplacedash = "-" x $thisrealtermlength;
							## Censoring comment
							if ($thiscommenttext =~ m/$thisrealterm/i) {
								$thiscommenttext =~ s/\b$thisrealterm\b/$thisrealtermreplace/isg;
							}
							if ($thiscommentauthor =~ m/$thisrealterm/i) {
								$thiscommentauthor =~ s/\b$thisrealterm\b/$thisrealtermreplacedash/isg;
							}
						} else {
							my $thisrealtermlength = length($thisterm);
							my $thisrealtermreplace = "*" x $thisrealtermlength;
							my $thisrealtermreplacedash = "-" x $thisrealtermlength;
							if ($thiscommenttext =~ m/$thisterm/i) {
								$thiscommenttext =~ s/\b$thisterm\b/$thisrealtermreplace/isg;
							}
							if ($thiscommentauthor =~ m/$thisterm/i) {
								$thiscommentauthor =~ s/\b$thisterm\b/$thisrealtermreplacedash/isg;
							}
						}
					}
				}
			}
		}
		
		### NOTE: this must be done after censoring or smartlink won't pick up censoring
		my $thiscommentauthoremail = Gm_Constants::EMPTY;
		my $thiscommentauthorhomepage = Gm_Constants::EMPTY;

		my $thiscommentauthorsmartlink = $thiscommentauthor;
	## TODO: MAKE A GETSMARTAUTHORLINKS FOR HOMEPAGE AND EMAIL SINCE THIS IS DUPPED +3 TIMES		
		if ($thiscommentauthoremailabsolute ne Gm_Constants::EMPTY) {
			$thiscommentauthoremail = $TEMPLATES->{'gmcommentauthoremailtemplate'};
			$thiscommentauthorsmartlink = "<a href=\"mailto:$thiscommentauthoremailabsolute\">$thiscommentauthor</a>";
		}
		if ($thiscommentauthorhomepageabsolute ne Gm_Constants::EMPTY) {
			$thiscommentauthorhomepage = $TEMPLATES->{'gmcommentauthorhomepagetemplate'};
			my $gmcommentlinktargettemplate = $TEMPLATES->{'gmcommentlinktargettemplate'};
			$thiscommentauthorsmartlink = "<a href=\"$thiscommentauthorhomepageabsolute\" $gmcommentlinktargettemplate>$thiscommentauthor</a>";
		}
		

		my $thiscommentfullbody = $TEMPLATES->{'gmcommentstemplate'};
		
		## Time to do some template replacing TODO: RESEARCH IF THIS CAN BE GENERIZIED AND USEFULL TO OTHERS?
		# MAYBE NOT SINCE THESE VALUES WERE ALL JUST SETUP BASED ON THE COMMENT, BUT MAYBE ONLY A FEW PARAMS
		# PASSED TO A GENERIC FUNCTION COULD BE USED??
		if ($thiscommentfullbody =~ m/{{comment/i) {
			$thiscommentfullbody =~ s/{{commentbody}}/$thiscommenttext/gi;
			$thiscommentfullbody =~ s/{{commentauthoremail}}/$thiscommentauthoremail/gi;
			$thiscommentfullbody =~ s/{{commentauthorhomepage}}/$thiscommentauthorhomepage/gi;
			$thiscommentfullbody =~ s/{{commentauthor}}/$thiscommentauthor/gi;
			$thiscommentfullbody =~ s/{{commentauthoremailabsolute}}/$thiscommentauthoremailabsolute/gi;
			$thiscommentfullbody =~ s/{{commentauthorhomepageabsolute}}/$thiscommentauthorhomepageabsolute/gi;
			$thiscommentfullbody =~ s/{{commentauthorsmartlink}}/$thiscommentauthorsmartlink/gi;
			$thiscommentfullbody =~ s/{{commentauthorip}}/$thiscommentauthorip/gi;

			## TODO make this come from comment_id
			$thiscommentfullbody =~ s/{{commentordernumber}}/$commentDisplayNumber/gi; 
		}
		
		## Time template translation
		$thiscommentfullbody =~ s/{{day}}/$thiscommentday/gi;
		$thiscommentfullbody =~ s/{{month}}/$thiscommentmonth/gi;
		$thiscommentfullbody =~ s/{{year}}/$thiscommentyear/gi;
		$thiscommentfullbody =~ s/{{hour}}/$thiscommenthour/gi;
		$thiscommentfullbody =~ s/{{minute}}/$thiscommentminute/gi;
		$thiscommentfullbody =~ s/{{second}}/$thiscommentsecond/gi;
		$thiscommentfullbody =~ s/{{dayday}}/$thiscommentdayday/gi;
		$thiscommentfullbody =~ s/{{monthmonth}}/$thiscommentmonthmonth/gi;
		$thiscommentfullbody =~ s/{{yearyear}}/$thiscommentyearyear/gi;
		$thiscommentfullbody =~ s/{{hourhour}}/$thiscommenthourhour/gi;
		$thiscommentfullbody =~ s/{{minuteminute}}/$thiscommentminuteminute/gi;
		$thiscommentfullbody =~ s/{{secondsecond}}/$thiscommentsecondsecond/gi;
		$thiscommentfullbody =~ s/{{weekday}}/$thiscommentweekday/gi;
		$thiscommentfullbody =~ s/{{weekdayshort}}/$thiscommentweekdayshort/gi;
		$thiscommentfullbody =~ s/{{monthword}}/$thiscommentmonthword/gi;
		$thiscommentfullbody =~ s/{{monthwordshort}}/$thiscommentmonthwordshort/gi;
		$thiscommentfullbody =~ s/{{weekdayupper}}/$thiscommentweekdayupper/gi;
		$thiscommentfullbody =~ s/{{monthwordupper}}/$thiscommentmonthwordupper/gi;
		$thiscommentfullbody =~ s/{{weekdaylower}}/$thiscommentweekdaylower/gi;
		$thiscommentfullbody =~ s/{{monthwordlower}}/$thiscommentmonthwordlower/gi;
		$thiscommentfullbody =~ s/{{weekdayuppershort}}/$thiscommentweekdayuppershort/gi;
		$thiscommentfullbody =~ s/{{monthworduppershort}}/$thiscommentmonthworduppershort/gi;
		$thiscommentfullbody =~ s/{{weekdaylowershort}}/$thiscommentweekdaylowershort/gi;
		$thiscommentfullbody =~ s/{{monthwordlowershort}}/$thiscommentmonthwordlowershort/gi;
		$thiscommentfullbody =~ s/{{militaryhour}}/$thiscommentmilitaryhour/gi;
		$thiscommentfullbody =~ s/{{ampm}}/$thiscommentampm/gi;
		$thiscommentfullbody =~ s/{{ampmdot}}/$thiscommentampmdot/gi;
		$thiscommentfullbody =~ s/{{ampmlower}}/$thiscommentampmlower/gi;
		$thiscommentfullbody =~ s/{{ampmdotlower}}/$thiscommentampmdotlower/gi;
		$thiscommentfullbody =~ s/{{dayappend}}/$thiscommentdayappend/gi;

		$collatedText .= $thiscommentfullbody;

		## Setting the variable to tell us if its the first comment or the Nth comment
		if( $CONFIGS->{'gmcommentsorder'} eq Gm_Constants::ASCENDING ){ 
			$commentDisplayNumber--; 
		} else { 
			$commentDisplayNumber++; 
		}
	} ## End of foreach comment loop

	return( $collatedText );
}


# ------------------
# emoticons subroutine
# ------------------
## Translates the emoticon shorthand (e.g. ':)', ':(' ) to image tags 
# ARG1 = the string to replace the emoticons within
# RETURN: the string with the smiley shorthand translated to html image tags
# DEPRECATES: gm_emoticons
sub translateEmoticons {
	my $line = shift();
	
	my $emoticonspath = $CONFIGS->{'gmemoticonspath'};
	
	$line =~ s/\:\)/<img src=\"$emoticonspath\/smile.gif\" alt=\"smile\" \/>/g;
	$line =~ s/\:O/<img src=\"$emoticonspath\/shocked.gif\" alt=\"shocked\" \/>/g;
	$line =~ s/\:\(/<img src=\"$emoticonspath\/sad.gif\" alt=\"sad\" \/>/g;
	$line =~ s/\:D/<img src=\"$emoticonspath\/biggrin.gif\" alt=\"big grin\" \/>/g;
	$line =~ s/\:P/<img src=\"$emoticonspath\/tongue.gif\" alt=\"razz\" \/>/g;
	$line =~ s/\;\)/<img src=\"$emoticonspath\/wink.gif\" alt=\"wink\" \/>/g;
	$line =~ s/\:angry:/<img src=\"$emoticonspath\/angry.gif\" alt=\"angry, grr\" \/>/g;
	$line =~ s/\:blush:/<img src=\"$emoticonspath\/blush.gif\" alt=\"blush\" \/>/g;
	$line =~ s/\:confused:/<img src=\"$emoticonspath\/confused.gif\" alt=\"confused\" \/>/g;
	$line =~ s/\:cool:/<img src=\"$emoticonspath\/cool.gif\" alt=\"cool eh?\" \/>/g;
	$line =~ s/\:crazy:/<img src=\"$emoticonspath\/crazy.gif\" alt=\"crazy\" \/>/g;
	$line =~ s/\:cry:/<img src=\"$emoticonspath\/cry.gif\" alt=\"crying\" \/>/g;
	$line =~ s/\:doze:/<img src=\"$emoticonspath\/doze.gif\" alt=\"sleepy\" \/>/g;
	$line =~ s/\:hehe:/<img src=\"$emoticonspath\/hehe.gif\" alt=\"hehe\" \/>/g;
	$line =~ s/\:laugh:/<img src=\"$emoticonspath\/laugh.gif\" alt=\"laugh out loud\" \/>/g;
	$line =~ s/\:plain:/<img src=\"$emoticonspath\/plain.gif\" alt=\"plain\" \/>/g;
	$line =~ s/\:rolleyes:/<img src=\"$emoticonspath\/rolleyes.gif\" alt=\"rolls eyes\" \/>/g;
	$line =~ s/\:satisfied:/<img src=\"$emoticonspath\/satisfied.gif\" alt=\"satisfied\" \/>/g;
	
	return( $line );
}


# ----------------------------------
# generate external author variables
# ----------------------------------
## Translates the author variable tokens to actual values 
# ARG line => the string on which to do the token replacement
# ARG entryVars => the output of getEntryVariables
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: the string with the translated tokens
# DEPRECATES: gm_generateexternalauthorvariables
sub translateExternalAuthorVariables {
	my (%params) = @_;
	
	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $entryreturn = $params{'line'} || '';
	my $entryVars = $params{'entryVars'} || 
		&$errHandler('Invalid entryVars parameter passed to translateExternalAuthorVariables');

	my $gmauthors = Gm_Storage::getAuthors( errHandler=>$errHandler );
	
	foreach my $author ( keys( %$gmauthors ) ){
		my $thisexternalauthor = $gmauthors->{$author}{'author'};
		my $thisexternalauthoremail = $gmauthors->{$author}{'email'};
		my $thisexternalauthorhomepage = $gmauthors->{$author}{'homepage'};
		my $thisexternalauthorentrycount = $gmauthors->{$author}{'posttotal'};;
	
		my $thisexternalauthorsmartlink = $thisexternalauthor;
	## TODO: MAKE A GETSMARTAUTHORLINKS FOR HOMEPAGE AND EMAIL SINCE THIS IS DUPPED +3 TIMES
		if( $thisexternalauthoremail ne Gm_Constants::EMPTY ){ 
			$thisexternalauthorsmartlink = "<A HREF=\"mailto:$entryVars->{'thisentryauthoremail'}\">$entryVars->{'thisentryauthor'}</A>"; 
		}
		if( $thisexternalauthorhomepage ne Gm_Constants::EMPTY ){ 
			$thisexternalauthorsmartlink = "<A HREF=\"$entryVars->{'thisentryauthorhomepage'}\">$entryVars->{'thisentryauthor'}</A>"; 
		}
	
		$entryreturn =~ s/{{authoremail $thisexternalauthor}}/$thisexternalauthoremail/isg;
		$entryreturn =~ s/{{authorhomepage $thisexternalauthor}}/$thisexternalauthorhomepage/isg;
		$entryreturn =~ s/{{authorsmartlink $thisexternalauthor}}/$thisexternalauthorsmartlink/isg;
		$entryreturn =~ s/{{authorentrycount $thisexternalauthor}}/$thisexternalauthorentrycount/isg;
	}
	
	return( $entryreturn );
}


## Construct Main Index
# Builds or Rebuilds the main index file, including translating variables, accessing file system, etc.
# (opt) ARG errHandler => the error handler used to display errors
# DEPRECATES: gm_generatemainindex
sub constructMainIndex {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
#&gm_readconfig;
#&gm_readcounter;
#&gm_readtemplates;
	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );

	my $indexlogbody = Gm_Constants::EMPTY;
	my $indexentrycounter = $gmCounters->{'entrytotal'};
	my $indexcurrentdatemarker = 'erewhon';
	my $indexcurrentdatescounted = 0;
	my $dategrouping = Gm_Constants::EMPTY;

	my $entryVars = ();

#	if ($newstayattopnumber ne "0") {
	if ( $gmCounters->{'stayattopentry'} ne '0' ){

		$entryVars = Gm_Core::getEntryVariables( entryid=>$gmCounters->{'stayattopentry'}, 
			errHandler=>\&Gm_Web::displayAdminErrorExit );
		if ($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) {

			my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
				template=>$TEMPLATES->{'gmstayattoptemplate'}, errHandler=>$errHandler );
				
			$indexlogbody .= $entryreturn;
		}
	}


	do {
		
		$entryVars = Gm_Core::getEntryVariables( entryid=>$indexentrycounter, 
			errHandler=>$errHandler );
		
		my $datemark = "$entryVars->{'thisentrymonth'} $entryVars->{'thisentryday'} $entryVars->{'thisentryyearyear'}";
		
		# if (($datemark ne $indexcurrentdatemarker) && ($thisentryopenstatus eq Gm_Constants::OPEN) && ($indexentrycounter ne $newstayattopnumber)) {
		if( ($datemark ne $indexcurrentdatemarker) && 
			($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
			($indexentrycounter ne $gmCounters->{'stayattopentry'}) ){
			
			$indexcurrentdatescounted++;
			
			if( $TEMPLATES->{'gmdatetemplate'} ne Gm_Constants::EMPTY ){
				my $currentdatehead = $TEMPLATES->{'gmdatetemplate'};
				$currentdatehead =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
				$currentdatehead =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
				$currentdatehead =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
				$currentdatehead =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
				$currentdatehead =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
				$currentdatehead =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
				$currentdatehead =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
				$currentdatehead =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;		
				$currentdatehead =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
				$currentdatehead =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;		
				$currentdatehead =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
				$currentdatehead =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
				$currentdatehead =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
				$currentdatehead =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
				$currentdatehead =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
				$currentdatehead =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
				$currentdatehead =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
				$currentdatehead =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
		
				my $thisentrydayappend = Gm_Utils::toOrdinal($entryVars->{'thisentryday'});
				$currentdatehead =~ s/{{dayappend}}/$thisentrydayappend/gi;
		
				unless( $indexcurrentdatescounted > $CONFIGS->{'gmindexdays'} ){ 
					 $indexlogbody .= $currentdatehead;
					 $dategrouping = Gm_Constants::OPEN;
				}
			}
			
			$indexcurrentdatemarker = "$entryVars->{'thisentrymonth'} $entryVars->{'thisentryday'} $entryVars->{'thisentryyearyear'}";
		
		} else {

			if( ($indexentrycounter ne $gmCounters->{'stayattopentry'}) && 
				($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
				($indexcurrentdatescounted <= $CONFIGS->{'gmindexdays'}) && 
				($TEMPLATES->{'gmentryseparatortemplate'} ne Gm_Constants::EMPTY) ){
				
				$indexlogbody .= $TEMPLATES->{'gmentryseparatortemplate'};
			}
		}
		
		if (($indexentrycounter ne $gmCounters->{'stayattopentry'}) && 
			($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
			($indexcurrentdatescounted <= $CONFIGS->{'gmindexdays'})) {

			my $entryreturn = '';
			if ($entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY) {
				$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
					template=>$TEMPLATES->{'gmmoreentrytemplate'}, errHandler=>$errHandler );
			} else {
				$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
					template=>$TEMPLATES->{'gmentrytemplate'}, errHandler=>$errHandler );
			}
			
			$indexlogbody .= $entryreturn;
		}
		
		if ($indexentrycounter > 1) {
		#     &gm_getentryvariables($indexentrycounter - 1); # look at the last open entry
			$entryVars = Gm_Core::getEntryVariables( entryid=>($indexentrycounter - 1), 
				errHandler=>$errHandler );
			my $nextdatemark = "$entryVars->{'thisentrymonth'} $entryVars->{'thisentryday'} $entryVars->{'thisentryyearyear'}";
			my $nextentryopenstatus = $entryVars->{'thisentryopenstatus'};
		#     &gm_getentryvariables($indexentrycounter); # look at the current entry again
			$entryVars = Gm_Core::getEntryVariables( entryid=>$indexentrycounter, 
				errHandler=>$errHandler );
		
			if( ($nextdatemark ne $indexcurrentdatemarker) && ($dategrouping eq Gm_Constants::OPEN) && 
				($nextentryopenstatus eq Gm_Constants::OPEN) && ($indexentrycounter ne $gmCounters->{'stayattopentry'}) ){   
				
				if ($TEMPLATES->{'gmdategroupingfootertemplate'} ne Gm_Constants::EMPTY) {
					my $currentdatefoot = $TEMPLATES->{'gmdategroupingfootertemplate'};
					$currentdatefoot =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
					$currentdatefoot =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
					$currentdatefoot =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
					$currentdatefoot =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
					$currentdatefoot =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
					$currentdatefoot =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
					$currentdatefoot =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
					$currentdatefoot =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;		
					$currentdatefoot =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
					$currentdatefoot =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;		
					$currentdatefoot =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
					$currentdatefoot =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
					$currentdatefoot =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
					$currentdatefoot =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
					$currentdatefoot =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
					$currentdatefoot =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
					$currentdatefoot =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
					$currentdatefoot =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
		
					my $thisentrydayappend = Gm_Utils::toOrdinal( $entryVars->{'thisentryday'} );
					$currentdatefoot =~ s/{{dayappend}}/$thisentrydayappend/gi;
		
					unless( $indexcurrentdatescounted > $CONFIGS->{'gmindexdays'} ){ 
						$indexlogbody .= $currentdatefoot;
						$dategrouping = Gm_Constants::CLOSED;
					}
				}
			}
		} 
		
		$indexentrycounter--;
		
		if( $indexentrycounter eq '0' ){
			if( $indexcurrentdatescounted > $CONFIGS->{'gmindexdays'} ){ 
				$indexentrycounter++; 
			}
			
			$indexcurrentdatescounted = $CONFIGS->{'gmindexdays'} + 1;
		}
		
		if( ($gmCounters->{'stayattopentry'} eq '1') && ($gmCounters->{'entrytotal'} eq '1') ){ 
			$indexcurrentdatescounted = $CONFIGS->{'gmindexdays'} + 1; 
		}
		
		if( $indexcurrentdatescounted > $CONFIGS->{'gmindexdays'} ){
			if( $indexentrycounter < 0 ){ 
				$indexentrycounter = 0; 
			}
			
			unless( $indexentrycounter eq '0' ){ 
				$indexentrycounter = $entryVars->{'thisentrynumber'}; 
			}
		}
		
	} until $indexcurrentdatescounted > $CONFIGS->{'gmindexdays'};

	if( ($TEMPLATES->{'gmdategroupingfootertemplate'} ne Gm_Constants::EMPTY) && ($dategrouping eq Gm_Constants::OPEN) ){
		my $currentdatefoot = $TEMPLATES->{'gmdategroupingfootertemplate'};
		$currentdatefoot =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
		$currentdatefoot =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
		$currentdatefoot =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
		$currentdatefoot =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
		$currentdatefoot =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
		$currentdatefoot =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
		$currentdatefoot =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
		$currentdatefoot =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;		
		$currentdatefoot =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
		$currentdatefoot =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;		
		$currentdatefoot =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
		$currentdatefoot =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
		$currentdatefoot =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
		$currentdatefoot =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
		$currentdatefoot =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
		$currentdatefoot =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
		$currentdatefoot =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
		$currentdatefoot =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
		
		my $thisentrydayappend = Gm_Utils::toOrdinal($entryVars->{'thisentryday'});
		$currentdatefoot =~ s/{{dayappend}}/$thisentrydayappend/gi;
		$indexlogbody .= $currentdatefoot;
		$dategrouping = Gm_Constants::CLOSED;
	}

	my $newindexfile = $TEMPLATES->{'gmindextemplate'};
	$newindexfile =~ s/{{logbody}}/$indexlogbody/gi;

	$entryVars = Gm_Core::getEntryVariables( entryid=>$gmCounters->{'entrytotal'}, 
		errHandler=>$errHandler );

	my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
		template=>$newindexfile, errHandler=>$errHandler );

	Gm_Storage::saveFile( loc=>"$CONFIGS->{'gmlogpath'}/$CONFIGS->{'gmindexfilename'}", content=>[$entryreturn],
		'new'=>1, ch_mod=>'0666', errHandler=>$errHandler );

#	$newarchivenumber = $indexentrycounter;  ## FIXING!! should this be in Diag & Repair
	$gmCounters->{'archivetotal'} = $indexentrycounter;
	
#	&gm_writecounter;  ## TODO: this is fixing some of the counters, as a side affect, should directly call
	## fixCounters or something so that we can fix all the counters
	Gm_Storage::setCounters( list=>$gmCounters, errHandler=>$errHandler );
}


## Construct Archive Index
# Builds or Rebuilds the archive index file, including translating variables, accessing file system, etc.
# (opt) ARG errHandler => the error handler used to display errors
# DEPRECATES: gm_rebuildarchivemasterindex
sub constructArchiveIndex {
	my (%params) = @_;
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	
	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );

	my $entryVars = ();
	if( $CONFIGS->{'gmkeeparchivemasterindex'} eq Gm_Constants::YES && hasPosted() ){
		if( $gmCounters->{'archivetotal'} ne '0') {			
			$entryVars = Gm_Core::getEntryVariables( entryid=>$gmCounters->{'archivetotal'}, 
				errHandler=>$errHandler );
		} else {
			$entryVars = Gm_Core::getEntryVariables( entryid=>$gmCounters->{'entrytotal'}, 
				errHandler=>$errHandler );
		}
	
		my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$TEMPLATES->{'gmarchivemasterindextemplate'}, errHandler=>$errHandler );
	
		Gm_Storage::saveFile( loc=>"$CONFIGS->{'gmentriespath'}/$CONFIGS->{'gmindexfilename'}", content=>[$entryreturn],
			'new'=>1, ch_mod=>'0666', errHandler=>$errHandler );
	}
}


## Construct Archives
# Builds or Rebuilds the archive log files, including translating variables, accessing file system, etc.
# Note that it starts from high entry number to low
# (opt) ARG startnum => the starting file number to rebuild with, default to latest entry
# (opt) ARG buildnum => the number of log files to build, default to all
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: the current index of the connected files list to resume building on
# DEPRECATES: gm_generatearchive
sub constructArchives {
	my (%params) = @_;
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;

	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );
	
	my $getstartnumber = $params{'startnum'} || $gmCounters->{'entrytotal'};
	my $startnumber = $getstartnumber; ## combine
	my $rebuildNum = $params{'buildnum'} || $gmCounters->{'entrytotal'};
	my $savedNum = 1; # number of files saved
	my $stoppednumber = Gm_Constants::EMPTY;
	my $gmneedstogeneratefirstarchive = 0;	

	# Main loop, looking to do the number of rebuilds or the number of saved files
	while( $startnumber > 0 && $savedNum <= $rebuildNum  ){
	
		my $indexarchivebody = Gm_Constants::EMPTY;
		my $indexentrycounter = $startnumber;
		my $indexcurrentdatemarker = 'erewhon';
		my $indexcurrentdatescounted = 0;	
	
		my $entryVars = Gm_Core::getEntryVariables( entryid=>$startnumber, errHandler=>$errHandler );
		
		my $indexcurrentmonthcounter = $entryVars->{'thisentrymonth'};
		my $indexcurrentweekcounter = "$entryVars->{'thisentryweekbeginningdayday'}$entryVars->{'thisentryweekendingdayday'}";
		my $dategrouping = Gm_Constants::EMPTY;
		my $entryreturn = Gm_Constants::EMPTY;
	
		$entryVars = (); ## why are they blanking them?
	
		do {
			
			$entryVars = Gm_Core::getEntryVariables( entryid=>$indexentrycounter, 
				errHandler=>$errHandler );
		
			my $thisentryweek = "$entryVars->{'thisentryweekbeginningdayday'}$entryVars->{'thisentryweekendingdayday'}";
		
			## If we are generating entry pages and the Start number is the same as the new Archive number
			## rebuilding because it could now be an archive
			if( $CONFIGS->{'gmgenerateentrypages'} eq Gm_Constants::YES && $indexentrycounter eq $gmCounters->{'archivetotal'} ){
				if( $entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN ){
	
					$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
						template=>$TEMPLATES->{'gmarchiveentrypagetemplate'}, errHandler=>$errHandler );
					Gm_Storage::saveFile( loc=>"$CONFIGS->{'gmentriespath'}/$entryVars->{'thisentrynumberpadded'}.$CONFIGS->{'gmentrysuffix'}", 
						content=>[$entryreturn], 'new'=>1, errHandler=>$errHandler );
				} else {
					unlink ("$CONFIGS->{'gmentriespath'}/$entryVars->{'thisentrynumberpadded'}.$CONFIGS->{'gmentrysuffix'}");
				}
			}
		
			my $datemark = "$entryVars->{'thisentrymonth'} $entryVars->{'thisentryday'} $entryVars->{'thisentryyearyear'}";
			
			if( $datemark ne $indexcurrentdatemarker && 
				$entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN ){
				$indexcurrentdatescounted++;
				if( $TEMPLATES->{'gmdatearchivetemplate'} ne Gm_Constants::EMPTY ){
					my $currentdatehead = $TEMPLATES->{'gmdatearchivetemplate'};
					$currentdatehead =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
					$currentdatehead =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
					$currentdatehead =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
					$currentdatehead =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
					$currentdatehead =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
					$currentdatehead =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
					$currentdatehead =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
					$currentdatehead =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;		
					$currentdatehead =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
					$currentdatehead =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;		
					$currentdatehead =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
					$currentdatehead =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
					$currentdatehead =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
					$currentdatehead =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
					$currentdatehead =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
					$currentdatehead =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
					$currentdatehead =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
					$currentdatehead =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
			
					my $thisentrydayappend = Gm_Utils::toOrdinal($entryVars->{'thisentryday'});
					$currentdatehead =~ s/{{dayappend}}/$thisentrydayappend/gi;
					
					if ($CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK) {
						unless ($entryVars->{'thisentryweek'} ne $indexcurrentweekcounter) {
							 $indexarchivebody .= $currentdatehead;
							 $dategrouping = Gm_Constants::OPEN;
						}
					} else {
						unless ($entryVars->{'thisentrymonth'} ne $indexcurrentmonthcounter) {
							 $indexarchivebody .= $currentdatehead;
							 $dategrouping = Gm_Constants::OPEN;
						}
					}
				}
				$indexcurrentdatemarker = "$entryVars->{'thisentrymonth'} $entryVars->{'thisentryday'} $entryVars->{'thisentryyearyear'}";
			} else {
				if ($CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK) {
					if (($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
						($entryVars->{'thisentryweek'} eq $indexcurrentweekcounter) && 
						($TEMPLATES->{'gmarchiveentryseparatortemplate'} ne Gm_Constants::EMPTY)) {
						$indexarchivebody .= $TEMPLATES->{'gmarchiveentryseparatortemplate'};
					}
				} else {
					if (($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
						($entryVars->{'thisentrymonth'} eq $indexcurrentmonthcounter) && 
						($TEMPLATES->{'gmarchiveentryseparatortemplate'} ne Gm_Constants::EMPTY)) {
						$indexarchivebody .= $TEMPLATES->{'gmarchiveentryseparatortemplate'};
					}
				}
			}
			
			if( $CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK ){
				if (($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
					($entryVars->{'thisentryweek'} eq $indexcurrentweekcounter)) {
					if ($entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY) {
		
						$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
							template=>$TEMPLATES->{'gmmorearchiveentrytemplate'}, errHandler=>$errHandler );
					} else {
		
						$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
							template=>$TEMPLATES->{'gmarchiveentrytemplate'}, errHandler=>$errHandler );
					}
					$indexarchivebody .= $entryreturn;
				}
			} else {
				if (($entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN) && 
					($entryVars->{'thisentrymonth'} eq $indexcurrentmonthcounter)) {
					if ($entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY) {
		
						$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
							template=>$TEMPLATES->{'gmmorearchiveentrytemplate'}, errHandler=>$errHandler );
					} else {
		
						$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
							template=>$TEMPLATES->{'gmarchiveentrytemplate'}, errHandler=>$errHandler );
					}
					$indexarchivebody .= $entryreturn;
				}
			}
			
			if( $indexentrycounter > 1 ){
		
					## We could use a different entry vars
					$entryVars = Gm_Core::getEntryVariables( entryid=>($indexentrycounter - 1), 
						errHandler=>$errHandler );
					my $nextdatemark = "$entryVars->{'thisentrymonth'} $entryVars->{'thisentryday'} $entryVars->{'thisentryyearyear'}";
					my $nextentryopenstatus = $entryVars->{'thisentryopenstatus'}; ## This isn't used in this subroutine
		
					$entryVars = Gm_Core::getEntryVariables( entryid=>$indexentrycounter, 
						errHandler=>$errHandler );
					if( $nextdatemark ne $indexcurrentdatemarker && $dategrouping eq Gm_Constants::OPEN && 
						$entryVars->{'thisentryopenstatus'} eq Gm_Constants::OPEN ){
							if( $TEMPLATES->{'gmdategroupingfooterarchivetemplate'} ne Gm_Constants::EMPTY ){
								my $currentdatefoot = $TEMPLATES->{'gmdategroupingfooterarchivetemplate'};
								$currentdatefoot =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
								$currentdatefoot =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
								$currentdatefoot =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
								$currentdatefoot =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
								$currentdatefoot =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
								$currentdatefoot =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
								$currentdatefoot =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
								$currentdatefoot =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;		
								$currentdatefoot =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
								$currentdatefoot =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;		
								$currentdatefoot =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
								$currentdatefoot =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
								$currentdatefoot =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
								$currentdatefoot =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
								$currentdatefoot =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
								$currentdatefoot =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
								$currentdatefoot =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
								$currentdatefoot =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
			
								my $thisentrydayappend = Gm_Utils::toOrdinal($entryVars->{'thisentryday'});
								$currentdatefoot =~ s/{{dayappend}}/$thisentrydayappend/gi;
								$indexarchivebody .= $currentdatefoot;
								$dategrouping = Gm_Constants::CLOSED;
							}
					}
			}
			 
			$indexentrycounter--;
		
			# This should probably be greater than 0
			if( $indexentrycounter eq '0' && $indexcurrentmonthcounter ne $entryVars->{'thisentrymonth'} ){ 
				$gmneedstogeneratefirstarchive=1; 
			}
			# This should probably be greater than 0
			if( $indexentrycounter eq '0' && $CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK && 
				$entryVars->{'thisentryweek'} ne $indexcurrentweekcounter ){ 
				$gmneedstogeneratefirstarchive=1;
			}
			if( $CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK ){
				if( $entryVars->{'thisentryweek'} ne $indexcurrentweekcounter ){
					## should be using Constant
					$indexcurrentmonthcounter = 'finis';
				} else {
					$indexcurrentmonthcounter = $entryVars->{'thisentrymonth'};
				}
			}
			
			if( $indexentrycounter eq '0' ){ 
				$indexcurrentmonthcounter = 'finis'; 
			}
		} until $entryVars->{'thisentrymonth'} ne $indexcurrentmonthcounter;
	
		if( $TEMPLATES->{'gmdategroupingfooterarchivetemplate'} ne Gm_Constants::EMPTY && $dategrouping eq Gm_Constants::OPEN ){
			my $currentdatefoot = $TEMPLATES->{'gmdategroupingfooterarchivetemplate'};
			$currentdatefoot =~ s/{{day}}/$entryVars->{'thisentryday'}/gi;
			$currentdatefoot =~ s/{{dayday}}/$entryVars->{'thisentrydayday'}/gi;
			$currentdatefoot =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
			$currentdatefoot =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
			$currentdatefoot =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
			$currentdatefoot =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
			$currentdatefoot =~ s/{{weekday}}/$entryVars->{'thisentryweekday'}/gi;
			$currentdatefoot =~ s/{{weekdayshort}}/$entryVars->{'thisentryweekdayshort'}/gi;		
			$currentdatefoot =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
			$currentdatefoot =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;		
			$currentdatefoot =~ s/{{weekdayupper}}/$entryVars->{'thisentryweekdayupper'}/gi;
			$currentdatefoot =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
			$currentdatefoot =~ s/{{weekdaylower}}/$entryVars->{'thisentryweekdaylower'}/gi;
			$currentdatefoot =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
			$currentdatefoot =~ s/{{weekdayuppershort}}/$entryVars->{'thisentryweekdayuppershort'}/gi;
			$currentdatefoot =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
			$currentdatefoot =~ s/{{weekdaylowershort}}/$entryVars->{'thisentryweekdaylowershort'}/gi;
			$currentdatefoot =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
		
			my $thisentrydayappend = Gm_Utils::toOrdinal($entryVars->{'thisentryday'});
			$currentdatefoot =~ s/{{dayappend}}/$thisentrydayappend/gi;
			$indexarchivebody .= $currentdatefoot;
			$dategrouping = Gm_Constants::CLOSED;
		}
	
		$stoppednumber = $entryVars->{'thisentrynumber'};
		$entryVars = Gm_Core::getEntryVariables( entryid=>$startnumber, errHandler=>$errHandler );
				
		my $usethisarchivefilename = Gm_Constants::EMPTY;
		if( $CONFIGS->{'gmarchiveformat'} eq Gm_Constants::WEEK ){
			$usethisarchivefilename = "$CONFIGS->{'gmentriespath'}/archive-$entryVars->{'thisentryweekbeginningmonthmonth'}".
				"$entryVars->{'thisentryweekbeginningdayday'}$entryVars->{'thisentryweekbeginningyearyear'}-".
				"$entryVars->{'thisentryweekendingmonthmonth'}$entryVars->{'thisentryweekendingdayday'}".
				"$entryVars->{'thisentryweekendingyearyear'}\.$CONFIGS->{'gmlogarchivesuffix'}";
		} else {
			$usethisarchivefilename = "$CONFIGS->{'gmentriespath'}/archive-$entryVars->{'thisentrymonthmonth'}".
				"$entryVars->{'thisentryyearyear'}\.$CONFIGS->{'gmlogarchivesuffix'}";
		}
	
		my $newarchivefile = $TEMPLATES->{'gmarchiveindextemplate'};
		$newarchivefile =~ s/{{year}}/$entryVars->{'thisentryyear'}/gi;
		$newarchivefile =~ s/{{yearyear}}/$entryVars->{'thisentryyearyear'}/gi;
		$newarchivefile =~ s/{{month}}/$entryVars->{'thisentrymonth'}/gi;
		$newarchivefile =~ s/{{monthmonth}}/$entryVars->{'thisentrymonthmonth'}/gi;
		$newarchivefile =~ s/{{monthword}}/$entryVars->{'thisentrymonthword'}/gi;
		$newarchivefile =~ s/{{monthwordshort}}/$entryVars->{'thisentrymonthwordshort'}/gi;
		$newarchivefile =~ s/{{monthwordupper}}/$entryVars->{'thisentrymonthwordupper'}/gi;
		$newarchivefile =~ s/{{monthwordlower}}/$entryVars->{'thisentrymonthwordlower'}/gi;
		$newarchivefile =~ s/{{monthworduppershort}}/$entryVars->{'thisentrymonthworduppershort'}/gi;
		$newarchivefile =~ s/{{monthwordlowershort}}/$entryVars->{'thisentrymonthwordlowershort'}/gi;
		$newarchivefile =~ s/{{archivebody}}/$indexarchivebody/gi;
		$newarchivefile =~ s/{{logbody}}/$indexarchivebody/gi;
	
		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$newarchivefile, errHandler=>$errHandler );
		Gm_Storage::saveFile( loc=>"$usethisarchivefilename", content=>[$entryreturn],
			'new'=>1, ch_mod=>'0666', errHandler=>$errHandler );
		$savedNum++;

		## This first if is keeping track of it there is only 1 entry in the first month
		# This issue that needs to be addressed when this is refactored is that this code is working
		# on sets of two, but that doesn't play well if is only one entry in a month, should be made to 
		# work on one entry at a time
		if( $gmneedstogeneratefirstarchive == 1 ){
			$gmneedstogeneratefirstarchive++;
			$startnumber = 1;
		} elsif( $stoppednumber == 1 ){
			$startnumber = 0;
		} else {
			$startnumber = $stoppednumber;
		}
	} ## end of while loop

	return( $stoppednumber );                        
}


## Construct Connected Files
# Builds or Rebuilds the the connected files, including translating variables, accessing file system, etc.
# (opt) ARG connectedstart => the starting connected file to rebuild
# (opt) ARG connectedend => the stopping connected file to rebuild, default all
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: the current index of the connected files list to resume building on
# DEPRECATES: gm_rebuildconnectedfiles
sub constructConnectedFiles {
	my (%params) = @_;
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	
	my $gmCounters = Gm_Storage::getCounters( errHandler=>$errHandler );
	
	my @connectedfilelist = split ('\\n', $CONFIGS->{'gmotherfilelist'} );
	my @variabledatabase = (Gm_Constants::TAGS);
	
	## Normally these vars would be after 
	my $connStartNum = $params{'connectedstart'} || 0;
	my $connEndNum = $params{'connectedend'} || $#connectedfilelist;	

	my $entryVars = Gm_Core::getEntryVariables( entryid=>$gmCounters->{'entrytotal'}, 
		errHandler=>$errHandler );

	my $connectcounter = 0;

	## Since we are working through all the files in this outer loop, the case of the EndNumber greater than
	# the actual number of files won't matter/impact, since this loop will terminate based on the real
	# max number of files regardless of EndNumber
	foreach my $usethisfilename ( @connectedfilelist ){
		# If we aren't on the file that is greater than start and less than end, we don't do anything
		unless( $connectcounter < $connStartNum || $connectcounter > $connEndNum ){	
			my $usethisfilenamestripped = $usethisfilename;
			$usethisfilenamestripped =~ s/\//BACKSLASH/g;
			$usethisfilenamestripped =~ s/\W//g;
			$usethisfilenamestripped =~ s/BACKSLASH/-/g;
		
			my $thereisapattern = Gm_Constants::NO;
		
			my @otherorigfilelines = @{Gm_Storage::readFile( loc=>"$usethisfilename", rel=>'1',
				errHandler=>$errHandler )};

			my @otherpatternfilelines = ();
			if( -e $CONFIGS->{'gmentriespath'}."/$usethisfilenamestripped.cgi" ){
				@otherpatternfilelines = @{Gm_Storage::readFile( loc=>$CONFIGS->{'gmentriespath'}.
					"/$usethisfilenamestripped.cgi", errHandler=>$errHandler )};
				$thereisapattern = Gm_Constants::YES;
			}
		
			my $gmcounter = 0;
		
			foreach( @otherorigfilelines ){
				chomp( $otherorigfilelines[$gmcounter] );
				$gmcounter++;
			}
			## TODO: making assumptions about how to store, CHANGE THIS!
			my $otherorigfilebody = join ('|*|', @otherorigfilelines);
		
			foreach my $thisvariablecheck ( @variabledatabase ){
				if( $otherorigfilebody =~ m/$thisvariablecheck/i ){ 
					$thereisapattern = Gm_Constants::NO; 
				}
			}
		
			my $otherfilebody = Gm_Constants::EMPTY;
			unless( $thereisapattern eq Gm_Constants::NO ){
				$gmcounter = 0;
				foreach( @otherpatternfilelines ){
					chomp( $otherpatternfilelines[$gmcounter] );
					$gmcounter++;
				}
				## TODO: making assumptions about how to store, CHANGE THIS!
				my $otherpatternfilebody = join ('|*|', @otherpatternfilelines);
				$otherfilebody = $otherpatternfilebody;
			} else {
				$otherfilebody = $otherorigfilebody;
			}
		
			my $newfilebodypattern = $otherfilebody;
		
			my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
				template=>$otherfilebody, errHandler=>$errHandler );
		
			## TODO: making assumptions about how to store, CHANGE THIS!
			$entryreturn =~ s/\|\*\|/\n/g;
			$newfilebodypattern =~ s/\|\*\|/\n/g;
		
			Gm_Storage::saveFile( loc=>"$usethisfilename", content=>[$entryreturn], rel=>'1',
				errHandler=>$errHandler );
		
			Gm_Storage::saveFile( loc=>$CONFIGS->{'gmentriespath'}."/$usethisfilenamestripped.cgi", 
				content=>[$newfilebodypattern], 'new'=>1, ch_mod=>'0666', rel=>'1', 
				errHandler=>$errHandler );
		
		}
		$connectcounter++;
		## Optimizing so that if the file we are working on is greater, skip looping to end 
		if( $connectcounter > $connEndNum ){
			last;
		}
	}

	## end of rebuilding connected files
}


## Send Email
# Sends an email per the given arguments 
# NOTE that sending mail is not considered 'essential' even though it is a core 
# service.  This means that is is inappropriate to stop a transaction based on
# this service failing.  Errors will be reported to the cplog.
# ARG to => the email address to send to, if more than one person seperate 
#  with semicolon (i.e. ';')
# (opt) ARG subject => the subject of the email
# (opt) ARG body => the body of the email
# (opt) ARG errHandler => the error handler used to display errors
# RETURN: 1 if worked, 0 otherwise
sub sendEmail {
	my (%params) = @_;
	
	## Setting up vars
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $emailBody = $params{'body'} || 'No Body';
	my $emailSubject = $params{'subject'} || 'No Subject';
	my $emailTo = $params{'to'} || 
		&$errHandler('Invalid "to" parameter passed to sendEmail');
	
	my $worked = 0;
	
	my $mailprog = $CONFIGS->{'gmmailprog'};
### TODO: RUN MAIL PROG PAST SECURITY CHECKING...	
	my $sendithere = "$mailprog -t";

	if( $mailprog && -e $mailprog ){
		my $gmversion = Gm_Constants::GM_VERSION;
		my $gmforums = Gm_Constants::GM_FORUM;

		## make this whitespace aware, just in case ...
		my @sendestinations = split ( ';', $emailTo);
		foreach my $destinationow ( @sendestinations ){
		
			$worked = open( MAIL, "|$sendithere" );
			if( $worked ){
				print MAIL "To: $destinationow\n";
				print MAIL "From: Greymatter <$destinationow>\n";
				print MAIL "Subject: [Greymatter] $emailSubject\n\n";
				print MAIL "$emailBody\n";
				print MAIL "-----\nGreymatter $gmversion\n";
				print MAIL "$gmforums\n\n";
				close( MAIL );
			} else {
				## Should this be passed some real gm_warn? something that won't die?
				Gm_Storage::addLogMessage( msg=>'<font COLOR="#dd0000">Can\'t open the mail program at '.
					$mailprog.'.</font> Please make sure you have this configured correctly.',
					errHandler=>$errHandler );
				$worked = 0;
			}
		} ## End of foreach
		
	} else {
		## Should this be passed some real gm_warn? something that won't die?
		Gm_Storage::addLogMessage( msg=>'<font COLOR="#dd0000">Email program specified "'.
			$mailprog.'" does not exist.</font> Please make sure you have this configured correctly.',
			errHandler=>$errHandler );
		$worked = 0;
	}
	
	return( $worked );	
}


## Has Posted Entries
# Checks whether an entry has been posted already
# RETURN: 1 if safe to post new entries, 0 not safe
sub hasPosted {
	my (%params) = @_;

	my $ret = Gm_Constants::FALSE;
	
	## TODO: this should be a param, so that it can be controlled higher up
	my $gmCounters = Gm_Storage::getCounters( errHandler=>\&Gm_Web::displayAdminErrorExit );
	## validating 
	if( defined( $gmCounters->{'entrytotal'} ) && 
		$gmCounters->{'entrytotal'} =~ m/\d/gi && 
		$gmCounters->{'entrytotal'} > 0 ){
		$ret = Gm_Constants::TRUE;
	}
	
	return( $ret );
}	


## Has Diag Run
# Determines if diagnostics and repair has been run
# RETURN: 1 if run, 0 otherwise
sub hasDiagRun {

	my $ret = Gm_Constants::FALSE;
	## TODO: this should be a param, so that it can be controlled higher up
	my $cploglines = Gm_Storage::getCplog( errHandler=>\&Gm_Web::displayAdminErrorExit );
	
	my $cplogtext = join (" ", @$cploglines);
	if( $cplogtext =~ /successfully performed diagnostics/ ){
		$ret = Gm_Constants::TRUE;
	}
	
	return( $ret );
}



###############################################################
#### Private Methods ##########################################

## Private sorter method just for generateLogListComments
# working off a format of '00|00|Y', doing numerical sort
## should this be anonymous?  Can it be re-used at all?
sub _numLogListCommentSort { 

	my @a_l = split( '\|', $a );
	my @b_l = split( '\|', $b );

	## The OR operator is working as a tie breaker here
	return $a_l[0] <=> $b_l[0] || $a_l[1] <=> $b_l[1];
}


## Inline Formating
# Performs the formatting shorthand ** for bold, // or \\ for italics, and __ for underline
# ARG1: The text to perform the replacement on
# RETURNS: the given text, with formatting if any present, otherwise, unaltered.
# NOTE: this function does not check the configs if INLINING is allowed, should this be moved to 
# doInlineFormating and a wrapper, inlineFormatting sub be made?  Is this a good pattern?
sub _inlineFormating {
	my $text = shift( @_ );
	
	## Is this redundant?  Doesn't match essentially check if it matches before doing it?  Could 
	## it be more efficient by elminating the 'if'?
	if( ($text =~ /\*\*(.*?)\*\*/) || ($text =~ /\\\\(.*?)\\\\/) || 
		($text =~ /__(.*?)__/) || ($text =~ /\/\/(.*?)\/\//) ){
		## Bold **
		$text =~ s/\*\*(.*?)\*\*/<span style="font-weight: bold;">$1<\/span>/isg;
		## Italic \\ or //
		$text =~ s/\\\\(.*?)\\\\/<span style="font-style: italic;">$1<\/span>/isg;
		## TODO: should be start of line OR whitespace, and should others follow this pattern?
		$text =~ s/(\s+)\/\/(.*?)\/\//$1<span style="font-style: italic;">$2<\/span>/isg;
		## Underline __
		$text =~ s/__(.*?)__/<span style="text-decoration: underline;">$1<\/span>/isg;
	}
	
	return $text;
}


1;
