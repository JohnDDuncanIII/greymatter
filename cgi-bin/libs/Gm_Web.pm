package Gm_Web;

###############################################################################
# Greymatter 1.8.2                             
# Copyright (c)2000-2017, The Greymatter team 
# http://greymatterforum.proboards.com/    
# By possessing this software, you agree not to hold the author responsible for 
# any problems that may arise from your installation or usage of Greymatter 
# itself, or from any content generated by yourself or others through the use of 
# this program.  You <I>may</I> freely modify and redistribute this program, so 
# long as every copyright notice (including in this manual and in the Greymatter 
# code) remains fully intact.  Finally, you may <I>not</I> sell or in any way 
# make a financial profit from this program, either in original or modified form.
# Your possession of this software signifies that you agree to these terms; 
# please delete your copy of this software if you don't agree to these terms.
# Original Creator Noah Grey
###############################################################################

#==============================================================================
# Note no exporting because items from this package should be fully qualified
## Gm Web
# This package groups functions that deal with html or web experience.
# This is pretty much, if a subroutine generates html, it belongs here.
# Notice that not everything needs to go here.  Notice the radio button
# logic basically is there to remove boring if...else checked logic.  This 
# is the place for those kinds of optimizations
# 
# CONVENTIONS
# 1. Return a string rather than printing, this is just more elegant.  Leave prints
#   to the calling subroutine, if possible
# 2. Private subroutines should start with the '_' character.  By private I mean
#   it will never be called outside of this package.
# 3. If you have more than 1 or 2 parameters, especially if they are not required,
#   use named parameters such as in createRadioButton.  By putting stuff in a 
#   hash we gain the flexibility to add more optional parameters without having
#   to pass in '' placeholders or modify existing code.
# 4. Subs starting with 'create' should return a string.
# 5. Subs starting with 'display' are expected to contain print statements
# 6. Use ' and " where appropriate.  If you don't have any variables or newlines
# then use ', its quicker and cleaner.  
# 7. Don't put all text on one huge long line.  It messes with some programs
# that don't do line wraps.  

use strict;
use warnings;

use CGI qw(:standard);

use Gm_Utils qw( println );
use Gm_Constants;
use Gm_Storage;
use Gm_Security;

use vars qw($gmversion $gmheadtag $gmframetop $gmfonttag $gmframebottom $gmadmincss);

my $WEB_REQ = '';  ## for mod perl, should this be 'our local'?

$gmadmincss = '<link rel="stylesheet" type="text/css" href="../css/admin.css">';


$gmversion = Gm_Constants::GM_VERSION; ## silly, just so the below blocks can find var, TODO: integrate

$gmheadtag = '<!DOCTYPE HTML>
<html>
<head>
<meta charset="UTF-8">
<meta name="Generator" content="Greymatter '.$gmversion.'">
<title>Greymatter</title>
'.$gmadmincss.'
<script type="text/javascript" src="../js/cookie.js"></script>
</head>

<body>';

## TODO:  GET RID OF THIS
$gmfonttag = '<FONT FACE="VERDANA, ARIAL, HELVETICA" SIZE=2>';

## TODO:  CONVERT THIS TO DIVS AND STYLE!
$gmframetop = '<table border=0 cellpadding=0 cellspacing=0 width=100% height=100%><tr>
<td valign=middle align=center><div id="admin_masthead">greymatter '.$gmversion." </div>\n".
	'<div id="admin_content">';

## TODO:  CONVERT THIS TO DIVS AND STYLE!
$gmframebottom = '</div><div id="admin_footer">'.
	'<a href="'.Gm_Constants::GM_FORUM.'" class="copynotice" target="_blank">'.
	'v'.Gm_Constants::GM_VERSION.' &#183; &copy;2000-2017 The Greymatter Team</a></div></TD></TR></TABLE>';


## TODO, make this stuff POD, at least its a standard ...

## Get Web Params
#  Will get the parameters from the web request
# RETURN: a reference to a hash of the web params
sub getWebParams {
	my (%params) = @_;
	
	## NOTE THIS SHOULD BE SWITCHED TO USE THE CGI.PM MODULE
	# However, due to the use of the 'thomas' variable, see gm.cgi, we can't do that
	# yet, CGI.pm was introduced to perl v. 5.004
	$WEB_REQ = new CGI;
	
	## Loading up vars from params
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my (%IN) = ();


	foreach my $key ( $WEB_REQ->param() ){
		my $name = $key;
		## some of the paramerts could be multiple, i.e. list context, previously GM would concat with tabs
		# see 'multideletecommentselection' param.  If change below, then need to modify code that deals with it
		# can grep for code doing a split on tab
		my $value = join( "\t", $WEB_REQ->param( $key ) );
		

		## NOTE that we may not want to put every variable to the same test, some
		# we can trust more than others, such as the author's entry text, this current 
		# stops someone from posting about the very issues we are trying to stop.
		# ALSO this messes with saving TEMPLATES and CONFIGS (where those chars can be legit)
		## TODO: CLEAN UP THIS LOGIC
		# MUST DEAL WITH CASE OF SOME VARS CAN HAVE |*| OR EVEN | BUT SINCE THIS IS A 
		#  COMMAND LINE HACK, JUST NEED TO CHECK VARS THAT MIGHT GOTO COMMAND LINE
		#  HOWEVER, HOW DEAL THIS THIS CLEANLY?  ALSO, WE AREN'T GOING TO SCRUTINIZE 
		#  AUTHOR SUBMITTED DATA AS CLOSELY, IN REGARD TO IFRAMES ETC., BUT WE STILL WANT
		#  TO KEEP AN EYE OUT FOR COMMAND LINE HACKS
		if( $name =~ m/^edited/i || $name =~ m/template$/i || 
			$name =~ m/^revisedentry/i || $name =~ m/^newcomment/i){		
			## do nothing for now
		} elsif( $name =~ m/^newcommentbody/i ){
			if( Gm_Security::hackWebTest( $name ) || Gm_Security::hackWebTest( $value ) ){
				&$errHandler('We don\'t take kindly to that sort of activity here. '.
				'Your attempt to break the script has been logged and the administrators have '.
				'been notified. <br>');
				## TODO MAKE UTIL HACKNOTIFY FUNCTION, see changelog todo
			}
		} else {
			if( Gm_Security::hackWebTest( $name ) || Gm_Security::hackClTest( $name ) ||
				Gm_Security::hackWebTest( $value ) || Gm_Security::hackClTest( $value ) ){
				&$errHandler('We don\'t take kindly to that sort of activity here. '.
				'Your attempt to break the script has been logged and the administrators have '.
				'been notified. <br>');
				## TODO MAKE UTIL HACKNOTIFY FUNCTION, see changelog todo
			}
		}

		# What if we have multiple values for the form element, hmm?
		if( exists( $IN{$name} ) && defined( $IN{$name} ) ){
			if( $name eq "thomas" ){
				# For some reason, this variable appears multiple times on a page,
				# perhaps so a reload won't mess with it?  Who knows..., but anyway
				# DO NOT APPEND, must replace 
				$IN{$name} = $value;
				warn 'Avoiding appending because of "thomas" variable, bad!';
			} else {
				# really append
				$IN{$name} .= "\t$value";
			}
		} else {
			$IN{$name} = $value;
#warn "$name = $value;\n";			
		}
	}
	
	
	return( \%IN );
}


sub getParam {
	my $key = shift( @_ );
	
	return( $WEB_REQ->param( $key ) );
}

## Create Radio Button
#  Will return a string of html that represents a radio button
# ARG name: name of the radio button
# ARG value: the value of the radio button
# ARG checked: will compare this to 'value' to see if should be checked
# ARG id: will give this element the id of the given value.  Should be unique to page.  
#  used in combination with Label tags to make easier to select inputs
# RETURN: the radio html
sub createRadioButton {
	my (%params) = @_;
	my $name = $params{'name'} || '';
	my $value = $params{'value'} || '';
	my $checked = $params{'checked'} || '';
	my $id = $params{'id'} || '';
	my $label = $params{'label'} || '';

	my $line = '<input type="radio" name="'.$name.'" value="'.$value.'" ';
	if( $id ){
		$line .= 'id="'.$id.'" ';
	}
	if( $value eq $checked ){
		$line .= 'CHECKED';
	}
	$line .= '> ';
	
	if( $id && $label ){
		$label = '<label for="'.$id.'">'.$label.'</label>';
	}
	$line .= $label;
	
	return $line;
}


## Create Checkbox
#  Will return a string of html that represents a checkbox
# ARG name: name of the check box
# ARG value: the value of the checkbox
# ARG checked: array reference that will compare to 'value' to see if should be checked
# ARG id: will give this element the id of the given value.  Should be unique to page.  
# RETURN: the checkbox html
sub createCheckbox {
	my (%params) = @_;
	my $name = $params{'name'} || '';
	my $value = $params{'value'} || '';
	my $checked = $params{'checked'} || [];
	my $id = $params{'id'} || '';
	# TODO refactor the core of this out and make new funcs that pass in radio or checkbox
	my $line = '<input type="checkbox" name="'.$name.'" value="'.$value.'" ';
	if( $id ){
		$line .= 'id="'.$id.'" ';
	}
	
	foreach my $check ( @$checked ){
		if( $value eq $check ){
			$line .= 'CHECKED ';
			last;
		}
	}
	$line .= '>';
	
	return $line;
}


## Create Option
#  Will return a string of html that represents an option, for selects, listboxes
# ARG label: label of the item
# ARG value: the value of the item
# ARG checked: will compare this to 'value' to see if should be selected
# RETURN: the option html
sub createOption {
	my (%params) = @_;
	my $label = $params{'label'} || '';
	my $value = $params{'value'} || '';
	my $checked = $params{'checked'} || '';

	my $line = '<option value="'.$value.'" ';
	if( $value eq $checked ){
		$line .= 'SELECTED';
	}
	$line .= '> '.$label.'</option>';
	
	return $line;
}


## Alternate Row Color
#  Will return an alternating color based on previous 'return'
# (opt) ARG1: previous return from calling this function
# (opt) ARG2: the default color
# (opt) ARG3: the alternate color
# RETURN: the html to alternate color
sub altRowColor {
	my ($lastreturn) = shift( @_ ) || '';
	my ($color) = shift( @_ ) || Gm_Constants::GM_ROW_COLOR;
	my ($color_alt) = shift( @_ ) || Gm_Constants::GM_ALT_COLOR;	

	my $default = 'style="background: '.$color.';"';
	my $alt = 'style="background: '.$color_alt.';"';
	
	my $ret = $default;
	if( $lastreturn eq $default ){
		$ret = $alt;
	}
	
	return $ret;
}


## Create Request Header
# Will return the header for the http request (NOT the html header).  Can be
# given params here to incorporate cookie and other logic.
# RETURN: the request header
sub createRequestHeader {
	my %params = @_;
	
	my %headers = ( 'Content-Type'=>'text/html; charset=utf-8', %params );
	my $s = join( "\n", map { "$_: $headers{$_}" } keys( %headers ) ); 
	
	## TODO: do we need to work about NPH and status?
	# 'HTTP/1.1 200 OK' or 'Status: HTTP/1.1 200 OK'?
	
	return "$s\n";
}


## Create Admin Header
# Will return the header for the html document (NOT the request header).  Can be
# given params here to incorporate redirect and other logic.
# RETURN: the request header
sub createAdminHeader {
	my @meta = @_;
	
	## TODO: make this take meta arguments, but do meta=>[], instead of everything, named params scale 
	# better....
#	my $metaLine = join( "\n ", @meta );
	my $localHeader = $gmheadtag;
	## Everyone raise their hand who thinks this is lame ...
#	$localHeader =~ s/<HEAD>/<HEAD>\n$metaLine\n/s;
	
	return( $localHeader );
}


## Display User Error Page Exit
# Will display the given error message, print the header, and exit.
# ARG1: Error string to print
sub displayUserErrorExit {
	my $error = shift( @_ );
	_displayPageExit( _createUserError( $error ) );
}


## Display User Redirect Exit
# Will redirect to the given URL and cover all bases, and exit.
# ARG1: URL to redirect to
sub displayUserRedirectExit {
	my $url = shift( @_ );
	
	my $msg = 'If this page does not automatically refresh, follow this link: '.
	'<a href="'.$url.'">'.$url.'</a><br />';
	
	$msg = _createUserError( $msg );
	
	## Everyone raise their hand who thinks this is lame ...
	my $meta = '<meta http-equiv="refresh" content="0; Url='.$url.'">';
	$msg =~ s/<head>/<head>\n$meta\n/s;
	
	
	println( createRequestHeader( Location=>$url ) );
	println( $msg );
	exit; # after we show the page we are done
}


## Display Admin Error Page Exit
# Will display the given error message, print the header, and exit.
# ARG1: Error string to print
# DEPRECATES: gm_dangermouse
sub displayAdminErrorExit {
	my $error = shift( @_ );
	_displayPageExit( _createAdminPage( '<span class="error_msg">Error Notice</span><p>'.$error.'</p>' ) );
}


## Display Admin Redirect Exit
# Will redirect to the given URL and cover MOST bases, and exit.  Note that we don't have a way to 
# manually redirect on the admin page.  If we provide this link, we wouldn't be able to tell the user
# when to click (since it could depend on the file rebuild process).  If we provide the link, the user
# may impatiently click the button, which would result in multiple of the same gm process trying to alter
# the files.  This seems very very bad.  The manual redirect link would have to have some warning like
# "Never ever follow the link  unless your browser has stopped working".
# ARG1: URL to redirect to
# ARG2: Text string to print
sub displayAdminRedirectExit {
	my $msg = shift( @_ );
	my $url = shift( @_ ) || displayAdminErrorExit( 'Url is required for displayAdminRedirectExit');

	
# 	my $msg = 'If this page does not automatically refresh, follow this link: '.
# 	'<a href="'.$url.'">'.$url.'</a><br />';
	
	$msg = _createAdminPage( $msg );
	
	## Everyone raise their hand who thinks this is lame ...
	my $meta = '<meta http-equiv="refresh" content="1; Url='.$url.'">';
	## Do we need to add 'no-cache' or something like that? Usually don't for cgi
	$msg =~ s/<HEAD>/<HEAD>\n$meta\n/s;
	
	## If we use Location here, it sends a status-code 3xx that indicates the page has moved, and the browser doesn't
	# show the page we send along :(
	println( createRequestHeader() );
	println( $msg );
	exit; # after we show the page we are done
}


## Display Admin Page Exit
# Will display the given given page no worry about headers
# ARG1: Page to display
# DEPRECATES: any direct use of gm css header, footer vars
sub displayAdminPageExit {
	my $message = shift( @_ );
	_displayPageExit( _createAdminPage( $message ) );
}


## Create Paging
#  Will create a page with next, previous and numbered pages links and
# limit the data to the page size constant (see Gm_Constants)
# ARG data => an array reference of data to truncate and return
# ARG baseurl => the base url to use when constructing links
# ARG webparams => the request parameters
# (opt) ARG pagesize => the overriding default page size
# RETURN 1: the navigation html
# RETURN 2: a reference to the data, truncated for the correct page
sub createPaging {
	my (%params) = @_;
	my $data = $params{'data'} || {};
	my $base_url = $params{'baseurl'} || '?';
	my $IN = $params{'webparams'} || {};
	my $pageSize = $params{'pagesize'} || Gm_Constants::GM_PAGE_SIZE;

	# Do we have any params, or are we continueing to add to others?
	if( $base_url =~ m/\?/gi ){
		$base_url .= '&';  ## already have params
	} else {
		$base_url .= '?';  ## start fresh
	}

	my @new_data = ();
	my $navigation = '';

  my $total_rows = scalar( @{$data} );
  my $page = defined( $IN->{'page'} ) ? $IN->{'page'} : '';
	
	if( $total_rows > $pageSize && $page ne 'all' ){
		## Create Navigation
		my $page_on = 0;
		if( $IN->{'page'} && $IN->{'page'} !~ m/\D/gi ){
			## TODO, make the number regex a util func, isDigit
			$page_on = $IN->{'page'};
		}
	
		# Note that if page_on is 0, then we start with row 0
		my $start_row = $page_on * $pageSize;
		my $end_row = $start_row + $pageSize;

		## Do Previous
		if( $page_on > 0 ){
			$navigation = ' <a href="'.$base_url.'page='.($page_on-1).'">Previous</a> ';
		} else {
			$navigation = ' (<a href="'.$base_url.'page=all">All</a>) ';
		}
		
		## Do pages, making curr page not a link
		my $num_pages = $total_rows / $pageSize;
		foreach( my $i = 0; $i < $num_pages; $i++ ){
			if( $i == $page_on ){
				$navigation .= ' '.($i+1).' ';
			} else {
				$navigation .= ' <a href="'.$base_url.'page='.$i.'">'.($i+1).'</a> ';
			}
		}

		
		## Do Next
		if( $total_rows > $end_row ){ 
			$navigation .= '<a href="'.$base_url.'page='.($page_on+1).'">Next</a> ';
		} else {
			$navigation .= ' Next ';
		}
		
		## Create New Data set	
		foreach( my $i = $start_row; $i < $end_row && $i < $total_rows; $i++ ){
			push( @new_data, $data->[$i] );
		}
		## end if total rows greater than page
	} else {
		@new_data = @{$data};		
	}
	
	return( $navigation, \@new_data );
}


#### Private Methods #####


## Create User Error
#  Will create the user error using the correct templates
# ARG1: Error string
# RETURN: the User Error html
sub _createUserError {
	my $dangerwarning = shift( @_ );
	
	# NOTE that we are using the adminerror handler, since we are in the user
	# if we can't create the user error, calling displayUserErrorExit == infinite loop
	my $gmTemplates = Gm_Storage::getTemplates( errHandler=>\&displayAdminErrorExit);

	my $line = $gmTemplates->{'gmusererrorheadertemplate'}; #User error header
	$line .= $dangerwarning;
	$line .= $gmTemplates->{'gmusererrorfootertemplate'}; #User error footer 
	
	# Why won't this do Param replacement?  It could use the entry 00000001 as a 
	## a 'template' so that the getEntryVariables stuff is happy.
	# HOWEVER, doing template variable replacement has ALOT of dependancies.  Quite
	# frankly, if we are in this function, chances are good that something is wrong
	# and trying to go through the most complicated part of the system at this stage
	# is unwise, so its a pain, but that template is unlikely to do var replacement...
	
	return $line;
}


## Create User Error
#  Will create the user error using the correct templates
# ARG1: Error string
# RETURN: the User Error html
sub _createAdminPage {
	my $theText = shift( @_ );
## TODO: THIS IS WHERE THE MENU DIV WILL BE PRINTED OUT, or above, so navi for errors
	my $line = createAdminHeader();
	$line .= "\n$gmframetop\n$theText\n$gmframebottom\n</body>\n</html>\n";
	
	return $line;
}


## Dispaly Page and Exit
# Private sub that will display the header, given message, and exit.
# ARG1: Error string to print
# TODO: have request header arg passthrough, so that can be reused in the RedirectExit subroutines
sub _displayPageExit {
	my $error = shift( @_ );
	
	println( createRequestHeader() );
	println( $error );
	exit; # after we show the page we are done
}

1;
