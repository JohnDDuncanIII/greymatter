package Gm_Storage;

###############################################################################
# Greymatter 1.8.2                             
# Copyright (c)2000-2017, The Greymatter team 
# http://greymatterforum.proboards82.com/     
# By possessing this software, you agree not to hold the author responsible for 
# any problems that may arise from your installation or usage of Greymatter 
# itself, or from any content generated by yourself or others through the use of 
# this program.  You <I>may</I> freely modify and redistribute this program, so 
# long as every copyright notice (including in this manual and in the Greymatter 
# code) remains fully intact.  Finally, you may <I>not</I> sell or in any way 
# make a financial profit from this program, either in original or modified form.
# Your possession of this software signifies that you agree to these terms; 
# please delete your copy of this software if you don't agree to these terms.
# Original Creators Noah Grey
###############################################################################

#==============================================================================
# Note no exporting because items from this package should be fully qualified
## Gm Storage
# This package groups functions that deal with getting/putting data from peristant storage
# this is the package that will be rewritten to handle a database backend.  These
# subroutines will mask the flatfile system from the rest of the code.
# 
# CONVENTIONS
# 1. Return a string rather than printing, this is just more elegant.  Leave prints
#   to the calling subroutine if possible.
# 2. Private subroutines should start with the '_' character.  By private I mean
#   it will never be called outside of this package.
# 3. If you have more than 1 or 2 parameters, especially if they are not required,
#   use named parameters such as in createRadioButton.  By putting stuff in a 
#   hash we gain the flexibility to add more optional parameters without having
#   to pass in '' placeholders or modify existing code.
# 4. Use ' and " where appropriate.  If you don't have any variables or newlines
# then use ', its quicker and cleaner.  
# 5. Don't put all text on one huge long line.  It messes with some programs
# that don't do line wraps.  

use strict;
use warnings;

use Gm_Constants;
use Gm_Utils;
use Gm_Security;

## NOTE: THIS IS NOT GLOBAL AND SHOULD NOT BE USED OUTSIDE OF THIS PACKAGE
# this is becaue the delimeter is an artifact of the file based storage
# mechanism.  The code outside this package must not act on any assumptions!
my $DATA_DELIM = '|'; ## Must escape bar character when splitting ... 

## TODO: make this stuff POD, at least its a standard ...

## TODO: MAKE updateTemplate AND updateConfig WHERE GIVE ONE TEMPLATE AND ONE CONFIG TO UPDATE

## TODO:  CAN WE USE GLOBAL VARS TO STORE TEMPLATE AND CONFIG DATA AND JUST RETURN 
# THAT INSTEAD OF FETCHING FROM FILE SEVERAL TIMES?  WHEN SAVE CAN CLEAR GLOBAL
# ISSUE IS THAT IF YOU PUT A WARN IN _LOADFILEARRAY, YOU SEE ALOT OF SAME CALLS

## Validate Resources
#  Will validate the files used to store data in GreyMatter.  It will check existance
#   and whether the files is readable and writable if needed (if errors, will use
#   given error handler or use warn).
#  NOTE: if this was working off a database, this method would probably verify the
#    db structure.  This is why this is a Storage method, since the resources
#		 depend on the storage mechanism used (flat file vs db vs web service )
# (opt) ARG ch_mod => if true (1 or something), will chmod the files as well to proper value
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: $worked = Gm_Storage::validateResources( errHandler=\&myErrHandler );
sub validateResources {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $toChmod = $params{'ch_mod'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;
	my $worked = 1; ## assuming works
	
	## TODO CAN USE CONFIGS TO GET FULLY QUALIFIED PATH???
	## Yes, make so that it tests with and without, per the deprecated functionality
	my @exists = qw(gm-counter.cgi gm-karma.cgi gm-comments.cgi 
									gm-entrylist.cgi gm-cplog.cgi gm-authors.cgi gm-templates.cgi 
									gm-banlist.cgi gm-config.cgi gm.cgi);
									
	my @writable =  qw(gm-counter.cgi gm-entrylist.cgi gm-cplog.cgi 
										gm-authors.cgi gm-templates.cgi gm-banlist.cgi gm-config.cgi);

	## TODO: SHOULD THIS USE VALIDATE FILE?  IT COULD NOT USE IT OFFICIALLY AS THAT
	# WOULD BE BREAKING THE DATA STORAGE INDIFFERENCE.  IT IS DUPLICATING FUNCTIONALITY
	# BUT IT IS SIMPLE FUNCTIONALITY...
	
	## checking if files exist
	foreach my $file (@exists){
		if( !-e $file ){
			&$errHandler( $file.' is missing.  Please upload this file to the same '.
				'directory as all the other Greymatter cgi files.' );
			$worked = 0;
		}
	}
	
	foreach my $file (@writable){
		chmod( 0666, $file ) if $toChmod;	
		if( !-r $file ){
			&$errHandler( $file.' is not readable.  Please check the file '.
				'permissions and make sure you CHMOD it to 666.' );
			$worked = 0;
		} elsif ( !-w $file ){
			&$errHandler( $file.' is not writable.  Please check the file '.
				'permissions and make sure you CHMOD it to 666.' );
			$worked = 0;
		}
	}

	return $worked;
}

## Validate File
# Will validate the given file.  It will check existance
#  and whether the files is readable (by default) and 
#  writable if needed (if errors, will use given error handler or use warn).
#  NOTE: if this was working off a database, this method would probably verify the
#    db structure.  This is why this is a Storage method, since the resources
#		 depend on the storage mechanism used (flat file vs db vs web service )
# (opt) ARG writable => check if the file is writable
# (opt) ARG ch_mod => if true (1 or something), will chmod the files as well to proper value
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: $worked = Gm_Storage::validateResources( errHandler=\&myErrHandler );
sub validateFile {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	
	my $file = $params{'file'} || 
		&$errHandler('Invalid file parameter pass to validateFile');
	my $writable = $params{'writable'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;		
	my $toChmod = $params{'ch_mod'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;
	my $worked = 1; ## assuming works							
	
	## checking if files exist
	if( !-e $file ){
		&$errHandler( $file.' is missing.  Greymatter is expecting this file to exist '.
		'and cannot continue without it.' );
		$worked = 0;
	}

	chmod( 0666, $file ) if $toChmod;		

	if( !-r $file ){
		my $err = $file.' is not readable.  Please check the file permissions';
		if( $toChmod ){
			$err .= ' and make sure you CHMOD it to 666.';
		}
		&$errHandler( $err );
		$worked = 0;
	}

	if ( $writable && !-w $file ){
		my $err = $file.' is not writable.  Please check the file permissions';
		if( $toChmod ){
			$err .= ' and make sure you CHMOD it to 666.';
		}
		&$errHandler( $err );
		$worked = 0;
	}				

	return $worked;
}


## Get Languages
# Will return a hash of installed languages.  The hash is made up of the keys, which
#  are the human readable langauge, typically the name, followed by the English name in
#  parenthesis e.g. 'Espanol (Spanish)'.  The valud of the hash is the language ID which
#  can be passed to Gm_Storage::loadLanguage.  The value will depend on how the langauge
#  files are stored.  For instance, in a flat file system, English => en_US.  This
#  will correspond to the en_US.pm file in the lang directory.  If GreyMatter were
#  switched to a database, this value could be a database id.  Or the database could
#  use the locale label as its id.  The importance is to never assume what the 'value' of the
#  hash actually is, just that it will always work when given to the loadLanguage subroutine.
# Return: Hash of languages installed
# USAGE: 
#   my $ls = Storage::getLanguages();
#   foreach my $l ( keys( %$ls )){
#      print "$l = $ls->{$l}\n"; }
sub getLanguages {
	my (%params) = @_;
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;

	my %langs = ();
			
	## TODO: FIX THIS, ITS HARDCODED AND ITS RELATIVE.  WE PRO'LLY CAN USE ABSOLUTE PATH
	# OTHERWISE ASSUMING THAT CALLING SCRIPT IS TOPLEVEL CGI
	my $lang_dir = 'lang/.';
	
	my $worked = opendir( DIR, $lang_dir );
	
	if( $worked ){
		while( defined( my $lang = readdir( DIR ) )){
			## As noted in translation document, locale names MUST be
			# two lowercase letters + '_' two lowercase or uppercase letters + '.pm'
			# or offically: ISO language code + '_' + ISO Country Code
			if( $lang =~ m/^[a-z]{2}?_[a-zA-Z]{2}?\.pm$/ ){
				$lang =~ s/\.pm$//;
				## TODO: FIX THIS, ITS HARDCODED AND ITS RELATIVE.  WE PRO'LLY CAN USE ABSOLUTE PATH
				# OTHERWISE ASSUMING THAT CALLING SCRIPT IS TOPLEVEL CGI
				eval "require lang::$lang";
				unless( $@ ){
					if( defined( $lang->LANGUAGE ) ){
						## note storing without '.pm' on file ending, cleaner, more agnostic (data source wise)
						$langs{ $lang->LANGUAGE } = $lang;
					}
				} else {
					$langs{ "Couldn't load: $lang" } = $lang;
				}
		
			}
		}
	} else {
		&$errHandler( 'Cannot Load Languages: $!' );
	}
	
	return \%langs;
}


## Load Language
# this can be used to load a particular language.  This method encapsulates how the langauges
#  stored from the rest of GreyMatter, database of file, it doesn't matter
# ARG1: a language locale hopefully, but really, a value from the hash returned by
#  getLanguages.  Trust GreyMatter to know what to load from the value, since it provided it.
# Return: reference to Hash of language files
# USAGE: my $hash_ref = Storage::loadLang( 'en_US' );
sub loadLanguage {
	my $lang = shift( @_ ) || Gm_Constants::EMPTY;
	my $errHandler = \&Gm_Utils::gmWarn;
	my $labels = {};
	
	## TODO: FIX THIS, ITS HARDCODED AND ITS RELATIVE.  WE PRO'LLY CAN USE ABSOLUTE PATH
	# OTHERWISE ASSUMING THAT CALLING SCRIPT IS TOPLEVEL CGI
	if( -e "lang/$lang.pm" ){
		eval "require lang::$lang";
		unless( $@ ){
			eval{
				$labels = $lang->getLabels();
			};
			if( $@ ){
				&$errHandler( "subroutine getLabels not defined for ($lang): $@" );
			}
		} else {
			&$errHandler( "error loading lang ($lang): $@" );
		}
	} else {
		&$errHandler( "Can't find module ($lang)" );
	}
	
	return( $labels );
}



## getEntry( id=>$id )
#  Will retrive an entry for a given id and 
#		hash of (entryinfo, karmavotes, maintext, extendedtext, comments)
#			entryinfo is hash of:
# 			id  = numeric, never 0
# 			author = alphanumeric, note unaffected by name changes (bad) and deletions (good)
# 			subject = title of post alphanumeric (we hope)
# 			weekday = numeric (0-6, 0=Sunday, 1=Monday, etc.)
# 			month = month of post numeric (1-12, no leading zeroes)
# 			day = day of post numeric (1-31, no leading zeroes)
# 			year = year of post numeric (format: yyyy)
# 			hour = hour of post numeric (1-12, no leading zeroes)
# 			minute =  minute of post numeric (1-12, no leading zeroes)
# 			second = second of post numeric (1-12, no leading zeroes)
# 			ampm = either AM or PM
# 			karmapos = positive karma numeric
# 			karmaneg = negative karma numeric
# 			commenttotal = number of comments numeric; 0 if no comments
# 			karma = votes allowed yes/no
# 			comments = comments allowed yes/no
# 			status = entry open or closed open/closed
# 			music = current music of entry (well author really)
# 			mood = current mood of entry (well author really)
# 			emoticons = are emoticons enabled, yes or no
#			karmavotes is hash of ( ip => P/N ) (of course has placeholder
#			 	0.0.0.0|I is a placeholder.			
#			maintext is scalar, The "main entry" text of each post. Single line breaks 
#				are replaced with a |*|, double line breaks with |*||*|. All of the text 
#				is presented in one wrapping line.
#			extendedtext is scalar, The "extended entry" text of each post. Text 
#				conventions are the same as with line 3.
#			comments is array of hashes:
#				# Need number variable, to go 1st through X?
# 			name = commenter's name alphanumeric
# 			ip = in the form of xxx.xxx.xxx.xxx
# 			email = in the form of user@email.com. If not provided, left blank.
# 			homepage = commenter's webpage in the form of http://www.site.com. If not provided, left blank.
# 			weekday = of comment numeric (0-6, 0=Sunday, 1=Monday, etc.)
# 			month = of comment numeric (1-12, no leading zeroes)
# 			day = of comment numeric (1-31, no leading zeroes)
# 			year = of comment numeric (format: yyyy)
# 			hour = of comment numeric (1-12, no leading zeroes)
# 			minute = of comment numeric (1-12, no leading zeroes)
# 			second = of comment numeric (1-12, no leading zeroes)
# 			ampm = either AM or PM
# 			comment = text presented all on one line, with the same text replacement 
#					conventions as in the main entry text. (See Line 3.)
# TODO use id for comments (order in which added), have to do mass conversion when upgrade
# ARG id => the id of the entry to return, NOT padded with 0's, that is file specific
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: an hash ref to the entry, as defined by this subroutine
# USAGE: $gm_e = Gm_Storage::getEntry( id=>1 ); 
# print $gm_e->{'maintext'};  ## print text of the exntry
sub getEntry {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $id = $params{'id'} || 
		&$errHandler('Invalid id parameter passed to getEntry');
	my %gmentry = ();

	if( $id ne Gm_Constants::EMPTY ){
		## we ain't gonna make assumptions about the id, so no test for all numbers, etc.
		my $configs = getConfigs( errHandler=>$errHandler );
	
		my $pad_id = Gm_Utils::toEntryPadded( $id );
	
		my $file_path = $configs->{'gmentriespath'}."/$pad_id.cgi";
		my $lines = _loadFileArray( fn=>$file_path, %params );
		
		if( scalar( @$lines ) > 3 ){
		# An entry must be at least 4 lines	
		
			# 1. Dealing with entry info
			my (@info) = split ( "\\$DATA_DELIM", $lines->[0]);
			$gmentry{'entryinfo'}{'id'} = $info[0];
			
# ---------------------------------------------------------------------
# PF 1.8.3
# modify here for fixed post links
# Add extra entry to the .cgi file for the link name {if its set}
# Also need to modify all entries files to add the extra parameter
# ----------------------------------------------------------------------

			$gmentry{'entryinfo'}{'linklink'} = $info[1];
			
			
			$gmentry{'entryinfo'}{'author'} = $info[2];
			$gmentry{'entryinfo'}{'subject'} = $info[3];
			$gmentry{'entryinfo'}{'weekday'} = $info[4];
			$gmentry{'entryinfo'}{'month'} = $info[5];
			$gmentry{'entryinfo'}{'day'} = $info[6];
			$gmentry{'entryinfo'}{'year'} = $info[7];
			$gmentry{'entryinfo'}{'hour'} = $info[8];
			$gmentry{'entryinfo'}{'minute'} = $info[9];
			$gmentry{'entryinfo'}{'second'} = $info[10];
			$gmentry{'entryinfo'}{'ampm'} = $info[11];
			$gmentry{'entryinfo'}{'karmapos'} = $info[12];
			$gmentry{'entryinfo'}{'karmaneg'} = $info[13];
			$gmentry{'entryinfo'}{'commenttotal'} = $info[14];
			$gmentry{'entryinfo'}{'karma'} = $info[15];
			$gmentry{'entryinfo'}{'comments'} = $info[16];
			$gmentry{'entryinfo'}{'status'} = defined( $info[17] ) ? $info[17] : 'O';
			$gmentry{'entryinfo'}{'music'} = defined( $info[18] ) ? $info[18] : Gm_Constants::EMPTY;
			$gmentry{'entryinfo'}{'mood'} = defined( $info[19] ) ? $info[19] : Gm_Constants::EMPTY;
			$gmentry{'entryinfo'}{'emoticons'} = defined( $info[20] ) ? $info[20] : Gm_Constants::NO;			
			
			# 2. dealing with karma releated information, ip =>P/N
			my %karma = split ( "\\$DATA_DELIM", $lines->[1]);
			$gmentry{'karmavotes'} = \%karma;
			
			# 3. dealing with main text of entry
			$gmentry{'maintext'} = $lines->[2];
			
			# 4. dealing with extended text of entry
			$gmentry{'extendedtext'} = $lines->[3];
		
			# 5. dealing with comments
			my @comments = ();
		
			for( my $i = 4; $i < scalar( @$lines ); $i++ ){
				my (@vals) = split ( "\\$DATA_DELIM", $lines->[$i] );
				my %coms = ();
				$coms{'name'} = $vals[0];
				$coms{'ip'} = $vals[1];
				$coms{'email'} = $vals[2];
				$coms{'homepage'} = $vals[3];
				$coms{'weekday'} = $vals[4];
				$coms{'month'} = $vals[5];
				$coms{'day'} = $vals[6];
				$coms{'year'} = $vals[7];
				$coms{'hour'} = $vals[8];
				$coms{'minute'} = $vals[9];
				$coms{'second'} = $vals[10];
				$coms{'ampm'} = $vals[11];
				$coms{'comment'} = $vals[12];
	
				push( @comments, \%coms );
			}
			
			$gmentry{'comments'} = \@comments;
		} else {
			&$errHandler( "Entry $id is malformed, cannot retrieve." );
		}
	} else {
		#  no id passed
		&$errHandler( 'Invalid id passed to getEntry.' );
	}

# Code:
# 742|username|entry subject|0|11|18|2001|5|44|4|AM|0|0|1|no|yes|open
# 0.0.0.0|I
# This is the main entry text.|*||*|More text.
# This would be extended entry text.
# flippedcracker|192.88.00.00|no@email.com|http://www.example.com/|1|11|19|2001|11|21|6|AM|A comment.
# 
# How the file is structured:
# Entry .cgi files are divided into major chunks of information - one chunk per line.
# 
# Line 1: information about the post
# Line 2: Karma-related information. The IP addresses and the votes associated with those IP addresses are collated here.
# Line 3: the "main text" of each entry.
# Line 4: the "extended text" of each entry. If none, a blank line is left.
# Line 5(and more if necessary): comments. One comment per line.
# 
# Contents of Line 1:
# entrynumber  numeric, never 0
# username alphanumeric
# title of post alphanumeric (we hope)
# weekday numeric (0-6, 0=Sunday, 1=Monday, etc.)
# month of post numeric (1-12, no leading zeroes)
# day of post numeric (1-31, no leading zeroes)
# year of post numeric (format: yyyy)
# hour of post numeric (1-12, no leading zeroes)
# minute of post numeric (1-12, no leading zeroes)
# second of post numeric (1-12, no leading zeroes)
# am/pm either AM or PM
# positive karma numeric
# negative karma numeric
# number of comments numeric; 0 if no comments
# karma votes allowed yes/no
# comments allowed yes/no
# entry open or closed open/closed
# music
# mood
# emoticons enabled
# 
# Contents of Line 2:
# 0.0.0.0|I is a placeholder.
# If ip # 12.34.56.78 casts a positive karma vote, it appends |12.34.56.78|P (or N for negative).
# 
# Contents of Line 3:
# The "main entry" text of each post. Single line breaks are replaced with a |*|, double line breaks with |*||*|. All of the text is presented in one wrapping line.
# 
# Contents of Line 4:
# The "extended entry" text of each post. Text conventions are the same as with line 3.
# 
# A typical comment line:
# Code:
# flipped cracker|192.00.00.00|no@email.com|http://www.example.com/|1|11|19|2001|11|21|6|AM|A comment.
# 
# The comment line, in detail
# commenter's name alphanumeric
# commenter's IP in the form of xxx.xxx.xxx.xxx
# commenter's email in the form of user@email.com. If not provided, left blank.
# commenter's webpage in the form of http://www.site.com. If not provided, left blank.
# weekday of comment numeric (0-6, 0=Sunday, 1=Monday, etc.)
# month of comment numeric (1-12, no leading zeroes)
# day of comment numeric (1-31, no leading zeroes)
# year of comment numeric (format: yyyy)
# hour of comment numeric (1-12, no leading zeroes)
# minute of comment numeric (1-12, no leading zeroes)
# second of comment numeric (1-12, no leading zeroes)
# am/pm either AM or PM
# comment text presented all on one line, with the same text replacement conventions as in the main entry text. (See Line 3.)


	return \%gmentry;
}


## Set Entry
#  Will store the entry to wherever they may be stored ... in the following format:
#		hash of (entryinfo, karmavotes, maintext, extendedtext, comments)
#			entryinfo is hash of:
# 			id  = numeric, never 0
# 			author = alphanumeric
# 			subject = title of post alphanumeric (we hope)
# 			weekday = numeric (0-6, 0=Sunday, 1=Monday, etc.)
# 			month = month of post numeric (1-12, no leading zeroes)
# 			day = day of post numeric (1-31, no leading zeroes)
# 			year = year of post numeric (format: yyyy)
# 			hour = hour of post numeric (1-12, no leading zeroes)
# 			minute =  minute of post numeric (1-12, no leading zeroes)
# 			second = second of post numeric (1-12, no leading zeroes)
# 			ampm = either AM or PM
# 			karmapos = positive karma numeric
# 			karmaneg = negative karma numeric
# 			commenttotal = number of comments numeric; 0 if no comments
# 			karma = votes allowed yes/no
# 			comments = comments allowed yes/no
# 			status = entry open or closed open/closed
# 			music = current music of entry (well author really)
# 			mood = current mood of entry (well author really)
# 			emoticons = are emoticons enabled, yes or no
#			karmavotes is hash of ( ip => P/N ) (of course has placeholder
#			 	0.0.0.0|I is a placeholder.			
#			maintext is scalar, The "main entry" text of each post. Single line breaks 
#				are replaced with a |*|, double line breaks with |*||*|. All of the text 
#				is presented in one wrapping line.
#			extendedtext is scalar, The "extended entry" text of each post. Text 
#				conventions are the same as with line 3.
#			comments is array of hashes:
# 			name = commenter's name alphanumeric
# 			ip = in the form of xxx.xxx.xxx.xxx
# 			email = in the form of user@email.com. If not provided, left blank.
# 			homepage = commenter's webpage in the form of http://www.site.com. If not provided, left blank.
# 			weekday = of comment numeric (0-6, 0=Sunday, 1=Monday, etc.)
# 			month = of comment numeric (1-12, no leading zeroes)
# 			day = of comment numeric (1-31, no leading zeroes)
# 			year = of comment numeric (format: yyyy)
# 			hour = of comment numeric (1-12, no leading zeroes)
# 			minute = of comment numeric (1-12, no leading zeroes)
# 			second = of comment numeric (1-12, no leading zeroes)
# 			ampm = either AM or PM
# 			comment = text presented all on one line, with the same text replacement 
#					conventions as in the main entry text. (See Line 3.)
# ARG entry => a ref to an hash of hashes/arrays/scalars that that make up an 
#		ENTIRE the Entry to store to a file
# (opt) ARG new => this is a new entry and if it already exists, we error out
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: %gm_e = ();  
#  Gm_Storage::setEntry( entry=>\%gm_e ); 
sub setEntry {
	my (%params) = @_;

## NOTE: SHOULD KARMA AND COMMENTS DEFAULT TO EMPTY IF NOT GIVEN?  WHEN DOING NEW
# IS IT REASONABLE TO EXPECT THOSE TO DEFAULT TO 'EMPTY' IF NOT GIVEN, LIKE MORETEXT?
	
	my $worked = 0;
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	
	my $entry = $params{'entry'} || 
		&$errHandler('Invalid entry parameter passed to setEntry');
	my $new_file = $params{'new'} || '0';
	my $lines = [];
	
	my $entryinfo = $entry->{'entryinfo'};
	if( defined( $entryinfo ) ){
		my $id = $entryinfo->{'id'};
		if( defined( $id ) ){
	
			# 1. The entry information			
			my $author = $entryinfo->{'author'};
			
# ---------------------------------------------------------------------
# PF 1.8.3
# modify here for fixed post links
# Add extra entry to the .cgi file for the link name {if its set}
# Also need to modify all entries files to add the extra parameter
# ----------------------------------------------------------------------
			
			my $linklink = $entryinfo->{'linklink'};
			
			my $subject = $entryinfo->{'subject'};
			my $weekday = $entryinfo->{'weekday'};
			my $month = $entryinfo->{'month'};
			my $day = $entryinfo->{'day'};
			my $year = $entryinfo->{'year'};
			my $hour = $entryinfo->{'hour'};
			my $minute =  $entryinfo->{'minute'};
			my $second = $entryinfo->{'second'};
			my $ampm = $entryinfo->{'ampm'};
			my $karmapos = $entryinfo->{'karmapos'};
			my $karmaneg = $entryinfo->{'karmaneg'};
			my $commenttotal = scalar( @{$entry->{'comments'}} );
			my $karma = $entryinfo->{'karma'};
			my $comments = $entryinfo->{'comments'};
			my $status = $entryinfo->{'status'};
			my $music = $entryinfo->{'music'};
			my $mood = $entryinfo->{'mood'};
			my $emoticons = $entryinfo->{'emoticons'};

# ---------------------------------------------------------------------
# PF 1.8.3
# modify to add the new link to the line
# ----------------------------------------------------------------------
	
			$lines->[0] = $id.$DATA_DELIM.$linklink.$DATA_DELIM.$author.$DATA_DELIM.$subject.$DATA_DELIM.
				$weekday.$DATA_DELIM.$month.$DATA_DELIM.$day.$DATA_DELIM.$year.$DATA_DELIM.
				$hour.$DATA_DELIM.$minute.$DATA_DELIM.$second.$DATA_DELIM.$ampm.$DATA_DELIM.
				$karmapos.$DATA_DELIM.$karmaneg.$DATA_DELIM.$commenttotal.$DATA_DELIM.
				$karma.$DATA_DELIM.$comments.$DATA_DELIM.$status.$DATA_DELIM.$music.
				$DATA_DELIM.$mood.$DATA_DELIM.$emoticons;
	
			# 2. Karma Votes		
			my $karmavotes = $entry->{'karmavotes'};
			my $karmaline = '0.0.0.0|I'; ## this is placeholder
			delete( $karmavotes->{'0.0.0.0'} );
			foreach my $karma_key ( keys( %$karmavotes ) ){
				$karmaline .= $DATA_DELIM.$karma_key.$DATA_DELIM.$karmavotes->{$karma_key};
			}
			
			$lines->[1] = $karmaline;
			
			# 3. Main text
			$lines->[2] = $entry->{'maintext'};
			
			# 4. Extended text
			$lines->[3] = $entry->{'extendedtext'};
			
			# 5. Comments, if there are any
			my $entry_comments = $entry->{'comments'};
			my $i = 4;
			
			foreach my $ec_line ( @$entry_comments ){
				my $c_name = $ec_line->{'name'};
				my $c_ip = $ec_line->{'ip'};
				my $c_email = $ec_line->{'email'};
				my $c_homepage = $ec_line->{'homepage'};
				my $c_weekday = $ec_line->{'weekday'};
				my $c_month = $ec_line->{'month'};
				my $c_day = $ec_line->{'day'};
				my $c_year = $ec_line->{'year'};
				my $c_hour = $ec_line->{'hour'};
				my $c_minute = $ec_line->{'minute'};
				my $c_second = $ec_line->{'second'};
				my $c_ampm = $ec_line->{'ampm'};
				my $c_comment = $ec_line->{'comment'};
				
				$lines->[$i] = $c_name.$DATA_DELIM.$c_ip.$DATA_DELIM.$c_email.$DATA_DELIM.$c_homepage.
					$DATA_DELIM.$c_weekday.$DATA_DELIM.$c_month.$DATA_DELIM.$c_day.$DATA_DELIM.$c_year.
					$DATA_DELIM.$c_hour.$DATA_DELIM.$c_minute.$DATA_DELIM.$c_second.
					$DATA_DELIM.$c_ampm.$DATA_DELIM.$c_comment;
				$i++;
			}
			
			## Saving the whole thing now, using padded number scheme
			my $configs = getConfigs( errHandler=>$errHandler );
		
			my $pad_id = sprintf ("%8d", $id);
			$pad_id =~ tr/ /0/;
		
			my $file_path = $configs->{'gmentriespath'}."/$pad_id.cgi";
	
			if( $new_file && -e $file_path ){
				&$errHandler( 'Fatal Error, gm-counter likely to be disrupted. Please run '.
					'a Diagnostics & Repair.  File '.$file_path.' already exists.' );
			}

			$worked = _storeFileArray( fn=>$file_path, lines=>$lines, %params );
			chmod( 0666, $file_path );
		} else {
			#  no id passed
			&$errHandler( 'Invalid id passed to setEntry.' );
		}
	} else {
		#  bad data structure passed to array
		&$errHandler( 'Invalid Entry object given to setEntry.' );
	}

	return $worked;
}



## Add Entry Comment
#  Will store the given comment for given entry to wherever they may be stored ...
# ARG id  = entry number, numeric, never 0
# ARG name = commenter's name alphanumeric
# ARG ip = in the form of xxx.xxx.xxx.xxx
# ARG email = in the form of user@email.com. If not provided, left blank.
# ARG homepage = commenter's webpage in the form of http://www.site.com. If not provided, left blank.
# ARG weekday = of comment numeric (0-6, 0=Sunday, 1=Monday, etc.)
# ARG month = of comment numeric (1-12, no leading zeroes)
# ARG day = of comment numeric (1-31, no leading zeroes)
# ARG year = of comment numeric (format: yyyy)
# ARG hour = of comment numeric (1-12, no leading zeroes)
# ARG minute = of comment numeric (1-12, no leading zeroes)
# ARG second = of comment numeric (1-12, no leading zeroes)
# ARG ampm = either AM or PM
# ARG comment = The "main entry" text of each post. Single line breaks are replaced with a |*|, 
#		double line breaks with |*||*|. All of the text is presented in one wrapping line.
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::addEntryComment( id=>1, name=>'nobody', ... );
sub addEntryComment {
	my (%params) = @_;
	
	my $worked = 0; ## assume bad since getting val from file manipulator
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $id = $params{'id'} || 
		&$errHandler('Invalid id parameter passed to addEntryComment');

	if( $id ne Gm_Constants::EMPTY ){
		## we ain't gonna make assumptions about the id, so no test for all numbers, etc.
		## but no 0 id
		
		my %comment = ();
		## getting need info into a 'clean' hash, thats why we don't just stick params onto comments
		$comment{'name'} = $params{'name'};
		$comment{'ip'} = $params{'ip'};
		$comment{'email'} = $params{'email'};
		$comment{'homepage'} = $params{'homepage'};
		$comment{'weekday'} = $params{'weekday'};
		$comment{'month'} = $params{'month'};
		$comment{'day'} = $params{'day'};
		$comment{'year'} = $params{'year'};
		$comment{'hour'} = $params{'hour'};
		$comment{'minute'} = $params{'minute'};
		$comment{'second'} = $params{'second'};
		$comment{'ampm'} = $params{'ampm'};
		$comment{'comment'} = $params{'comment'};
	

		my $entry = getEntry( id=>$id, errHandler=>$errHandler );
		## update the comments array
		push( @{$entry->{'comments'}}, \%comment );
		## Update entry info with comments array size, not just incrementing blindly
		$entry->{'entryinfo'}{'commenttotal'} = scalar( @{$entry->{'comments'}} ); 
		
		## finally, saving the modified entry
		setEntry( entry=>$entry, errHandler=>$errHandler );
		
	} else {
		&$errHandler( 'Invalid id passed to getEntry.' );
	}
	
	
	return $worked;
}



## Get Counters
#  Will retrieve stats of gm from whereve they may be stored ...
#  NOTE that all values default to 0
#  A NOTE on counter format. The format of the counter files is: 
#   entrytotal = total number of entries posted
#   archivetotal = total number of entries not on front page
#   stayattopentry = entry# designated as "Stay At Top", marked 0 if there's no such thing
#   karmapos = total positive karma votes
#   karmaneg = total negative karma votes
#   commenttotal = total comments posted
#   opentotal = total number of open entries
#   closedtotal = total number of closed entries
# This format will remove order dependance and cut down on code bloat
# by allowing the use of looping to go over counters.
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: an hash ref to the configs, as defined by this subroutine
# USAGE: $gm_counters = Gm_Storage::getCounters(); 
# print $gm_counters->{'newentries'};  ## print number of new entries
## DEPRECATES gm_readcounter
sub getCounters {
	my (%params) = @_;
	
	my %gmfile = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE
	my $lines = _loadFileArray( fn=>"gm-counter.cgi", %params );
	
	## The format of the config files is: countername=countervalue
	# This format will remove order dependance and cut down on code bloat
	foreach my $line (@$lines){
		my ($key, $val) = split('=',$line,2); # only split into two fields
		unless( defined( $val ) ){
			$val = 0; # defaulting to 0
		}
		$gmfile{$key} = $val;
	}
	
#### SAVE THIS FOR CONVERTING OLD TEMPLATES TO NEW
# $newentrynumber = $entrycounters[0];
# $newarchivenumber = $entrycounters[1];
# $newstayattopnumber = $entrycounters[2];
# $newalltimepktotalnumber = $entrycounters[3];
# $newalltimenktotalnumber = $entrycounters[4];
# $newalltimecommentstotalnumber = $entrycounters[5];
# $newalltimeopenentriesnumber = $entrycounters[6];
# $newalltimeclosedentriesnumber = $entrycounters[7];

	return \%gmfile;
}


## Set Counters
#  Will store the counters to wherever they may be stored ...
# NOTE defaults empty values to 0
# ARG list => an ref to a hash that contains ALL the counters to store to a file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_counters = Gm_Storage::getCounters(); 
# $gm_counters->{'entrytotal'} = $gm_counters->{'entrytotal'}++; # adding one  
# Gm_Storage::setConfigs( list => $gm_counters ); #storing the change we made
## DEPRECATES gm_writecounter
sub setCounters {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $list = $params{'list'} || 
		&$errHandler('Invalid list parameter passed to setCounters');
	my $lines = [];
	
	## The format of the template files is: templatename=templatevalue
	# This format will remove order dependance and cut down on code bloat
	my $i = 0;
	my $val = Gm_Constants::EMPTY;
	foreach my $item (keys(%$list)){
		$val = defined( $list->{$item} ) ? $list->{$item} :  0; #default 0
		$lines->[$i] = $item.'='.$val;
		$i++;
	}

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-counter.cgi', lines=>$lines, %params );

	return $worked;
}


## Get Entry List
#  Will retrieve the master entry list information, listing of all entries
#  A NOTE on Entrylist format. The hash data contains:
#  id => the numerical id of entry, this is the key, with a value of a hash:
#   id => the numerical id of the entry (key of returned hash)(usually order in which entered, never 0)
#   author =>  entry author's name (must be alphanumeric)
#   subject => entry subject (must be alphanumeric)
#   created => CREATE Date of entry in the format of mm/dd/yy (does include leading zeros)
#   createt => CREATE Time of entry in the form of hh:mm [AM/PM] (does include leading zeros)
#   status => entry status: open/closed, either O or C
#   extended => is this an extended entry, either Y or N
#   music => current music of entry (well author really)
#   mood => current mood of entry (well author really)
#   emoticons => are emoticons enabled, yes or no
# TODO: STANDARDIZE WHEN Y OR N OR YES OR NO, AND STATUS OPEN OR NO (INSTEAD OF O OR C)
# This format does not use order dependance, the key of the returned hash are the 
# entery ids, numerical order indicates order of entry (i.e. 1 is first and so on ...)
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: a hash ref of the entries, as defined by this subroutine
#   the key is the unique entry id and each value is another hash, using the above labels
# USAGE: $gm_el = Gm_Storage::getEntrylist(); 
#  print $gm_el->{1}{subject};  ## print first entry subject
sub getEntrylist {
	my (%params) = @_;
	
	my %list = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE
	my $lines = _loadFileArray( fn=>"gm-entrylist.cgi", %params );
	
	# This format will remove order dependance and cut down on code bloat
	foreach my $line (@$lines){
	
		## TODO validate format, exit and err if bad
		# id|author|subject|created|createt|status|extended|music|mood|emoticons
		my ( $id, $author, $subject, $created, $createt, $status, $extended, $music, 
			$mood, $emoticons) = split ( "\\$DATA_DELIM", $line); ## ESCAPE DELIM

		$list{$id} = { id=>$id, author=>$author, subject=>$subject, created=>$created, 
			createt=>$createt, status=>$status, extended=>$extended, music=>$music, 
			mood=>$mood, emoticons=>$emoticons };
	}

	return \%list;
}


## Set Entrylist
#  Will store the entrylist to wherever they may be stored ...
# ARG list => a ref to an hash of hashes that contains ALL the Entrylist to store to a file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# TODO: STANDARDIZE WHEN Y OR N OR YES OR NO, AND STATUS OPEN OR NO (INSTEAD OF O OR C)
# Return: 1 if worked, 0 if error
# USAGE: %gm_e = ();  
#  Gm_Storage::setEntrylist( list=>\%gm_e ); #erasing the entrylist
sub setEntrylist {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $thelist = $params{'list'} || 
		&$errHandler('Invalid list parameter passed to setEntrylist');
	my $lines = [];
	
	# id|author|subject|created|createt|status|extended|music|mood|emoticons
	# This format will remove order dependance and cut down on code bloat
	my $i = 0;
	my ( $id, $author, $subject, $created, $createt, $status, $extended, $music, 
			$mood, $emoticons);
	## Sort the keys (ids) into ascending numerical order 1, 2, 3, ...	
	foreach my $conf ( sort { $b <=> $a } keys(%$thelist)){
		$id = $thelist->{$conf}{'id'};
		$author = $thelist->{$conf}{'author'};
		$subject = $thelist->{$conf}{'subject'};		
		$created = $thelist->{$conf}{'created'};	
		$createt = $thelist->{$conf}{'createt'};
		$status = defined( $thelist->{$conf}{'status'} ) ? $thelist->{$conf}{'status'} : 'O';
		$extended = defined( $thelist->{$conf}{'extended'} ) ? $thelist->{$conf}{'extended'} : 'N';
		$music = defined( $thelist->{$conf}{'music'} ) ? $thelist->{$conf}{'music'} : Gm_Constants::EMPTY;
		$mood = defined( $thelist->{$conf}{'mood'} ) ? $thelist->{$conf}{'mood'} : Gm_Constants::EMPTY;
		$emoticons = defined( $thelist->{$conf}{'emoticons'} ) ? $thelist->{$conf}{'emoticons'} : Gm_Constants::NO;


		$lines->[$i] = $id.$DATA_DELIM.$author.$DATA_DELIM.$subject.$DATA_DELIM.$created.
			$DATA_DELIM.$createt.$DATA_DELIM.$status.$DATA_DELIM.$extended.$DATA_DELIM.
			$music.$DATA_DELIM.$mood.$DATA_DELIM.$emoticons;
		$i++;
	}

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-entrylist.cgi', lines=>$lines, %params );

	return $worked;
}


## Add Entrylist
#  Will store the given entry information to wherever they may be stored ...
#   id = the numerical id of the entry (key of returned hash)(usually order in which entered, never 0)
#   author =  entry author's name (must be alphanumeric)
#   subject = entry subject (must be alphanumeric)
#   created = CREATE Date of entry in the format of mm/dd/yy (does include leading zeros)
#   createt = CREATE Time of entry in the form of hh:mm [AM/PM] (does include leading zeros)
#   status = entry status: open/closed, either O or C
#   extended = is this an extended entry, either Y or N
#   music = current music of entry (well author really)
#   mood = current mood of entry (well author really)
#   emoticons = are emoticons enabled, yes or no
# TODO: STANDARDIZE WHEN Y OR N OR YES OR NO, AND STATUS OPEN OR NO (INSTEAD OF O OR C)
# ALSO: EMOTICONS should be in the entry listing, why in summary?
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::addEntrylist( author=>'Alice', subject=>...
sub addEntrylist {
	my (%params) = @_;
	
	my $worked = 1;
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	
	# TODO: VALIDATE THAT GIVEN GOOD AUTHOR SUBJECT
	my $id = $params{'id'};  ## THIS SHOULDN"T HAVE TO BE PASSED IN
	my $author = $params{'author'};
	my $subject = $params{'subject'};
	my $created = $params{'created'}; ## THESE CAN PROBABLY BE SET HERE
	my $createt = $params{'createt'}; ## THIS CAN PROBABLY BE SET HERE
	
	if( !defined( $id ) || !defined( $author ) || !defined( $subject ) ){
		&$errHandler( 'Please provide a valid id, author, and subject to add an entry.' );
		$worked = 0;
	} else {	
		my $status = defined( $params{'status'} ) ? $params{'status'} : 'O';
		my $extended = defined( $params{'extended'} ) ? $params{'extended'} : 'N';
		my $music = defined( $params{'music'} ) ? $params{'music'} : Gm_Constants::EMPTY;
		my $mood = defined( $params{'mood'} ) ? $params{'mood'} : Gm_Constants::EMPTY;
		my $emoticons = defined( $params{'emoticons'} ) ? $params{'emoticons'} : Gm_Constants::NO;
	
		my $line = $id.$DATA_DELIM.$author.$DATA_DELIM.$subject.$DATA_DELIM.$created.
			$DATA_DELIM.$createt.$DATA_DELIM.$status.$DATA_DELIM.$extended.$DATA_DELIM.
			$music.$DATA_DELIM.$mood.$DATA_DELIM.$emoticons;
		$worked = _addFileLine( fn=>'gm-entrylist.cgi', line=>$line, %params );
	}
	return $worked;
}


## Update Entry List
#  Will update the entrylist  information associated with the given key (in which
# case is the id field.  Note that only changes should be passed
# to this function.  Any passed in data will be assumed to be valid
# (so don't pass in blank values if you do not want that information updated,
# because it will update with blank then).
# ARG key = id of the entryllist line.
# (opt) ARG author =  entry author's name (must be alphanumeric)
# (opt) ARG subject = entry subject (must be alphanumeric)
# (opt) ARG created = CREATE Date of entry in the format of mm/dd/yy (does include leading zeros)
# (opt) ARG createt = CREATE Time of entry in the form of hh:mm [AM/PM] (does include leading zeros)
# (opt) ARG status = entry status: open/closed, either O or C
# (opt) ARG extended = is this an extended entry, either Y or N
# (opt) ARG music = current music of entry (well author really)
# (opt) ARG mood = current mood of entry (well author really)
# (opt) ARG emoticons = are emoticons enabled, yes or no
# TODO: STANDARDIZE WHEN Y OR N OR YES OR NO, AND STATUS OPEN OR NO (INSTEAD OF O OR C)
# ALSO: EMOTICONS should be in the entry listing, why in summary?
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::updateEntrylist( key=>'1', subject=>'Test' ); # sets entry one's subject
sub updateEntrylist {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $worked = 1;
	my $key = $params{'key'};

	## Checking for key
	if( !defined( $key )){
		&$errHandler( 'Please provide a valid entrylist id to update.' );
		$worked = 0;
	} else {
		my $list = getEntrylist();
		if ( exists( $list->{$key}) ) {
			## we are ready to go
			# We are blending the two hashes, the passed in parameters are 'overwriting' the orig	
			# Extra params, such as errHandler, will be ignored by the setting program
			$list->{$key} = {%{$list->{$key}},%params};
			
			$worked = setEntrylist( list=>$list, %params );
		} else {
			&$errHandler( 'Entrylist to update does not exist.' );
		}
	}

	return $worked;
}


## Get Author List
#  Will retrieve Authos from wherever they may be stored ...
#  A NOTE on Authors format. The format of the gm-authors.cgi file is: 
#   author =  author's name (key of returned hash (case sensitive))
#   password = author's password (crypted)
#   email = author's email
#   homepage = author's homepage
#   created = CREATE Date of the author 
#   posttotal = total number of postings by this author
#   postnew = can this author make new posts Y or N
#   editentries = can this author edit entries Y or N
#   editconfigs = can this author edit configs Y or N
#   edittemplates = can this author edit templates Y or N
#   editauthors = can this author edit other authors Y or N
#   rebuild = can this author rebuild files Y or N
#   viewcplog = can this author view the control panel Y or N
#   bookmarklets = can this author use bookmarklets Y or N
#   upload = can this author upload files Y or N
#   viewadmin = can this author access the admin scene (gm.cgi) Y or N
#
# TODO: STANDARDIZE ON 'YES/NO' OR 'Y/N' or '1/0' (true/false) seems best
# 
# This format does not use order dependance, the key of the returned hash are the 
# author names (case sensitive)
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: a hash ref of the authors, as defined by this subroutine
#   the key is the unique author name (should be id?) and each value is another hash, using the above labels
# USAGE: $gm_as = Gm_Storage::getAuthors(); 
#  print $gm_as->{Alice}{password};  ## print Alice's pasword
sub getAuthors {
	my (%params) = @_;
	
	my %list = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE
	my $lines = _loadFileArray( fn=>"gm-authors.cgi", %params );
	
	# This format will remove order dependance and cut down on code bloat
	foreach my $line (@$lines){
	
		## TODO validate format, exit and err if bad
		# author|password|email|homepage|created|posttotal|postnew|editentries|editconfigs|edittemplates|
		#  editauthors|rebuild|viewcplog|bookmarklets|upload|admin
		my ($author, $password, $email, $homepage, $created, $posttotal, $postnew, 
			$editentries, $editconfigs, $edittemplates, $editauthors, $rebuild, 
			$viewcplog, $bookmarklets, $upload, $viewadmin) 
			= split ( "\\$DATA_DELIM", $line); ## ESCAPE DELIM

		$list{$author} = { author=>$author, password=>$password, email=>$email, 
			homepage=>$homepage, created=>$created, posttotal=>$posttotal, postnew=>$postnew, 
			editentries=>$editentries, editconfigs=>$editconfigs, edittemplates=>$edittemplates, 
			editauthors=>$editauthors, rebuild=>$rebuild, viewcplog=>$viewcplog, 
			bookmarklets=>$bookmarklets, upload=>$upload, viewadmin=>$viewadmin };
	}

	return \%list;
}


## Set Authors
#  Will store the authors to wherever they may be stored ...
# ARG list => a ref to an hash of hashes that contains ALL the Banlist to store to a file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: %gm_a = {};  
#  Gm_Storage::setAuthors( list=>\%gm_a ); #erasing the authors
sub setAuthors {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $thelist = $params{'list'} || 
		&$errHandler('Invalid list parameter passed to setAuthors');
	my $lines = [];
	
	# author|password|email|homepage|created|posttotal|postnew|editentries|editconfigs|edittemplates|
	#  editauthors|rebuild|viewcplog|bookmarklets|upload|admin
	# This format will remove order dependance and cut down on code bloat
	my $i = 0;
		my ($author, $password, $email, $homepage, $created, $posttotal, $postnew, 
			$editentries, $editconfigs, $edittemplates, $editauthors, $rebuild, 
			$viewcplog, $bookmarklets, $upload, $viewadmin);
	foreach my $conf (keys(%$thelist)){
		$author = $thelist->{$conf}{'author'};
		$password = $thelist->{$conf}{'password'};
		$email = defined( $thelist->{$conf}{'email'} ) ? $thelist->{$conf}{'email'} : Gm_Constants::EMPTY;
		$homepage = defined( $thelist->{$conf}{'homepage'} ) ? $thelist->{$conf}{'homepage'} : Gm_Constants::EMPTY;
		$created = defined( $thelist->{$conf}{'created'} ) ? $thelist->{$conf}{'created'} : Gm_Constants::EMPTY;
		$posttotal = defined( $thelist->{$conf}{'posttotal'} ) ? $thelist->{$conf}{'posttotal'} : Gm_Constants::EMPTY;
		$postnew = defined( $thelist->{$conf}{'postnew'} ) ? $thelist->{$conf}{'postnew'} : Gm_Constants::EMPTY;
		$editentries = defined( $thelist->{$conf}{'editentries'} ) ? $thelist->{$conf}{'editentries'} : Gm_Constants::EMPTY;
		$editconfigs = defined( $thelist->{$conf}{'editconfigs'} ) ? $thelist->{$conf}{'editconfigs'} : Gm_Constants::EMPTY;
		$edittemplates = defined( $thelist->{$conf}{'edittemplates'} ) ? $thelist->{$conf}{'edittemplates'} : Gm_Constants::EMPTY;
		$editauthors = defined( $thelist->{$conf}{'editauthors'} ) ? $thelist->{$conf}{'editauthors'} : Gm_Constants::EMPTY;
		$rebuild = defined( $thelist->{$conf}{'rebuild'} ) ? $thelist->{$conf}{'rebuild'} : Gm_Constants::EMPTY;
		$viewcplog = defined( $thelist->{$conf}{'viewcplog'} ) ? $thelist->{$conf}{'viewcplog'} : Gm_Constants::EMPTY;
		$bookmarklets = defined( $thelist->{$conf}{'bookmarklets'} ) ? $thelist->{$conf}{'bookmarklets'} : Gm_Constants::EMPTY;
		$upload = defined( $thelist->{$conf}{'upload'} ) ? $thelist->{$conf}{'upload'} : Gm_Constants::EMPTY;
		$viewadmin = defined( $thelist->{$conf}{'viewadmin'} ) ? $thelist->{$conf}{'viewadmin'} : Gm_Constants::EMPTY;

		$lines->[$i] = $author.$DATA_DELIM.$password.$DATA_DELIM.$email.$DATA_DELIM.$homepage.
		$DATA_DELIM.$created.$DATA_DELIM.$posttotal.$DATA_DELIM.$postnew.$DATA_DELIM.
		$editentries.$DATA_DELIM.$editconfigs.$DATA_DELIM.$edittemplates.$DATA_DELIM.$editauthors.
		$DATA_DELIM.$rebuild.$DATA_DELIM.$viewcplog.$DATA_DELIM.$bookmarklets.$DATA_DELIM.
		$upload.$DATA_DELIM.$viewadmin;
		$i++;
	}

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-authors.cgi', lines=>$lines, %params );

	return $worked;
}


## Add Author
#  Will store the given author information to wherever they may be stored ...
# ARG author =  author's name (key of returned hash (case sensitive))
# ARG password = author's password (crypted)
# ARG email = author's email
# ARG homepage = author's homepage
# ARG created = CREATE Date of the author 
# ARG posttotal = total number of postings by this author
# ARG postnew = can this author make new posts Y or N
# ARG editentries = can this author edit entries Y or N
# ARG editconfigs = can this author edit configs Y or N
# ARG edittemplates = can this author edit templates Y or N
# ARG editauthors = can this author edit other authors Y or N
# ARG rebuild = can this author rebuild files Y or N
# ARG viewcplog = can this author view the control panel Y or N
# ARG bookmarklets = can this author use bookmarklets Y or N
# ARG upload = can this author upload files Y or N
# ARG viewadmin = can this author access the admin scene (gm.cgi) Y or N
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::addAuthor( author=>'Alice', password=>...
sub addAuthor {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $author = $params{'author'} || 
		&$errHandler('Invalid author parameter passed to addAuthor');
	my $password = $params{'password'} || 
		&$errHandler('Invalid password parameter passed to addAuthor');
	my $email = defined( $params{'email'} ) ? $params{'email'} : Gm_Constants::EMPTY;
	my $homepage = defined( $params{'homepage'} ) ? $params{'homepage'} : Gm_Constants::EMPTY;
	my $created = defined( $params{'created'} ) ? $params{'created'} : Gm_Constants::EMPTY;
	my $posttotal = defined( $params{'posttotal'} ) ? $params{'posttotal'} : Gm_Constants::EMPTY;
	my $postnew = defined( $params{'postnew'} ) ? $params{'postnew'} : Gm_Constants::EMPTY;
	my $editentries = defined( $params{'editentries'} ) ? $params{'editentries'} : Gm_Constants::EMPTY;
	my $editconfigs = defined( $params{'editconfigs'} ) ? $params{'editconfigs'} : Gm_Constants::EMPTY;
	my $edittemplates = defined( $params{'edittemplates'} ) ? $params{'edittemplates'} : Gm_Constants::EMPTY;
	my $editauthors = defined( $params{'editauthors'} ) ? $params{'editauthors'} : Gm_Constants::EMPTY;
	my $rebuild = defined( $params{'rebuild'} ) ? $params{'rebuild'} : Gm_Constants::EMPTY;
	my $viewcplog = defined( $params{'viewcplog'} ) ? $params{'viewcplog'} : Gm_Constants::EMPTY;
	my $bookmarklets = defined( $params{'bookmarklets'} ) ? $params{'bookmarklets'} : Gm_Constants::EMPTY;
	my $upload = defined( $params{'upload'} ) ? $params{'upload'} : Gm_Constants::EMPTY;
	my $viewadmin = defined( $params{'viewadmin'} ) ? $params{'viewadmin'} : Gm_Constants::EMPTY;

	my $line = $author.$DATA_DELIM.$password.$DATA_DELIM.$email.$DATA_DELIM.$homepage.
		$DATA_DELIM.$created.$DATA_DELIM.$posttotal.$DATA_DELIM.$postnew.$DATA_DELIM.
		$editentries.$DATA_DELIM.$editconfigs.$DATA_DELIM.$edittemplates.$DATA_DELIM.$editauthors.
		$DATA_DELIM.$rebuild.$DATA_DELIM.$viewcplog.$DATA_DELIM.$bookmarklets.$DATA_DELIM.
		$upload.$DATA_DELIM.$viewadmin;
	my $worked = _addFileLine( fn=>'gm-authors.cgi', line=>$line, %params );

	return $worked;
}


## Delete Author
#  Will delete the given author from wherever they may be stored ...
# ARG author => the name of an author to delete
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::deleteAuthor( author=>'Alice' );
sub deleteAuthor {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $worked = 1;
	my $author = defined( $params{'author'} ) ? $params{'author'} :  
		&$errHandler('Invalid author parameter passed to deleteAuthor');
	
	if( $author ne Gm_Constants::EMPTY ){
		my $authorlist = getAuthors();
		if( exists( $authorlist->{$author} )){
			delete( $authorlist->{$author} );
			$worked = setAuthors( list=>$authorlist, %params );
		}
	}

	return $worked;
}


## Update Author
#  Will the author information associated with the given key (in which
# case is the author name field.  Note that only changes should be passed
# to this function.  Any passed in data will be assumed to be valid
# (so don't pass in blank values if you do not want that information updated,
# because it will update with blank then)
# ARG key = original author's name.  This means that if someone changes their name
#  this field should be given the original name.
# (opt) ARG author =  author's name (key of returned hash (case sensitive))
# (opt) ARG password = author's password (crypted)
# (opt) ARG email = author's email
# (opt) ARG homepage = author's homepage
# (opt) ARG created = CREATE Date of the author 
# (opt) ARG posttotal = total number of postings by this author
# (opt) ARG postnew = can this author make new posts Y or N
# (opt) ARG editentries = can this author edit entries Y or N
# (opt) ARG editconfigs = can this author edit configs Y or N
# (opt) ARG edittemplates = can this author edit templates Y or N
# (opt) ARG editauthors = can this author edit other authors Y or N
# (opt) ARG rebuild = can this author rebuild files Y or N
# (opt) ARG viewcplog = can this author view the control panel Y or N
# (opt) ARG bookmarklets = can this author use bookmarklets Y or N
# (opt) ARG upload = can this author upload files Y or N
# (opt) ARG viewadmin = can this author access the admin scene (gm.cgi) Y or N
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::updateAuthor( key=>'Alice', email=>'foo' ); # sets Alice's email to foo
sub updateAuthor {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $worked = 1;
	my $key = $params{'key'};  ## err checking below

	## Checking for key
	if( !defined( $key )){
		&$errHandler( 'Please provide a valid author key to update.' );
	} else {
		my $authorlist = getAuthors();
		if ( exists( $authorlist->{$key}) ) {
			## we are ready to go
			# We are blending the two hashes, the passed in parameters are 'overwriting' the orig		
			$authorlist->{$key} = {%{$authorlist->{$key}},%params};
			
			$worked = setAuthors( list=>$authorlist, %params );
		} else {
			&$errHandler( 'Author to update does not exist.' );
		}
	}

	return $worked;
}


## Get Ban List
#  Will retrieve Banlist from wherever they may be stored ...
#  A NOTE on Banlist format. The format of the Banlist files is: 
#   ip = ip address of machine to ban (key of returned hash)
#   host = the hostname of the banned ip (currently not used)
#   label = an optional label to describe the banned ip
# This format does not use order dependance, the key of the returned hash are the 
# unique ip's.
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: a hash ref of the banlist, as defined by this subroutine
#   the key is the unique ip and each value is another hash, using the above labels
# USAGE: $gm_bl = Gm_Storage::getBanlist(); 
# print $gmbanlist->{'0.0.0.0'}{'label'} # prints the label for ip 0.0.0.0
sub getBanlist {
	my (%params) = @_;
	
	my %gmbanlist = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE
	my $lines = _loadFileArray( fn=>"gm-banlist.cgi", %params );
	
	# This format will remove order dependance and cut down on code bloat
	foreach my $line (@$lines){
		## todo validate format, exit and err if bad
		my ($ip, $iphost, $label) = split ( "\\$DATA_DELIM", $line); ## ESCAPE DELIM

		$gmbanlist{$ip} = { ip=>$ip, host=>$iphost, label=>$label};
	}

	return \%gmbanlist;
}


## Set Ban List
#  Will store the Banlist to wherever they may be stored ...
# ARG list => an ref to an array that contains ALL the Banlist to store to a file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: %gm_bl = {};  
# Gm_Storage::setBanlist( list=>\%gm_bl ); #erasing out the log
sub setBanlist {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $banlist = $params{'list'} || 
		&$errHandler('Invalid list parameter passed to setBanlist');
	my $lines = [];
	
	## The format of the template files is: ip|host|label
	# This format will remove order dependance and cut down on code bloat
	my $i = 0;
	my $label = Gm_Constants::EMPTY;
	foreach my $conf (keys(%$banlist)){
		$label = defined( $banlist->{$conf}{'label'} ) ? $banlist->{$conf}{'label'} :  Gm_Constants::EMPTY;
		$lines->[$i] = $banlist->{$conf}{'ip'}.$DATA_DELIM.$banlist->{$conf}{'host'}.$DATA_DELIM.$label;
		$i++;
	}

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-banlist.cgi', lines=>$lines, %params );

	return $worked;
}


## Add Ban List
#  Will store the given ban information to wherever they may be stored ...
#  This should be called addBanItem or something
# ARG ip => an ip to ban (NOTE this should be unique)
# ARG host => a host to ban
# (opt) ARG label => an optional label, blank if not given
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: 1 if worked, 0 if error
# USAGE: Gm_Storage::addBanlist( ip=>'0.0.0.0', host=>'nobody' );
sub addBanlist {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $worked = 0; ## default to false

	my $ip = defined( $params{'ip'} ) ? $params{'ip'} : 
		&$errHandler('Invalid ip parameter passed to addBanlist');
	my $host = defined( $params{'host'} ) ? $params{'host'} : Gm_Constants::EMPTY;

	if( $ip ne Gm_Constants::EMPTY && $host ne Gm_Constants::EMPTY ){	
		my $label = defined( $params{'label'} ) ? $params{'label'} :  Gm_Constants::EMPTY;
	
		my $line = $ip.$DATA_DELIM.$host.$DATA_DELIM.$label;
		
		$worked = _addFileLine( fn=>'gm-banlist.cgi', line=>$line, %params );
	} else {
		&$errHandler( 'IP and Host must be suppled for addBanlist.' );
	}

	return $worked;
}


## Delete Ban List
#  Will delete the given ban information from wherever they may be stored ...
# ARG ip => an ip to ban (NOTE this should be unique)
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# Return: a hashref to a hash containing the deleted ip, see getBanList for more info on hash
# USAGE: Gm_Storage::deleteBanlist( ip=>'0.0.0.0' );
sub deleteBanlist {
	my (%params) = @_;
	
	my $deleted = {};
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $ip = defined( $params{'ip'} ) ? $params{'ip'} : 
		&$errHandler('Invalid ip parameter passed to deleteBanlist');
	
	if( $ip ne Gm_Constants::EMPTY ){
		my $banlist = getBanlist();
		if( exists( $banlist->{$ip} )){
			$deleted = $banlist->{$ip};
			delete( $banlist->{$ip} );
			setBanlist( list=>$banlist, %params );
		}
	}

	return $deleted;
}


## Get Control Panel Log
#  Will retrieve cplog from wherever they may be stored ...
#  A NOTE on cplog format. The format of the cplog files is: 
#   logline
# This format uses order dependance, but this is fine for the log.  no one needs
# to modify existing entries.
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: an array ref to the cplog, as defined by this subroutine
# USAGE: $gm_confs = Gm_Storage::getCplog(); 
# print $gm_confs->[0];  ## print first log entry
sub getCplog {
	my (%params) = @_;
	
	my %gmconfigs = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE
	my $file = _loadFileArray( fn=>"gm-cplog.cgi", %params );

	return $file;
}


## Set Control Panel Log
#  Will store the cplog to wherever they may be stored ...
# ARG log => an ref to an array that contains ALL the log to store to a file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_cpl = [];  
# Gm_Storage::setCplog( log=>$gm_cpl ); #erasing out the log
sub setCplog {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $lines = $params{'log'} || 
		&$errHandler('Invalid log parameter passed to setCplog');

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-cplog.cgi', lines=>$lines, %params );

	return $worked;
}


## add Log Message
#  Will enter a log item with the text given, NOTE adds newline
# TODO INTEGRATE LOG CHECKING INTO THIS TO REMOVE CHECKS FOR IF( LOG )
# ARG msg => the message to log
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURNS: 1 if worked, 0 if failed to open for some reason
# USAGE: Gm_Storage::addLogMessage( msg=>"logging this" );
# DEPRECATES: opening the file gm-cplog.cgi manually NO TOUCH
sub addLogMessage {	
	my (%params) = @_;
	
	my $message = defined( $params{'msg'} ) ? $params{'msg'} : 'no message ...';
	## not going to die with message here because logging isn't mission critical?

	my $line = $message;

	my $worked = _addFileLine( fn=>'gm-cplog.cgi', line=>$line, %params );

	return $worked;
}


## Get Configs
#  Will retrieve configs from whereve they may be stored ...
#  A NOTE on config format. The format of the config files is: 
#   configname=configvalue
# This format will remove order dependance and cut down on code bloat
# by allowing the use of looping to go over templates.
# NOTE that all configs should start with 'gm' so that they can be
# identified with mixed with other configs (such as mods).
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: an hash ref to the configs, as defined by this subroutine
# USAGE: $gm_confs = Gm_Storage::getConfigs(); 
# print $gm_confs->{'gmlogpath'};  ## print log path config
#	DEPRACATES: gm_readconfig
sub getConfigs {
	my (%params) = @_;
	
	my %gmconfigs = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ... IS THIS POSSIBLE HERE?
	my $lines = _loadFileArray( fn=>'gm-config.cgi', %params );
	
	## The format of the config files is: configname=configvalue
	# This format will remove order dependance and cut down on code bloat
	foreach my $line (@$lines){
		my ($key, $val) = split('=',$line,2); # only split into two fields
		$val = defined( $val ) ? $val : Gm_Constants::EMPTY;
		$gmconfigs{$key} = $val;
	}
	
	return \%gmconfigs;
}



## Set Configs
#  Will store the configs to wherever they may be stored ...
# ARG configs => an ref to a hash that contains ALL the configs to store to a file
# TODO: RENAME ARGUMENT TO LIST, PER CONVENTION OF OTHER SETTERS
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_confs = Gm_Storage::getConfigs(); 
# $gm_confs->{'logpath'} = 'foo...';  
# Gm_Storage::setConfigs( configs => $gm_confs ); #storing the change we made
## DEPRECATES writeconfig
sub setConfigs {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $gmconfigs = $params{'configs'} || 
		&$errHandler('Invalid configs parameter passed to setConfigs');
	my $lines = [];
	
	## The format of the template files is: templatename=templatevalue
	# This format will remove order dependance and cut down on code bloat
	my $i = 0;
	my $val = Gm_Constants::EMPTY;
	foreach my $conf (keys(%$gmconfigs)){
		$val = defined( $gmconfigs->{$conf} ) ? $gmconfigs->{$conf} :  Gm_Constants::EMPTY;
		$lines->[$i] = $conf.'='.$val;
		$i++;
	}

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-config.cgi', lines=>$lines, %params );

	return $worked;
}

## NEED an updateConfigs


## Get Templates
#  Will retrieve templates from whereve they may be stored ...
#  A NOTE on template format. The format of the template files is: 
#   templatename=templatevalue
# This format will remove order dependance and cut down on code bloat
# by allowing the use of looping to go over templates.
#  NOTE that all templates should end with 'template' so that they can be
# identified with mixed with form variables.
#  NOTE that is a template is required to be made websafe, that that should be 
# only be done with the template will be displayed as html, not by default!
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: an hash ref to the templates, as defined by this subroutine
# USAGE: $gm_tems = Gm_Storage::getTemplates(); 
# print $gm_tems->{'gmindextemplate'};  ## print gmindextemplate template
#	DEPRACATES: gm_readtemplates
sub getTemplates {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my %gmtemplates = ();

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $lines = _loadFileArray( fn=>"gm-templates.cgi", %params );
	
	## The format of the template files is: templatename=templatevalue
	# This format will remove order dependance and cut down on code bloat
	foreach my $line (@$lines){
		my ($key, $val) = split('=',$line,2); # only split into two fields
		$gmtemplates{$key} = $val;
	}

	return \%gmtemplates;
}

## Set Templates
#  Will store the templates to wherever they may be stored ...
# ARG templates => an ref to a hash that contains ALL the templates to store to a file
# TODO: RENAME ARGUMENT TO LIST, PER CONVENTION OF OTHER SETTERS
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_tems = Gm_Storage::getTemplates(); 
# $gm_tems->{'gmindextemplate'} = 'foo...';  
# Gm_Storage::setTemplates( templates => $gm_tems ); #storing the change we made
sub setTemplates {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $gmtemplates = $params{'templates'} || 
		&$errHandler('Invalid templates parameter passed to setTemplates');
	my $lines = [];
	
	## The format of the template files is: templatename=templatevalue
	# This format will remove order dependance and cut down on code bloat
	my $i = 0;
	my $val = Gm_Constants::EMPTY;
	foreach my $templ (keys(%$gmtemplates)){
		$val = defined( $gmtemplates->{$templ} ) ? $gmtemplates->{$templ} :  Gm_Constants::EMPTY;
		$lines->[$i] = $templ.'='.$val;
		$i++;
	}

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>'gm-templates.cgi', lines=>$lines, %params );

	return $worked;
}

## Get File
#  Will retrieve the contents in the given file location
#  NOTE that this is clearly file based, and should never be used when
#  other Storage methods will suffice.
# ARG loc => the location of where to save the file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# (opt) ARG rel => if this is a local file that can use a relative path
# RETURN: 1 if worked, 0 if error
# USAGE: Gm_Storage::getFile( loc=>'some_connectedfile' ); 
sub readFile {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $file_location = $params{'loc'} || 
		&$errHandler('Invalid loc parameter passed to getFile');

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $lines = _loadFileArray( fn=>$file_location, %params );

	return $lines;
}

## Save File
#  Will save the given content in the given file location
#  NOTE that this is clearly file based, and should never be used when
#  other Storage methods will suffice.
# ARG loc => the location of where to save the file
# ARG content => an ref to an array that contains the data to save to the file
# (opt) ARG new => signify whether you are overwriting a file or making a new one,
#  if you don't specify new, and the file doesn't exist, it will generate an error
# (opt) ARG ch_mod => the value to chmod the file to
# (opt) ARG rel => if this is a local file that can use a relative path
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_cpl = [];  
# Gm_Storage::saveFile( loc=>'/tmp/fubar.txt', content=>$gm_cpl ); 
sub saveFile {
	my (%params) = @_;
	
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $file_location = $params{'loc'} || 
		&$errHandler('Invalid loc parameter passed to saveFile');
#	&Gm_Trace::Trace(level => 3, msg => "inside saveFile[4.3][$file_location]");
	my $lines = $params{'content'} || 
		&$errHandler('Invalid content parameter passed to saveFile');
	my $change_mode = $params{'ch_mod'} || Gm_Constants::EMPTY;

	## TODO USE CONFIGS SO THAT WE HAVE THE FULLY QUALIFIED PATH HERE ...
	my $worked = _storeFileArray( fn=>$file_location, lines=>$lines, external=>1, %params );
	if( $worked && $change_mode ){	
		## so silly, can't cast to a number
		chmod( oct($change_mode), $file_location );
	}

	return $worked;
}

#######################################################
############ PRIVATE FUNCTIONS ########################
#######################################################

## load File Array (private)
#  Will read a file and plop it into an array
# ARG fn => the filename of the file to open
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: an array ref to the file, each array item is a line in the orginal file
# USAGE: $gm_tems = _loadFileArray(fn=>'gm-templates.cgi'); print $gm_tems->[0]; ## print first template
sub _loadFileArray {
	my (%params) = @_;
	
	## Loading up vars from params
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $filename = $params{'fn'} ? $params{'fn'} : 
		&$errHandler('Invalid fn parameter passed to _loadFileArray');
	my $relPath = $params{'rel'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;	

	if( Gm_Security::hackClTest( $filename, $relPath ) ){
		&$errHandler('We don\'t take kindly to that sort of activity here. '.
		'Your attempt to break the script has been logged and the administrators have '.
		'been notified. <br>');
		## TODO MAKE UTIL HACKNOTIFY FUNCTION
	}

	my @filearray = (); #init to empty
	
	if( -e $filename ){
		my @gmtemplates = ();
		## TODO USE PROPER FILE LOCKING
		# We are only reading, this had benefit of defeating pipe attacks as well
		## also do: open(my $FILE,"<$filename")
		my $worked = open (THEFILE, "<$filename");
		
		if( $worked ){ 		
			@filearray = <THEFILE>;
			close (THEFILE);
	
			#Converting newlines and cleaning end of lines
			foreach my $line (@filearray) {
				chomp($line);
				## TODO Makes this a Util function or at least make it so the 
				#the newline replace is constant
				$line =~ s/\|\*\|/\n/g;
			}
		} else {
			&$errHandler('Can\'t read file "'.$filename.'".  Please make sure that the file '.
			'is CHMODed to 666 and is in the same place as all your other Greymatter CGI files; '.
			'also try running Diagnostics & Repair from the Configuration screen.');
		}
	
	} else {
		# executing error handler
		&$errHandler( 'The file "'.$filename.'" doesn\'t seem to exist.  Please check that '.
		'your files are in the correct location and that GreyMatter is configured '.
		'correctly.');
	}

	return \@filearray;
}


## store File Array (private)
#  Will take an array ref and save to file
# ARG fn => the filename of the file to open
# (opt) ARG new => signify whether you are overwriting a file or making a new one,
#  if you don't specify new, and the file doesn't exist, it will generate an error
# (opt) external => signify whether newlines should NOT be converted to the GM
#  internal newline |*|
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_tems = _storeFileArray(fn=>'gm-templates.cgi', lines=>$arry_ref); 
sub _storeFileArray {
	my (%params) = @_;
	
	## Loading up vars from params
	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;	
	my $filename = $params{'fn'} ? $params{'fn'} : 
		&$errHandler('Invalid fn parameter passed to _storeFileArray');
	my $lines = $params{'lines'} || 
		&$errHandler('Invalid lines parameter passed to _storeFileArray');
	my $createFile = $params{'new'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;		
	my $externalFile = $params{'external'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;
	my $relPath = $params{'rel'} ? Gm_Constants::TRUE : Gm_Constants::FALSE;
		
	if( Gm_Security::hackClTest( $filename, $relPath ) ){
		&$errHandler('We don\'t take kindly to that sort of activity here. '.
		'Your attempt to break the script has been logged and the administrators have '.
		'been notified. <br>');
		## TODO MAKE UTIL HACKNOTIFY FUNCTION
	}
	
	my $worked = 1; # init to worked
	
	## If we aren't creating a file, we need to check that file exists, and error if not
	unless( $createFile ){
		unless( -e $filename ){
			# executing error handler
			&$errHandler( 'The file "'.$filename.'" doesn\'t seem to exist.  Please check that '.
			'your files are in the correct location and that GreyMatter is configured '.
			'correctly.');
			$worked = 0;
		}
	}

	if( $worked ){
		my $oneLine = Gm_Constants::EMPTY;
		if( $externalFile ){
			$oneLine = join( "\n", @$lines );
		} else {
			foreach my $line (@$lines) {
				## TODO Makes this a Util function or at least make it so the 
				#the newline replace is a constant
				$line =~ s(\n)(\|\*\|)g;
				$oneLine = $oneLine."$line\n";
			}
		}
	
		## TODO USE PROPER FILE LOCKING
		## also do: open(my $FILE,">$filename")
		$worked = open (THEFILE, ">$filename");
		if( $worked ){
			print THEFILE $oneLine;
			close (THEFILE);
			# Done saving to file			
		} else {
			## TODO: WE CAN TEST FOR WRITEABLILITY, DO SO FOR BETTER ERROR MESSAGE
			&$errHandler('Can\'t save the file "'.$filename.'".  Please make sure that directory to save the file '.
			'is CHMODed to 777 and that the file is CHMODed to 666.  Also try running Diagnostics & Repair '.
			'from the Configuration screen.');
			$worked = 0;
		}
	}		

	return $worked;
}


## add File Line
#  Will add the given line to the given file, NOTE adds newline
# TODO INTEGRATE LOG CHECKING INTO THIS TO REMOVE CHECKS FOR IF( LOG )
#  Will take an array ref and save to file
# ARG fn => the filename of the file to open
# ARG line => the line to append to the end of the file
# (opt) ARG errHandler => an error handler that should take an error message as an argument
# RETURN: 1 if worked, 0 if error
# USAGE: $gm_tems = _storeFileArray(fn=>'gm-templates.cgi', lines=>$arry_ref); 
sub _addFileLine {
	my (%params) = @_;

	my $errHandler = $params{'errHandler'} || \&Gm_Utils::gmWarn;
	my $filename = $params{'fn'} ? $params{'fn'} : 
		&$errHandler('Invalid fn parameter passed to _addFileLine');	
	my $line = $params{'line'} ? $params{'line'} : 
		&$errHandler('Invalid line parameter passed to _addFileLine');

	if( Gm_Security::hackClTest( $filename ) ){
		&$errHandler('We don\'t take kindly to that sort of activity here. '.
		'Your attempt to break the script has been logged and the administrators have '.
		'been notified. <br>');
		## TODO MAKE UTIL HACKNOTIFY FUNCTION
	}

	my $worked = 1; # init to worked
	
	if( $line ne Gm_Constants::EMPTY ){
		if( -e $filename ){
			## TODO USE PROPER FILE LOCKING
			## also do: open(my $FILE,">>$filename")
			$worked = open (THEFILE, ">>$filename");
			
			if( $worked ){ 		
				#Converting newlines and cleaning end of lines
				## TODO Makes this a Util function or at least make it so the 
				#the newline replace is a constant
				$line =~ s(\n)(\|\*\|)g;
				print THEFILE "$line\n";
				close (THEFILE);
				# Done saving to file			
			} else {
				## TODO: WE CAN TEST FOR WRITEABLILITY, DO SO FOR BETTER ERROR MESSAGE
				&$errHandler('Can\'t read file "'.$filename.'".  Please make sure that directory to save the file '.
				'is CHMODed to 777 and that the file is CHMODed to 666.  Also try running Diagnostics & Repair '.
				'from the Configuration screen.');
				$worked = 0;
			}
		
		} else {
			# executing error handler
			&$errHandler( 'The file "'.$filename.'" doesn\'t seem to exist.  Please check that '.
			'your files are in the correct location and that GreyMatter is configured '.
			'correctly.');
			$worked = 0;
		}
	} else {
		# executing error handler
		&$errHandler( 'Nothing was passed in to save to file "'.$filename.'".  '.
		'Please contact the site admin at TODO_PUT_EMAIL_HERE.');
		$worked = 0;
	}

	return $worked;
}


1;
