#!/usr/bin/perl

###############################################################################
# Greymatter 1.8.2                            
# Copyright (c)2000-2017, The Greymatter team 
# http://greymatterforum.proboards82.com/     
# By possessing this software, you agree not to hold the author responsible for 
# any problems that may arise from your installation or usage of Greymatter 
# itself, or from any content generated by yourself or others through the use of 
# this program.  You MAY freely modify and redistribute this program, so 
# long as every copyright notice (including in this manual and in the Greymatter 
# code) remains fully intact.  Finally, you may NOT sell or in any way 
# make a financial profit from this program, either in original or modified form.
# Your possession of this software signifies that you agree to these terms; 
# please delete your copy of this software if you don't agree to these terms.
# Original Creator Noah Grey
###############################################################################

use lib 'libs';

use CGI::Carp qw(fatalsToBrowser);
use Gm_Constants;
use Gm_Web;
use Gm_Core;
use Gm_Security;

require "gm-library.cgi";

### TODO: refactor into gm_uactions (Gm User Actions) to remove dependancy on gm-library.cgi

%IN = %{Gm_Web::getWebParams( errHandler=>\&Gm_Web::displayUserErrorExit )};

$userip = $ENV{'REMOTE_ADDR'};
$authorIP = $userip || 'userip';

&gm_readconfig;  ## this is duplicated, replace with global config reference
&gm_readtemplates;
&gm_readcounter;

if (($IN{'newcommentbody'} eq Gm_Constants::EMPTY ) && 
	($IN{'newcommentauthor'} eq Gm_Constants::EMPTY ) && ($IN{'gmsearch'} eq Gm_Constants::EMPTY )) {
	Gm_Web::displayUserErrorExit('No valid information was given.');
}

## validate entry id!!
if( ($IN{'gmsearch'} eq Gm_Constants::EMPTY ) ){
	## We are assuming we are submitting a comment or previewing if no data
	if( !defined( $IN{'newcommententrynumber'} ) ){
		## note that this caused errors with no feeedback (Internal Server Error).  Must find in 
		# other parts of code to prevent
		Gm_Web::displayUserErrorExit('The {{entrycommentsform}} is missing the "newcommententrynumber" '.
			'value, please fix your templates');
	} elsif( $IN{'newcommententrynumber'} =~ m/\D/gos ){
		## We got a non digit entered, more than likely, this is a hack attempt
		# TODO: INTEGRATE INTO GM_PHPHACKCHECK (AND RENAME), SO WE CAN EMAIL!
		Gm_Web::displayUserErrorExit('A invalid value was given for "newcommententrynumber" when commenting.');
	}
}

## Checking for people being naughty
&gm_phphackcheck;

#&gm_commentbancheck;
gm_commentbancheck( $userip );  ## Will redirect if bad

if ($IN{'gmsearch'} ne "") { 
	&gm_searchresults; 
}

# now gets tags with spaces
# and line breaks are handles via the /s modifier
## TODO make this generic, such as Sanitize Util or Web method
$IN{'newcommentauthor'} =~      s(<[^>]*>)()gs;
$IN{'newcommentemail'} =~       s(<[^>]*>)()gs;
$IN{'newcommenthomepage'} =~    s(<[^>]*>)()gs;

$IN{'newcommentbody'} =~        s/\|\*\|/\n/g;

$IN{'newcommentauthor'} =~      s/{/(/g;
$IN{'newcommentemail'} =~       s/{/(/g;
$IN{'newcommenthomepage'} =~    s/{/(/g;
$IN{'newcommentbody'} =~        s/{/(/g;
$IN{'newcommentauthor'} =~      s/}/)/g;
$IN{'newcommentemail'} =~       s/}/)/g;
$IN{'newcommenthomepage'} =~    s/}/)/g;
$IN{'newcommentbody'} =~        s/}/)/g;
$IN{'newcommentauthor'} =~      s/{/(/g;
$IN{'newcommentemail'} =~       s/{/(/g;
$IN{'newcommenthomepage'} =~    s/{/(/g;
$IN{'newcommentbody'} =~        s/{/(/g;
$IN{'newcommentauthor'} =~      s/}/)/g;
$IN{'newcommentemail'} =~       s/}/)/g;
$IN{'newcommenthomepage'} =~    s/}/)/g;
$IN{'newcommentbody'} =~        s/}/)/g;

$IN{'newcommentauthor'} =~      s/\|//g;
$IN{'newcommentemail'} =~       s/\|//g;
$IN{'newcommenthomepage'} =~    s/\|//g;
$IN{'newcommentbody'} =~        s/\|//g;

$IN{'newcommentauthor'} =~      s/"/\&quot;/g;
$IN{'newcommentemail'} =~       s/"/\&quot;/g;
$IN{'newcommenthomepage'} =~    s/"/\&quot;/g;
$IN{'newcommentbody'} =~        s/"/\&quot;/g;

$IN{'newcommentauthor'} =~      s/^\s+//;
$IN{'newcommentauthor'} =~      s/\s+$//;
$IN{'newcommentemail'} =~       s/^\s+//;
$IN{'newcommentemail'} =~       s/\s+$//;
$IN{'newcommenthomepage'} =~    s/^\s+//;
$IN{'newcommenthomepage'} =~    s/\s+$//;
$IN{'newcommentbody'} =~        s/^\s+//;
$IN{'newcommentbody'} =~        s/\s+$//;

$IN{'newcommentauthor'} =~      s/\n//g;
$IN{'newcommentemail'} =~       s/\n//g;
$IN{'newcommenthomepage'} =~    s/\n//g;
$IN{'newcommentauthor'} =~      s/\r//g;
$IN{'newcommentemail'} =~       s/\r//g;
$IN{'newcommenthomepage'} =~    s/\r//g;

$IN{'newcommentbody'} =~        s/\r//g;
$IN{'newcommentbody'} =~        s/\n/\|\*\|/g;
$IN{'newcommentbody'} =~        s/(\|\*\|\|\*\|){2,}/\|\*\|\|\*\|/g;
$IN{'newcommentbody'} =~        s/\|\*\|\|\*\|\|\*\|/\|\*\|\|\*\|/g;

$IN{'newcommentauthor'} = Gm_Utils::sanitizeInput($IN{'newcommentauthor'});
$IN{'newcommentemail'} = Gm_Utils::sanitizeInput($IN{'newcommentemail'});
$IN{'newcommenthomepage'} = Gm_Utils::sanitizeInput($IN{'newcommenthomepage'});
$IN{'newcommentbody'} = Gm_Utils::sanitizeInput($IN{'newcommentbody'});


$temphomepageprefix = substr($IN{'newcommenthomepage'}, 0, 7);
if ($temphomepageprefix ne "http://") { $IN{'newcommenthomepage'} = "http://$IN{'newcommenthomepage'}"; }

if ($IN{'newcommenthomepage'} eq "http://") { $IN{'newcommenthomepage'} = ""; }

$newcommententrynumberpadded = Gm_Utils::toEntryPadded( $IN{'newcommententrynumber'} );

my $gmEntry = Gm_Storage::getEntry( id=>$IN{'newcommententrynumber'},
	errHandler=>\&Gm_Web::displayUserErrorExit );

## TODO: refactor out usage of variables, make work directly off of entry
# ------------------------------------------------------
# PF 1.8.3
# This is to set up the post comment link
# ------------------------------------------------------

$thisentrynumber = $gmEntry->{'entryinfo'}{'id'};
$thisentryauthor = $gmEntry->{'entryinfo'}{'author'};
$thisentrysubject = $gmEntry->{'entryinfo'}{'subject'};
$thisentryweekdaynumber = $gmEntry->{'entryinfo'}{'weekday'};
$thisentrymonth = $gmEntry->{'entryinfo'}{'month'};
$thisentryday = $gmEntry->{'entryinfo'}{'day'};
$thisentryyearyear = $gmEntry->{'entryinfo'}{'year'};
$thisentryhour = $gmEntry->{'entryinfo'}{'hour'};
$thisentryminute = $gmEntry->{'entryinfo'}{'minute'};
$thisentrysecond = $gmEntry->{'entryinfo'}{'second'};
$thisentryampm = $gmEntry->{'entryinfo'}{'ampm'};
$thisentrypositivekarma = $gmEntry->{'entryinfo'}{'karmapos'};
$thisentrynegativekarma = $gmEntry->{'entryinfo'}{'karmaneg'};
$thisentrycommentsnumber = $gmEntry->{'entryinfo'}{'commenttotal'};
$thisentryallowkarma = $gmEntry->{'entryinfo'}{'karma'};
$thisentryallowcomments = $gmEntry->{'entryinfo'}{'comments'};
$thisentryopenstatus = $gmEntry->{'entryinfo'}{'status'};
$thisentrymusic = $gmEntry->{'entryinfo'}{'music'};
$thisentrymood = $gmEntry->{'entryinfo'}{'mood'};
$thisentryemoticonsallowed = $gmEntry->{'entryinfo'}{'emoticons'};


gm_allowedcheck();
gm_blankcheck();

if( $commentthrottle eq Gm_Constants::YES || $commentthrottle eq 'static' ){
	gm_commentthrottle( ip=>$authorIP, entry=>$gmEntry );
}
 
if( $protectauthorname eq 'STRICT' || $protectauthorname eq 'LOOSE' ){
	gm_authorcheck();
}
gm_linklimitcheck() if( $commentlinklimit eq 'block' || $commentlinklimit eq 'blockban' );

gm_referercheck() if( $commentverifyreferer eq Gm_Constants::YES );

# allow graphic buttons for comment form: linear 
if ( ($IN{'gmpostpreview'} ne "") || ($IN{'gmpostpreview.x'} ne "") ) {	
	gm_previewcomment();
} else {

	if( !_verifyPreview() ){
		## if force preview, check if var 'postit' only found on preview page
		gm_previewcomment();
	}

	if( $commentverify eq 'static' || $commentverify eq 'random' ){
		## if force preview, check if var 'postit' only found on preview page
		gm_forceverify();
	}	
	
	gm_addcomment();
	gm_freshenaftercomment();
}

# -------------
# check for ban
# -------------
sub gm_commentbancheck {
	my $useraddr = shift(@_);

	my $action = $IN{'gmsearch'} ? 'searching' : 'commenting';
	# Should this be in Gm_Web::
	Gm_Core::processBanCheck( ip=>$useraddr, action=>$action, 
		errHandler=>\&Gm_Web::displayUserErrorExit )
}

# -------------------------------
# check if comments can be posted
# -------------------------------

sub gm_allowedcheck {

	my $safeComment = Gm_Utils::toWebSafe( $IN{'newcommentbody'} );
	my $safeAuthor = Gm_Utils::toWebSafe( $IN{'newcommentauthor'} );

	if (($posttoarchives eq Gm_Constants::NO) && ($thisentrynumber <= $newarchivenumber)) {
		
		if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
			Gm_Core::writeToCplog( "A comment was blocked from being added to archived entry ".
				"#$IN{'newcommententrynumber'} (".Gm_Utils::sumMsg( $safeAuthor ).": ".
				Gm_Utils::sumMsg( $safeComment ).")",
				\&Gm_Web::displayUserErrorExit );
		}
		
		Gm_Web::displayUserErrorExit('Sorry - comments cannot be posted to archived '.
			'entries.  Please use your browser\'s Back button to return.');
	}

	if (($thisentryallowcomments eq Gm_Constants::NO) || ($generateentrypages eq Gm_Constants::NO) || 
		($thisentryopenstatus eq Gm_Constants::CLOSED) || ($allowkarmaorcomments eq Gm_Constants::KARMA) || 
		($allowkarmaorcomments eq Gm_Constants::NEITHER)) {
	
		if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
			Gm_Core::writeToCplog( "A comment was blocked from being added to entry #$IN{'newcommententrynumber'} ".
				"(".Gm_Utils::sumMsg( $safeAuthor ).": ".Gm_Utils::sumMsg( $safeComment ).")",
				\&Gm_Web::displayUserErrorExit );
		}
	
		Gm_Web::displayUserErrorExit('Sorry - comments cannot be posted to this '.
			'entry.  Please use your browser\'s Back button to return.');
	}

}

## GM Comment Throttle
# ARG ip: ip address to check for commenting
# ARG entry: the entry whose comments we are checking
# Will check that the commenter does not comment more often then allowed
## TODO: Make so this ignores the blog authors
sub gm_commentthrottle {
	my (%params) = @_;

	my $currentip = $params{'ip'} || $ENV{'REMOTE_ADDR'};
	my $gmEntry = $params{'entry'} || {};
	
	my ($skip, $wday, $month, $day, $year, $hour, $min, $sec, $AMPM ) = 
		Gm_Utils::getStdDate( $serveroffset );
	
	my ($commentNum, $lastComment) = _getCommentInfo( $gmEntry->{'comments'}, $year, $month, $day );

	# if there is a last comment && day/month/year matches
	if( $commentNum ){
		## convert last comment and current time to minutes, since throttleing is day to day
		my $currentMins = $hour * 60 + $min;	
		my $commentMins = $lastComment->{'hour'} * 60 + $lastComment->{'minute'};

		## if static throttle, add throttle to last comment		
		my $minOffset = $commentthrottlemin;
		
		## if exponetial throttle, square the number of comments & add to last comment
		if( $commentthrottle eq Gm_Constants::YES ){
			$minOffset = $commentNum * $commentNum;
		}
	
		$commentMins += $minOffset;
		## if current minutes < last comment minutes show error message
		if( $currentMins < $commentMins ){
			## Add CPLOGing for this here?
		
			Gm_Web::displayUserErrorExit( "You may not post another comment withen $minOffset minutes ".
				"of your last comment." );
		}
	}
}

# Private sub to count commenter information
# ARG 1: Array of comments
# ARG 2: Year
# ARG 3: Month
# ARG 4: Day
# RETURNS: number of comments for the given day, and the last comment on that day, or 
#  empty hash if  no comment
sub _getCommentInfo {
	my $comments = shift( @_ ) || [];
	my $year = shift( @_ ) || 0;
	my $month = shift( @_ ) || 0;
	my $day = shift( @_ ) || 0;
	
	my $commentCount = 0;
	my $lastComment = { hour=>0, minute=>0 };
	
	foreach my $comment ( @{$comments} ){
		if( $comment->{'year'} eq $year && $comment->{'month'} eq $month && $comment->{'day'} eq $day ){
			$commentCount++;
			$lastComment = $comment;
		}
	}
	
	return( $commentCount, $lastComment );
}


## GM Link Limit
# Args: ?
# Will check that the commenters does not contain more links than allowed by
# the configuration setting.
sub gm_linklimitcheck {

	my $linkCount = _countLinks( $IN{'newcommentbody'} );

	if( $linkCount > $commentlinklimitnum ){

		my $safeAuthor = Gm_Utils::sumMsg( Gm_Utils::toWebSafe( $IN{'newcommentauthor'} ) );
	
		## if blockban, ban them
		if( $commentlinklimit eq 'blockban' ){
			## TODO, SHOULD CONVERT THE $IN VAR TO WEBSAFE! SPECIFICALLY, SCRUB HREFS FULL, PARTIAL
			Gm_Storage::addBanlist( ip=>$authorIP, host=>$authorIP, 
				label=>"autobanned: $safeAuthor", errHandler=>\&Gm_Web::displayUserErrorExit );
		}
		
		## Logging	
		my $cpMsg = "<span class=\"error_msg\">'$safeAuthor' ($authorIP) was blocked ";
		## banned the spammer too
		if( $commentlinklimit eq 'blockban' ){
			$cpMsg .= 'and banned (autobanned) ';		
		}
		$cpMsg .=	"for posting a comment with $linkCount links ($commentlinklimitnum allowed).</span>";
		Gm_Core::writeToCplog(  $cpMsg,	\&Gm_Web::displayUserErrorExit );	
	
		## report back to user that they have been blocked and/or banned
		my $userMessage = "You have submitted a comment with more links than allowed. ".
			"Your comment has not been posted";
		if( $commentlinklimit eq 'blockban' ){
			$userMessage .= " and you have been banned from posting further comments";		
		}
		Gm_Web::displayUserErrorExit( $userMessage."." );
	}
}


## GM Link Limit
# Args: ?
# Will check that the commenters does not contain more links than allowed by
# the configuration setting.
sub gm_referercheck {

	my $referer = $ENV{'HTTP_REFERER'} || '';
	## check if commenter is coming from cgi path, archive path, or entries path; matches start of incoming URL
	unless( $referer =~ m/^$EntriesWebPath/i || $referer =~ m/^$cgiwebpath/i || $referer =~ m/^$LogWebPath/i ){
		## Logging	
		my $cpMsg = "<span class=\"error_msg\">($authorIP) attempted to illegally post to entry #".
			$IN{'newcommententrynumber'}." from '".Gm_Utils::sumMsg( Gm_Utils::toWebSafe( $referer ) ).
			"'</span>";
		Gm_Core::writeToCplog(  $cpMsg, \&Gm_Web::displayUserErrorExit );	
	
		## report back to user that they have been blocked
		my $userMessage = "You have submitted a comment from an external site, this is prohibited.";
		Gm_Web::displayUserErrorExit( $userMessage );
	}
}


# ------------------------------
# check if name or body is blank
# ------------------------------
sub gm_blankcheck {
	if (($IN{'newcommentauthor'} eq Gm_Constants::EMPTY) || ($IN{'newcommentbody'} eq Gm_Constants::EMPTY)) {
		Gm_Web::displayUserErrorExit('You left either your name or your comments '.
			'blank.  Please use your browser\'s Back button to return.');
	}
}

## Verify Preview
# will verify if the comment is previewed if it is required to be
# RETURNS: 1 if the comment is previewed or doens't need to be, 0 if fails
sub _verifyPreview {
	my $previewed = 0;

	if( $commentforcepreview eq Gm_Constants::YES || $commentforcepreview eq 'rand' ){ 
	
		# checking for 'postit' variable
		if( exists( $IN{'postit'} ) ){
			$previewed = 1;
		}
		
		# checking if rand is required and provided
		if( $previewed && $commentforcepreview eq 'rand' ){ 
			unless( _verifyRandomPhrase( $commentverifyphrase, $IN{'previewrand'} ) ){
				## provided random phrase didn't match
				my $cpMsg = "<span class=\"error_msg\">'$authorIP attempted to post without Previewing entry #".
					$IN{'newcommententrynumber'}."</span>";
				Gm_Core::writeToCplog(  $cpMsg, \&Gm_Web::displayUserErrorExit );	
		
				Gm_Web::displayUserErrorExit('You do not seemed to have "Previewed" the comment, '.
					'this is required for posting comments on this site.  All comments must be posted '.
					'within three minutes of "Previewing".');
			} 
		}
	} else {
		# we are not forcing preview, so we return 1
		$previewed = 1;
	}

	
	return $previewed;
}

# ------------------------------
# preview comment before posting
# ------------------------------

sub gm_previewcomment {

my ($skip, $wday, $mon, $mday, $JSYear, $hour, $min, $sec, $AMPM ) = 
	Gm_Utils::getStdDate( $serveroffset );

my $entryVars = Gm_Core::getEntryVariables( entryid=>$IN{'newcommententrynumber'}, 
	errHandler=>\&Gm_Web::displayUserErrorExit );

if ($entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY ) {
	if ($thisentrynumber <= $newarchivenumber) {
		$commentpreviewpage = $gmmorearchiveentrypagetemplate;
	} else {
		$commentpreviewpage = $gmmoreentrypagetemplate;
	}
} else {
	if ($thisentrynumber <= $newarchivenumber) {
		$commentpreviewpage = $gmarchiveentrypagetemplate;
	} else {
		$commentpreviewpage = $gmentrypagetemplate;
	}
}


$thisentrycomments = "";
$thisentrycommentsnumber = 1;
# $thispreviewcounter = $thisentrycommentsnumber + 3;

$IN{'newcommentauthor'} =~ s/\&quot;/"/g;
$IN{'newcommentemail'} =~ s/\&quot;/"/g;
$IN{'newcommenthomepage'} =~ s/\&quot;/"/g;
$IN{'newcommentbody'} =~ s/\&quot;/"/g;
$IN{'newcommentbody'} =~ s/\|\*\|/\n/g;

## Used by collatecomments, creating a new comment
my %newComment = ();
$newComment{'name'} = $IN{'newcommentauthor'};
$newComment{'ip'} = $userip;
$newComment{'email'} = $IN{'newcommentemail'};
$newComment{'homepage'} = $IN{'newcommenthomepage'};
$newComment{'weekday'} = $wday;
$newComment{'month'} = $mon;
$newComment{'day'} = $mday;
$newComment{'year'} = $JSYear;
$newComment{'hour'} = $hour;
$newComment{'minute'} = $min;
$newComment{'second'} = $sec;
$newComment{'ampm'} = $AMPM;
$newComment{'comment'} = $IN{'newcommentbody'};
push( @{$gmEntry->{'comments'}}, \%newComment );

$IN{'newcommentauthor'} =~ s/"/\&quot;/g;
$IN{'newcommentemail'} =~ s/"/\&quot;/g;
$IN{'newcommenthomepage'} =~ s/"/\&quot;/g;
$IN{'newcommentbody'} =~ s/"/\&quot;/g;
$IN{'newcommentbody'} =~ s/\n/\|\*\|/g;

$previewcommentauthor = $IN{'newcommentauthor'};
if( $protectauthorname ne Gm_Constants::NO ){
	## TODO: FIX THIS, ITS UGLY.  ADDED FUNCTIONALITY SHOULDN'T MODIFY THIS FUNCTION
	## have a check for previewing in gm_authorcheck, and remove this if
	$previewcommentauthor = $IN{'newcommentauthor_org'};
}

$previewcommentemail = $IN{'newcommentemail'};
$previewcommenthomepage = $IN{'newcommenthomepage'};
$previewcommentbody = $IN{'newcommentbody'};

## THIS VAR NOT NEEDED?
my $thisentrycomments = Gm_Core::collateComments( entry=>$gmEntry, 
	errHandler=>\&Gm_Web::displayUserErrorExit );
$entryVars->{'thisentrycomments'} = $thisentrycomments;

$commentpreviewpage =~ s/{{commentdivider}}/$gmcommentpreviewdividertemplate/gi;
$commentpreviewpage =~ s/{{entrycommentsform}}/$gmcommentpreviewformtemplate/gi;
$commentpreviewpage =~ s/{{previewcommentauthor}}/$previewcommentauthor/gi;
$commentpreviewpage =~ s/{{previewcommentemail}}/$previewcommentemail/gi;
$commentpreviewpage =~ s/{{previewcommenthomepage}}/$previewcommenthomepage/gi;
$commentpreviewpage =~ s/{{previewcommentbody}}/$previewcommentbody/gi;

if( $commentforcepreview eq 'rand' ){
	my $previewrand = _generateRandomPhrase( $commentverifyphrase );
	$commentpreviewpage =~ s/{{previewrand}}/$previewrand/gi;
}

my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
	template=>$commentpreviewpage, errHandler=>\&Gm_Web::displayUserErrorExit );

println( Gm_Web::createRequestHeader() );

print<<PREVIEWCOMMENT;

$entryreturn

PREVIEWCOMMENT

exit;

}

# --------------------------
# so add the comment already
# --------------------------

sub gm_addcomment {
	
	my ($skip, $wday, $mon, $mday, $JSYear, $hour, $min, $sec, $AMPM ) = 
		Gm_Utils::getStdDate( $serveroffset );

	my %comment = ();
	$comment{'name'} = $IN{'newcommentauthor'};
	$comment{'ip'} = $userip;
	$comment{'email'} = $IN{'newcommentemail'};
	$comment{'homepage'} = $IN{'newcommenthomepage'};
	$comment{'weekday'} = $wday;
	$comment{'month'} = $mon;
	$comment{'day'} = $mday;
	$comment{'year'} = $JSYear;
	$comment{'hour'} = $hour;
	$comment{'minute'} = $min;
	$comment{'second'} = $sec;
	$comment{'ampm'} = $AMPM;
	$comment{'comment'} = $IN{'newcommentbody'};
	
	Gm_Storage::addEntryComment( id=>$IN{'newcommententrynumber'}, %comment, 
		errHandler=>\&Gm_Web::displayUserErrorExit );

}

# ------------------------
# primp, preen, take a bow
# ------------------------

sub gm_freshenaftercomment {

my $entryreturn = '';

$newalltimecommentstotalnumber++;
&gm_writecounter;

# -------------------------------------------
# PF 1.8.3 
# use the built in comment link
# -------------------------------------------
#$aftermath = "$EntriesWebPath/$newcommententrynumberpadded.$entrysuffix#comments";


my $entryVars = Gm_Core::getEntryVariables( entryid=>$IN{'newcommententrynumber'}, errHandler=>\&Gm_Web::displayUserErrorExit );

# -------------------------------------------
# PF 1.8.3 
# use the built in comment link
# -------------------------------------------

$aftermath = $entryVars->{'thisentrycommentspostlink'};

if ($entryVars->{'thisentrymorebody'} ne Gm_Constants::EMPTY ) {
	if ($entryVars->{'thisentrynumber'} <= $newarchivenumber) {

		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$gmmorearchiveentrypagetemplate, errHandler=>\&Gm_Web::displayUserErrorExit );
	} else {

		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$gmmoreentrypagetemplate, errHandler=>\&Gm_Web::displayUserErrorExit );
	}
} else {
	if ($entryVars->{'thisentrynumber'} <= $newarchivenumber) {

		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
			template=>$gmarchiveentrypagetemplate, errHandler=>\&Gm_Web::displayUserErrorExit );
	} else {

 		$entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
 			template=>$gmentrypagetemplate, errHandler=>\&Gm_Web::displayUserErrorExit );
	}
}
# ---------------------------------------------------------------------
# PF 1.8.3
# Just use the filename stored in the hash
# ----------------------------------------------------------------------
#&Gm_Trace::Trace(level => 3, msg => "saveFile[2.8]");
Gm_Storage::saveFile( loc=>"$EntriesPath/$entryVars->{'thisentrylink'}.$entrysuffix", 
	content=>[$entryreturn], errHandler=>\&Gm_Web::displayUserErrorExit );

if ($entryVars->{'thisentrynumber'} <= $newarchivenumber) {
	&gm_readcounter;
# 	$stoppednumber = $newarchivenumber;
# 	do { &gm_generatearchive($stoppednumber); } until $stoppednumber <= 1;
# 	if( $gmneedstogeneratefirstarchive ){ &gm_generatearchive(1); }
	## startnum could be more precise, if we could figure out which entry starts the month of the 
	# entry that was commented on, we could give that and tell to only build it, instead of all archives
	Gm_Core::constructArchives( startnum=>$newarchivenumber,  
		errHandler=>\&Gm_Web::displayUserErrorExit );
} else {
#	&gm_generatemainindex;
	Gm_Core::constructMainIndex( errHandler=>\&Gm_Web::displayUserErrorExit );
}

&gm_readconfig;

if (($NotifyForStatus eq Gm_Constants::COMMENTS) || ($NotifyForStatus eq Gm_Constants::BOTH)) {
if ($NotifyEmail ne "") {

	$formattedcomment = $IN{'newcommentbody'};
	$formattedcomment =~ s/\|\*\|/\n/g;
	
	my $emailBody = "A comment has just been posted to entry #$IN{'newcommententrynumber'} ".
	"($thisentrysubject).\n\nName: $IN{'newcommentauthor'} (IP: $userip)\nE-Mail: ".
	"$IN{'newcommentemail'}\nHomepage: $IN{'newcommenthomepage'}\n\nComments: ".
	"$formattedcomment\n\nPosted to: $aftermath\n";

	Gm_Core::sendEmail( to=>$NotifyEmail, subject=>"Comment Posted to #$IN{'newcommententrynumber'} ".
		"at $LogWebPath", body=>$emailBody ); 

	}  ## end if
}

if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
	my ($gmdate) = Gm_Utils::getStdDate( $serveroffset );
	Gm_Core::writeToCplog( "<I>$IN{'newcommentauthor'} added a comment to entry #$IN{'newcommententrynumber'} ".
		"($thisentrysubject)</I>", \&Gm_Web::displayUserErrorExit );
}

## Time to send user back to page came from
Gm_Web::displayUserRedirectExit( $aftermath );

}

# --------------
# search results
# --------------

sub gm_searchresults {

$searchmatchescount = 0;
$searchresultbody = '';

$IN{'gmsearch'} =~ s/\|//g;
# search robustness improvement
$IN{'gmsearch'} = quotemeta($IN{'gmsearch'});  ### USE THIS FOR MAKING OTHER STUFF SAFE FOR LOGGING?
## truncating to 35 chars try to prevent against web based attacks
$IN{'gmsearch'} = substr( $IN{'gmsearch'}, 0, 35);


&gm_readconfig;
&gm_readcounter;
&gm_readtemplates;

$countfromhere = $newentrynumber;

while( $countfromhere > 0 ){
## changed do ... while X eq '0'  TO while X > 0
# WHY:  extremely dangerous to assume that X is valid, and by doing a 'do' without
# check its value, you open yourself to infinite loops, because a non number, or number
# less than 0 will never 'eq "0"'.  While a non-number will always register as NOT
# greater than 0

	my $entryVars = Gm_Core::getEntryVariables( entryid=>$countfromhere, 
		errHandler=>\&Gm_Web::displayUserErrorExit );
	unless ($entryVars->{'thisentryopenstatus'} eq Gm_Constants::CLOSED) {

## TODO: REFACTOR THIS TO:
# 1. GIVE EACH MATCH A RATING (BASED ON OCCURANCES)
# 2. ALLOW USER TO SWITCH WHETHER SORTED BY DATE, OR RATING
# 3. ONCE TAGS ARE USED, WEIGHT TAGS MORE HEAVILY
# 4. BREAK APART QUERY TO DO 'OR' TYPE LOGIC, WITH AND MATCHES HAVING HEAVIER RATING
####

		if (($entryVars->{'thisentrysubject'} =~ m/$IN{'gmsearch'}/i) || 
		($entryVars->{'thisentryauthor'} =~ m/$IN{'gmsearch'}/i) || 
		($entryVars->{'thisentrymainbody'} =~ m/$IN{'gmsearch'}/i) || 
		($entryVars->{'thisentrymorebody'} =~ m/$IN{'gmsearch'}/i) || 
		($entryVars->{'thisentrycomments'} =~ m/$IN{'gmsearch'}/i) || 
		($entryVars->{'thisentrymusic'} =~ m/$IN{'gmsearch'}/i) || 
		($entryVars->{'thisentrymood'} =~ m/$IN{'gmsearch'}/i)) {

			my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
				template=>$gmsearchresultsentrytemplate, errHandler=>\&Gm_Web::displayUserErrorExit );
			$searchresultbody .= $entryreturn;
			$searchmatchescount++;

		}

	}

	$countfromhere--;
}

# XSS scripting mitigation
$IN{'gmsearch'} =~ s/</&lt;/g;
$IN{'gmsearch'} =~ s/>/&gt;/g;

$searchpage = $gmsearchresultspagetemplate;
$searchpage =~ s/{{searchterm}}/$IN{'gmsearch'}/g;
$searchpage =~ s/{{searchmatches}}/$searchmatchescount/g;
$searchpage =~ s/{{searchresults}}/$searchresultbody/g;

my $entryVars = Gm_Core::getEntryVariables( entryid=>1, errHandler=>\&Gm_Web::displayUserErrorExit );
my $entryreturn = Gm_Core::translateEntryTemplates( entryVars=>$entryVars,
	template=>$searchpage, errHandler=>\&Gm_Web::displayUserErrorExit );


println( Gm_Web::createRequestHeader() );

print<<SHOWSEARCHRESULTS;

$entryreturn

SHOWSEARCHRESULTS

if (($keeplog eq Gm_Constants::YES) && ($logkarmaandcomments eq Gm_Constants::YES)) {
	## do we really need to display an error on this?
	## TODO, SHOULD CONVERT THE $IN VAR TO WEBSAFE! SPECIFICALLY, SCRUB HREFS FULL, PARTIAL
	Gm_Core::writeToCplog( "<I>A search was performed for \"".
		Gm_Utils::sumMsg($IN{'gmsearch'})."\" ".
		"($searchmatchescount matches)</I>", \&Gm_Web::displayUserErrorExit );
}

exit;
}

# ------------------------------ 
# check if there's a lame PHP tag attempt 
# ------------------------------ 
## this should be provice of security or Core, more likely Core since Security is mostly the auth realm
sub gm_phphackcheck { 

if ( Gm_Security::hackWebTest( $IN{'newcommentauthor'} ) || 
		Gm_Security::hackWebTest( $IN{'newcommentbody'} ) || 
		Gm_Security::hackWebTest( $IN{'newcommentemail'} ) || 
		Gm_Security::hackWebTest( $IN{'newcommenthomepage'} ) ){
    my ($gmdate) = Gm_Utils::getStdDate( $serveroffset );    
 
    if ($mailhacknotice eq Gm_Constants::YES) {
    &gm_readconfig;
    my $safeComment = Gm_Utils::toWebSafe( $IN{'newcommentbody'} );
    my $safeAuthor = Gm_Utils::toWebSafe( $IN{'newcommentauthor'} );
    my $safeEmail = Gm_Utils::toWebSafe( $IN{'newcommentemail'} );
    my $safeHomepage = Gm_Utils::toWebSafe( $IN{'newcommenthomepage'} );
    if ($NotifyEmail ne "") {
  
			my $emailMsg = "A hacker was blocked from an attack against entry ".
				"#$IN{'newcommententrynumber'}\n\n(data entered by hacker was made web safe)\n".
				"Name: $safeAuthor (IP: $userip)\nE-Mail: $safeEmail\nHomepage: $safeHomepage\n".
				"\nComments: $safeComment\n";
 
			Gm_Core::sendEmail( to=>$NotifyEmail, subject=>'Notice: Comment hack attempt logged', 
				body=>$emailMsg );
		}
	} 

	if ($keepphphacklog eq Gm_Constants::YES) { 
	# scrub the string a bit so we can log it cleanly
	my $safeAuthor = Gm_Utils::toWebSafe( $IN{'newcommentauthor'} );
	my $safeComment = Gm_Utils::toWebSafe( $IN{'newcommentbody'} );

	## TODO, SHOULD CONVERT THE $IN VAR TO WEBSAFE! SPECIFICALLY, SCRUB HREFS FULL, PARTIAL
	Gm_Core::writeToCplog( "<b>A script kiddie was blocked</b> from a comment attack against entry ".
		"#$IN{'newcommententrynumber'} (".Gm_Utils::sumMsg( $safeAuthor ).": ".
		Gm_Utils::sumMsg( $safeComment ).")",
		\&Gm_Web::displayUserErrorExit );
    } 

	Gm_Web::displayUserErrorExit("We don't take kindly to that sort of activity here. ".
		"Your attempt to break the script has been logged and the administrators have ".
		"been notified. <br>[$gmdate] [$userip]"); 
    
   ## Checking the search string 
	} elsif( Gm_Security::hackWebTest( $IN{'gmsearch'} ) || 
		Gm_Security::hackClTest( $IN{'gmsearch'} ) ){

    my ($gmdate) = Gm_Utils::getStdDate( $serveroffset ); 
		my $safeSearch = Gm_Utils::toWebSafe( quotemeta( $IN{'gmsearch'} ) );
 
    if ($mailhacknotice eq Gm_Constants::YES) {
			&gm_readconfig;
			if ($NotifyEmail ne "") {
			
				my $emailMsg = "A hacker was blocked from a script attack while searching\n\n".
					"IP: $userip\nSearch: $safeSearch\n";
	 
				Gm_Core::sendEmail( to=>$NotifyEmail, subject=>'Notice: Search hack attempt logged', 
					body=>$emailMsg );
			
			}
		} 

    if ($keepphphacklog eq Gm_Constants::YES) { 
			# scrub the string a bit so we can log it cleanly
			Gm_Core::writeToCplog( "<b>A script kiddie was blocked</b> from a script attack while searching: ".
				'"'.Gm_Utils::sumMsg( $safeSearch ).'"',
				\&Gm_Web::displayUserErrorExit );
    } 

		Gm_Web::displayUserErrorExit("We don't take kindly to that sort of activity here. ".
			"Your attempt to break the script has been logged and the administrators have ".
			"been notified. <br>[$gmdate] [$userip]"); 
	}
}
 

## GM Author Check
# Will check that the commenters name does not contain an author name.  If it does
#  will check that the comment author string is "AUTHOR_PASSWORD" and use the password
#  to verify the identity of the author.
sub gm_authorcheck {

	## so that preview works, using org var, since we need to keep the 'Name_Pw'
	# note that we are _always_ setting this so that if we preview, a valid value
	# goest into the commentauthorname isn't a gm author ...
	$IN{'newcommentauthor_org'} = $IN{'newcommentauthor'};

	my $gmauthors = Gm_Storage::getAuthors( errHandler=>\&Gm_Web::displayUserErrorExit );	

	# because the AUTHOR_PASSWORD comes in as a single string and is compared with the list of
	# blog authors we need to extract the name first here to check with the GM names to ensure
	# that the name passed with a _PASSWORD is a correct author name. We need to reverse the string to ensure
	# that we still extract the name and password even if the name includes an underscore.
	## only need to setup commenter namepassword once
	my $authorname = '';
	my $auth_pw = '';
	if ( $IN{'newcommentauthor'} =~ m/_/g ){
		($auth_pw, $authorname) = split( '_', reverse( $IN{'newcommentauthor'} ), 2);
		$auth_pw = reverse( $auth_pw );
		$authorname = reverse( $authorname );
	} else {
		$authorname = $IN{'newcommentauthor'};
	}

	foreach my $author ( keys( %$gmauthors ) ) {
		my $a_name = $gmauthors->{$author}{'author'};
		my $a_password = $gmauthors->{$author}{'password'};
		my $a_email = $gmauthors->{$author}{'email'};
		my $a_homepage = $gmauthors->{$author}{'homepage'};
		
		my $commenter_auth_match = 0;
		if( $protectauthorname eq 'STRICT'  && $authorname =~ m/^$a_name$/i){
			## got a strict match, does catch leading white space
			$commenter_auth_match = 1;
		}

		if( $protectauthorname eq 'LOOSE' && $authorname =~ m/$a_name/i){
			## Loose matching, only has to contain name
			$commenter_auth_match = 1;
		}
	
		## we are doing a regex to get a match since we don't want to be fooled by leading spaces (or case)
		if( $commenter_auth_match ){
			## We got an athor name match, lets check the pw
			my $commentpassword = crypt($auth_pw, $auth_pw);
			
			## hmm, we are checking if the password matches both the plain and the crypted, because of Alice ...
			if ( ($a_password eq $commentpassword) || ($a_password eq $auth_pw) ){
				$IN{'newcommentauthor'} = $a_name;
				$IN{'newcommenthomepage'} = $a_homepage;
				$IN{'newcommentemail'}= $a_email;
			
			} else {
				## Good to let someone know that people are trying to impersonate
				Gm_Core::writeToCplog( "<B><FONT COLOR=\"#dd0000\">Invalid Password commenting on entry ".
					"#$IN{'newcommententrynumber'}:</font></B> $IN{'newcommentauthor'} ", 
					\&Gm_Web::displayUserErrorExit );

				Gm_Web::displayUserErrorExit('You cannot use that name to '.
					'post a comment without the correct password. Please pick '.
					'another name or check your password.' );
			}
		}
	}
}

## GM Force Verify
# Args: ?
# Will display a screen that allows the user to enter a pass-phrase to verify
# before the comment is posted.
sub gm_forceverify {

	# check if verifying
	if( $IN{'userverify'} ){
		# verify  match
		if( $IN{'userphrase'} ne $commentverifyphrase && 
			!_verifyRandomPhrase( $commentverifyphrase, $IN{'userphrase'} )){
			_showVerifyScreen( _generateRandomPhrase( $commentverifyphrase ), 
			'<FONT COLOR="#dd0000">Phrase entered did not match, please try again.</font>' );
		}
	} else {
		if( $commentverify eq 'static' ){
			_showVerifyScreen( $commentverifyphrase );
		} else {
			_showVerifyScreen( _generateRandomPhrase( $commentverifyphrase ) );
		}
	}
	
	## if everything is fine, fall through
}

sub _showVerifyScreen {
	my $phrase = shift( @_ );
	my $err = shift( @_ );
	
	my $userMessage = '';
	if( $err ){
		$userMessage .= "<p>$err</p>\n";
	}
		
	my $commentAuthor = $IN{'newcommentauthor'};
	if( $protectauthorname ne Gm_Constants::NO ){
		## TODO: FIX THIS, ITS UGLY.  ADDED FUNCTIONALITY SHOULDN'T MODIFY THIS FUNCTION
		## have a check for previewing in gm_authorcheck, and remove this if
		$commentAuthor = $IN{'newcommentauthor_org'};
	}
		
	$userMessage .= '<form ACTION="gm-comments.cgi" METHOD=POST><table>'."\n";
	## postit && previewrand is for previewing and rest is comment
	## TODO: THESE SHOULD BE PUT INTO GLOBAL HASH SOMEWHERE TO PREVENT DUPLICATION
	$userMessage .= '<INPUT TYPE=HIDDEN NAME="postit" VALUE="postit">'."\n";
	$userMessage .= '<input type="hidden" name="previewrand" value="'.
		$IN{'previewrand'}.'" />'."\n";
	$userMessage .= '<input type="hidden" name="newcommententrynumber" value="'.
		$IN{'newcommententrynumber'}.'" />'."\n";
	$userMessage .= '<input type="hidden" name="newcommentauthor" value="'.
		$commentAuthor.'" />'."\n";
	$userMessage .= '<input type="hidden" name="newcommentemail" value="'.
		$IN{'newcommentemail'}.'" />'."\n";
	$userMessage .= '<input type="hidden" name="newcommenthomepage" value="'.
		$IN{'newcommenthomepage'}.'" />'."\n";
	$userMessage .= '<input type="hidden" name="newcommentbody" value="'.
		$IN{'newcommentbody'}.'" />'."\n";
	
	$userMessage .= '<tr><td colspan="2"><p> As a final step before posting your '.
		'comment, please enter the letters and numbers you see below.<br /> '.
		'This test is used to prevent automated robots from posting comments.</p> </td></tr>'."\n";
	$userMessage .= '<tr><td align="center" valign="center"><p><span style="font-weight: bold;'.
		'border: 1px solid #000; padding: 5px;">'.$phrase.'</span></p></td>'."\n";	
	$userMessage .= '<td><p><INPUT TYPE=TEXT NAME="userphrase" SIZE=15 MAXLENGTH=15 tabindex="1"> '."\n";	
	$userMessage .= '<INPUT TYPE=SUBMIT NAME="userverify" VALUE="Post Comment"> </p></td></tr>'."\n";
	$userMessage .= '</table></form><br />'."\n";

	Gm_Web::displayUserErrorExit( $userMessage );
}

## Private subroutine to count links
# ARG 1: string containing links
# RETURN: the number of links, 0 if none
sub _countLinks {
	my $text = shift(@_);
	$text =~ s/\|\*\|/ /g; ## we need to use whitespace to isolate links
	$text = $text.' '; ## ditto, a link at the end will go uncounted
	my $count = 0;

	## Explanation, we are going from the longest way 
	# to create a link, to the shortest, however, to avoid counting the same
	# link twice, we replacing the links with empty space
	# Looking for pattern "<a href=...</a>"
	$count += ($text =~ s/(<a\s+?href\=.*?<\/a>)/ /gi);
	# Looking for pattern "http://... "
	$count += ($text =~ s/(http:\/\/.*?\s)/ /gi);
	# Looking for pattern "www.... "
	$count += ($text =~ s/(www\..*?\s)/ /gi);

	return( $count );
}

## Private subroutine to verify a psuedo random phrase
# this does this by generating 3 random phrases, a phrase for the current minute,
# the minute before, and the minute before that.  This gives the random phrase
# a three minute lifetime
# ARG 1: seed, probably from the config file
# ARG 2: value to check against, probably previously generated Random Phrase
# RETURN: 0 or no match, 1 if match
sub _verifyRandomPhrase {
	my $seed = shift(@_);
	my $val = shift(@_);
	
	my $ret = 0;
	
	## Lets loop through and check if this 'val' was generated in last three minutes
	for( my $i = 0; $i > -3; $i-- ){
		my $phrase = _generateRandomPhrase( $seed, $i );
		if( $phrase eq $val ){
			$ret = 1;
		}
	}
	
	return( $ret );
}

## Private subroutine to generate a psuedo random phrase
# ARG 1: seed of random phrase
# ARG 2: offset pertaining to minutes variable used in phrase, to make phrases that
# 'expire'
# RETURN: repeatable, random phrase
## TODO: this should filter out confusing letters/numbers (i.e. zero and capital o,
# capital i and lowercase l)
sub _generateRandomPhrase {
	my $c = shift(@_);
	my $offset = shift(@_);
	$offset = defined( $offset ) ? $offset : '0';
	
	my ($skip, $wday, $mon, $mday, $JSYear, $hour, $min ) = Gm_Utils::getStdDate( $serveroffset );
	
	## using off set
	my $newmin = $min + $offset;
	if( $newmin > 60 ){
		$newmin = $newmin - 60;
	} elsif( $newmin < 0 ){
		$newmin = $newmin + 60;
	}
	my $b = "$newmin$mday$mon";
	my $a = $ENV{'REMOTE_ADDR'};


	## b is used as salt since its dynamic, on the minute
	$a = crypt($a, $b);
	$b = crypt($b, $b);
	$c = crypt($c, $b);
	
	## get rid of all non-alphanumerics (which includes _ so we and it in)
	$a =~ s/[^\w]|_//g; 
	$b =~ s/[^\w]|_//g;
	$c =~ s/[^\w]|_//g;
	
	$a = lc($a);
	$b = lc($b);
	$c = lc($c);
	## don't want to take from beging because salt is added to first part of word
	my $ret_string = substr( $a, -2, 2 ).substr( $b, -2, 2 ).substr( $c, -3, 3 );
	
	return( $ret_string );
}


